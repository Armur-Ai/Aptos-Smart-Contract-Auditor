[
    {
        "code": "module LendingPlatform { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct LendingPool<phantom CoinType> has key { total_deposits: u64, total_borrows: u64, interest_rate: u64, last_update_timestamp: u64, } struct UserAccount<phantom CoinType> has key { deposit_balance: u64, borrow_balance: u64, last_interaction_timestamp: u64, } const E_NOT_INITIALIZED: u64 = 1; const E_ALREADY_INITIALIZED: u64 = 2; const E_INSUFFICIENT_BALANCE: u64 = 3; const E_BORROW_LIMIT_EXCEEDED: u64 = 4; public fun initialize<CoinType>(account: &signer, initial_interest_rate: u64) { let sender = signer::address_of(account); assert!(!exists<LendingPool<CoinType>>(sender), E_ALREADY_INITIALIZED); move_to(account, LendingPool<CoinType> { total_deposits: 0, total_borrows: 0, interest_rate: initial_interest_rate, last_update_timestamp: timestamp::now_seconds(), }); } public fun deposit<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserAccount { let sender = signer::address_of(account); assert!(exists<LendingPool<CoinType>>(sender), E_NOT_INITIALIZED); let pool = borrow_global_mut<LendingPool<CoinType>>(sender); pool.total_deposits = pool.total_deposits + amount; if (!exists<UserAccount<CoinType>>(sender)) { move_to(account, UserAccount<CoinType> { deposit_balance: 0, borrow_balance: 0, last_interaction_timestamp: timestamp::now_seconds(), }); } let user_account = borrow_global_mut<UserAccount<CoinType>>(sender); user_account.deposit_balance = user_account.deposit_balance + amount; user_account.last_interaction_timestamp = timestamp::now_seconds(); coin::transfer<CoinType>(account, sender, amount); } public fun borrow<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserAccount { let sender = signer::address_of(account); assert!(exists<LendingPool<CoinType>>(sender), E_NOT_INITIALIZED); let pool = borrow_global_mut<LendingPool<CoinType>>(sender); assert!(pool.total_deposits >= pool.total_borrows + amount, E_INSUFFICIENT_BALANCE); let user_account = borrow_global_mut<UserAccount<CoinType>>(sender); let collateral_ratio = user_account.deposit_balance * 2; assert!(user_account.borrow_balance + amount <= collateral_ratio, E_BORROW_LIMIT_EXCEEDED); pool.total_borrows = pool.total_borrows + amount; user_account.borrow_balance = user_account.borrow_balance + amount; user_account.last_interaction_timestamp = timestamp::now_seconds(); coin::transfer<CoinType>(account, sender, amount); } public fun repay<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserAccount { let sender = signer::address_of(account); assert!(exists<LendingPool<CoinType>>(sender), E_NOT_INITIALIZED); let pool = borrow_global_mut<LendingPool<CoinType>>(sender); let user_account = borrow_global_mut<UserAccount<CoinType>>(sender); assert!(user_account.borrow_balance >= amount, E_INSUFFICIENT_BALANCE); pool.total_borrows = pool.total_borrows - amount; user_account.borrow_balance = user_account.borrow_balance - amount; user_account.last_interaction_timestamp = timestamp::now_seconds(); coin::transfer<CoinType>(account, sender, amount); } public fun withdraw<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserAccount { let sender = signer::address_of(account); assert!(exists<LendingPool<CoinType>>(sender), E_NOT_INITIALIZED); let pool = borrow_global_mut<LendingPool<CoinType>>(sender); let user_account = borrow_global_mut<UserAccount<CoinType>>(sender); assert!(user_account.deposit_balance >= amount, E_INSUFFICIENT_BALANCE); assert!(pool.total_deposits - amount >= pool.total_borrows, E_INSUFFICIENT_BALANCE); pool.total_deposits = pool.total_deposits - amount; user_account.deposit_balance = user_account.deposit_balance - amount; user_account.last_interaction_timestamp = timestamp::now_seconds(); coin::transfer<CoinType>(account, sender, amount); } public fun update_interest_rate<CoinType>(account: &signer, new_rate: u64) acquires LendingPool { let sender = signer::address_of(account); assert!(exists<LendingPool<CoinType>>(sender), E_NOT_INITIALIZED); let pool = borrow_global_mut<LendingPool<CoinType>>(sender); pool.interest_rate = new_rate; pool.last_update_timestamp = timestamp::now_seconds(); } public fun get_user_balances<CoinType>(account: &signer): (u64, u64) acquires UserAccount { let sender = signer::address_of(account); let user_account = borrow_global<UserAccount<CoinType>>(sender); (user_account.deposit_balance, user_account.borrow_balance) } }",
        "vulnerabilities": [
            "Reentrancy vulnerability in deposit and borrow functions",
            "Integer overflow/underflow in arithmetic operations",
            "Lack of access control for update_interest_rate function",
            "Timestamp manipulation vulnerability",
            "Missing event emissions for important state changes",
            "Centralization risk due to single pool design",
            "Static collateralization ratio not accounting for asset price fluctuations",
            "No contract pausability mechanism",
            "Lack of slippage protection for large deposits/withdrawals",
            "Missing interest accrual implementation"
        ]
    },
    {
        "code": "module DecentralizedExchange { use std::signer; use aptos_framework::coin; use aptos_framework::event; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: u64, reserve_y: u64, lp_token_supply: u64, } struct LiquidityToken<phantom X, phantom Y> {} struct AddLiquidityEvent has drop, store { provider: address, amount_x: u64, amount_y: u64, lp_tokens: u64, } struct SwapEvent has drop, store { user: address, amount_in: u64, amount_out: u64, } public fun create_pool<X, Y>(account: &signer) { assert!(!exists<LiquidityPool<X, Y>>(signer::address_of(account)), 1); move_to(account, LiquidityPool<X, Y> { reserve_x: 0, reserve_y: 0, lp_token_supply: 0, }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let lp_tokens = if (pool.lp_token_supply == 0) { sqrt(amount_x * amount_y) } else { min((amount_x * pool.lp_token_supply) / pool.reserve_x, (amount_y * pool.lp_token_supply) / pool.reserve_y) }; pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; pool.lp_token_supply = pool.lp_token_supply + lp_tokens; coin::transfer<X>(account, @pool_address, amount_x); coin::transfer<Y>(account, @pool_address, amount_y); coin::mint<LiquidityToken<X, Y>>(lp_tokens, account); event::emit(AddLiquidityEvent { provider: sender, amount_x, amount_y, lp_tokens }); } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let amount_out = (amount_in * 997 * pool.reserve_y) / (pool.reserve_x * 1000 + amount_in * 997); assert!(amount_out >= min_amount_out, 2); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; coin::transfer<X>(account, @pool_address, amount_in); coin::transfer<Y>(@pool_address, sender, amount_out); event::emit(SwapEvent { user: sender, amount_in, amount_out }); } fun sqrt(y: u64): u64 { if (y < 4) { if (y == 0) { 0 } else { 1 } } else { let z = y; let x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } z } } fun min(a: u64, b: u64): u64 { if (a < b) a else b } }",
        "vulnerabilities": [
            "Lack of access control for creating pools",
            "No slippage protection in add_liquidity function",
            "Potential for precision loss in liquidity calculations"
        ]
    },
    {
        "code": "module SimpleStaking { use std::signer; use aptos_framework::coin; struct StakeInfo has key { amount: u64, start_time: u64 } public fun stake(account: &signer, amount: u64) { let stake_info = StakeInfo { amount, start_time: timestamp::now_seconds() }; move_to(account, stake_info); coin::transfer<AptosCoin>(account, @staking_pool, amount); } public fun unstake(account: &signer) acquires StakeInfo { let StakeInfo { amount, start_time } = move_from<StakeInfo>(signer::address_of(account)); coin::transfer<AptosCoin>(@staking_pool, signer::address_of(account), amount); } }",
        "vulnerabilities": [
            "No minimum staking period",
            "Lack of reward distribution mechanism",
            "Missing access control for unstaking",
            "No slashing mechanism for bad actors",
            "Potential for reentrancy in unstaking",
            "Absence of stake amount validation",
            "No mechanism to update staking parameters",
            "Missing events for stake/unstake actions",
            "Lack of emergency withdrawal function",
            "No cap on total staked amount"
        ]
    },
    {
        "code": "module Crowdfunding { use aptos_framework::coin; struct Campaign has key { target_amount: u64, total_raised: u64, deadline: u64, creator: address, } public fun start_campaign(account: &signer, target_amount: u64, deadline: u64) { let creator = signer::address_of(account); move_to(account, Campaign { target_amount: target_amount, total_raised: 0, deadline: deadline, creator: creator }); } public fun contribute(account: &signer, amount: u64) acquires Campaign { let campaign = borrow_global_mut<Campaign>(@campaign_address); assert!(timestamp() < campaign.deadline, 1); campaign.total_raised = campaign.total_raised + amount; coin::transfer(account, @campaign_address, amount); } public fun claim_funds(account: &signer) acquires Campaign { let campaign = borrow_global_mut<Campaign>(@campaign_address); assert!(campaign.creator == signer::address_of(account), 1); assert!(campaign.total_raised >= campaign.target_amount, 2); coin::transfer(account, campaign.total_raised); move_from<Campaign>(@campaign_address); } }",
        "vulnerabilities": [            "No refund mechanism for contributors",            "Potential for funds to be claimed early"        ]
    },  
    {
        "code": "module TokenFactory { use std::signer; use aptos_framework::coin; struct TokenInfo has key { name: vector<u8>, symbol: vector<u8>, decimals: u8, total_supply: u64, } public fun create_token(account: &signer, name: vector<u8>, symbol: vector<u8>, decimals: u8, initial_supply: u64) { let sender = signer::address_of(account); move_to(account, TokenInfo { name, symbol, decimals, total_supply: initial_supply }); coin::mint_to(account, sender, initial_supply); } }",
        "vulnerabilities": [
            "Potential overflow in total_supply",
            "Lack of access control on create_token function",
            "No validation of token parameters",
            "No event emissions for token creation",
            "Single entity control over token supply",
            "No mechanism for supply adjustments",
            "No burn functionality",
            "No ownership transfer functionality",
            "No mechanism for freezing accounts",
            "No mechanism for pausing contract"
        ]
    },
    {
        "code": "module VotingSystem { use std::signer; struct Proposal has key { description: vector<u8>, yes_votes: u64, no_votes: u64, } public fun create_proposal(account: &signer, description: vector<u8>) { let sender = signer::address_of(account); move_to(account, Proposal { description, yes_votes: 0, no_votes: 0 }); } public fun vote_yes(account: &signer, proposal: &mut Proposal) { proposal.yes_votes = proposal.yes_votes + 1; } public fun vote_no(account: &signer, proposal: &mut Proposal) { proposal.no_votes = proposal.no_votes + 1; } }",
        "vulnerabilities": [
            "Lack of access control on vote functions",
            "Potential for double voting",
            "No mechanism for proposal end time",
            "No mechanism for proposal result finalization",
            "No event emissions for votes",
            "No user authentication",
            "No quorum for proposal acceptance",
            "No mechanism for proposal withdrawal",
            "No validation of proposal description",
            "No prevention of spam proposals"
        ]
    },

    {
        "code": "module SimpleNFT { use std::string; use aptos_framework::account; struct NFT has key { id: u64, name: string::String, owner: address } public fun mint(creator: &signer, name: string::String) { let nft = NFT { id: account::get_sequence_number(signer::address_of(creator)), name, owner: signer::address_of(creator) }; move_to(creator, nft); } public fun transfer(from: &signer, to: address, id: u64) acquires NFT { let nft = move_from<NFT>(signer::address_of(from)); assert!(nft.id == id, 1); nft.owner = to; move_to(account::create_signer_with_capability(&account::create_test_signer_cap(to)), nft); } }",
        "vulnerabilities": [
            "Lack of access control for minting",
            "No check for duplicate NFT IDs",
            "Missing ownership validation in transfer",
            "Absence of royalty mechanism",
            "No burning functionality",
            "Lack of metadata standards",
            "Missing events for minting and transfers",
            "No support for batch operations",
            "Absence of approval mechanism for transfers",
            "Potential for front-running in transfers"
        ]
    },
    {
        "code": "module SimpleDEX { use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: u64, reserve_y: u64 } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex); coin::transfer<X>(account, @dex, amount_x); coin::transfer<Y>(account, @dex, amount_y); pool.reserve_x += amount_x; pool.reserve_y += amount_y; } public fun swap<X, Y>(account: &signer, amount_in: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex); let amount_out = (amount_in * pool.reserve_y) / (pool.reserve_x + amount_in); coin::transfer<X>(account, @dex, amount_in); coin::transfer<Y>(@dex, signer::address_of(account), amount_out); pool.reserve_x += amount_in; pool.reserve_y -= amount_out; } }",
        "vulnerabilities": [
            "Lack of slippage protection",
            "No minimum liquidity requirement",
            "Missing access control for pool creation",
            "Absence of fee mechanism",
            "Potential for sandwich attacks",
            "No support for flash loans",
            "Missing events for liquidity and swap actions",
            "Lack of price oracle integration",
            "No mechanism to pause trades in emergencies",
            "Absence of liquidity provider tokens"
        ]
    },
    {
        "code": "module SimpleDAO { use std::signer; struct Proposal has key { id: u64, description: vector<u8>, votes_for: u64, votes_against: u64, deadline: u64 } public fun create_proposal(creator: &signer, description: vector<u8>, deadline: u64) { let proposal = Proposal { id: 0, description, votes_for: 0, votes_against: 0, deadline }; move_to(creator, proposal); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@dao_address); if (vote) { proposal.votes_for += 1; } else { proposal.votes_against += 1; } } }",
        "vulnerabilities": [
            "Lack of token-based voting power",
            "No quorum requirement for proposals",
            "Missing access control for proposal creation",
            "Absence of execution mechanism for passed proposals",
            "No support for delegate voting",
            "Lack of time-lock for proposal execution",
            "Missing events for proposal and voting actions",
            "No mechanism to cancel or update proposals",
            "Absence of vote weight calculation",
            "Potential for double voting"
        ]
    },
    {
        "code": "module SimpleLending { use aptos_framework::coin; struct Loan<phantom CoinType> has key { borrower: address, amount: u64, interest_rate: u64, due_date: u64 } public fun borrow<CoinType>(borrower: &signer, amount: u64, interest_rate: u64, duration: u64) { let loan = Loan<CoinType> { borrower: signer::address_of(borrower), amount, interest_rate, due_date: timestamp::now_seconds() + duration }; move_to(borrower, loan); coin::transfer<CoinType>(@lending_pool, signer::address_of(borrower), amount); } public fun repay<CoinType>(borrower: &signer) acquires Loan { let loan = move_from<Loan<CoinType>>(signer::address_of(borrower)); let repay_amount = loan.amount + (loan.amount * loan.interest_rate / 100); coin::transfer<CoinType>(borrower, @lending_pool, repay_amount); } }",
        "vulnerabilities": [
            "No collateral requirement",
            "Lack of partial repayment functionality",
            "Missing checks for borrowing limits",
            "Absence of liquidation mechanism",
            "No support for variable interest rates",
            "Lack of grace period for repayments",
            "Missing events for borrow and repay actions",
            "No mechanism to extend loan duration",
            "Absence of loan-to-value ratio checks",
            "Potential for interest rate manipulation"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::coin; struct Auction has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64 } public fun create_auction(seller: &signer, end_time: u64) { let auction = Auction { seller: signer::address_of(seller), highest_bidder: @0x0, highest_bid: 0, end_time }; move_to(seller, auction); } public fun place_bid(bidder: &signer, bid_amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@auction_address); assert!(timestamp::now_seconds() < auction.end_time, 1); assert!(bid_amount > auction.highest_bid, 2); coin::transfer<AptosCoin>(bidder, @escrow, bid_amount); if (auction.highest_bidder != @0x0) { coin::transfer<AptosCoin>(@escrow, auction.highest_bidder, auction.highest_bid); } auction.highest_bidder = signer::address_of(bidder); auction.highest_bid = bid_amount; } }",
        "vulnerabilities": [
            "Lack of minimum bid increment",
            "No mechanism to extend auction time",
            "Missing access control for auction creation",
            "Absence of auction cancellation functionality",
            "No support for reserve price",
            "Lack of events for bid placement",
            "Missing checks for sufficient balance before bidding",
            "No mechanism to handle tied bids",
            "Absence of withdrawal functionality for seller",
            "Potential for front-running in bid placement"
        ]
    },
    {
        "code": "module SimpleMultisig { use std::vector; struct MultiSigWallet has key { owners: vector<address>, required_confirmations: u64 } struct Transaction has key { to: address, value: u64, data: vector<u8>, confirmations: vector<address>, executed: bool } public fun create_wallet(creator: &signer, owners: vector<address>, required_confirmations: u64) { let wallet = MultiSigWallet { owners, required_confirmations }; move_to(creator, wallet); } public fun submit_transaction(submitter: &signer, to: address, value: u64, data: vector<u8>) acquires MultiSigWallet { let wallet = borrow_global<MultiSigWallet>(@multisig_address); assert!(vector::contains(&wallet.owners, &signer::address_of(submitter)), 1); let transaction = Transaction { to, value, data, confirmations: vector::empty(), executed: false }; move_to(submitter, transaction); } }",
        "vulnerabilities": [
            "Lack of owner removal functionality",
            "No mechanism to change required confirmations",
            "Missing events for wallet creation and transaction submission",
            "Absence of transaction execution logic",
            "No support for cancelling transactions",
            "Lack of checks for duplicate owners",
            "Missing functionality to replace owners",
            "No mechanism to handle failed transactions",
            "Absence of daily transaction limit",
            "Potential for centralization if required confirmations is too low"
        ]
    },
    {
        "code": "module SimpleTokenVesting { use std::signer; use aptos_framework::coin; struct VestingSchedule has key { beneficiary: address, total_amount: u64, released_amount: u64, start_time: u64, duration: u64 } public fun create_vesting(creator: &signer, beneficiary: address, total_amount: u64, start_time: u64, duration: u64) { let schedule = VestingSchedule { beneficiary, total_amount, released_amount: 0, start_time, duration }; move_to(creator, schedule); coin::transfer<AptosCoin>(creator, @vesting_contract, total_amount); } public fun release(beneficiary: &signer) acquires VestingSchedule { let schedule = borrow_global_mut<VestingSchedule>(@vesting_contract); let vested_amount = (schedule.total_amount * (timestamp::now_seconds() - schedule.start_time) / schedule.duration); let to_release = vested_amount - schedule.released_amount; coin::transfer<AptosCoin>(@vesting_contract, signer::address_of(beneficiary), to_release); schedule.released_amount += to_release; } }",
        "vulnerabilities": [
            "Lack of cliff period",
            "No support for multiple token types",
            "Missing access control for vesting creation",
            "Absence of revocation mechanism",
            "No handling of remaining tokens after vesting period",
            "Lack of events for vesting creation and releases",
            "Missing checks for vesting parameters validity",
            "No support for vesting acceleration",
            "Absence of partial release functionality",
            "Potential for front-running in release function"
        ]
    },
    {
        "code": "module SimplePredictionMarket { use std::signer; use aptos_framework::coin; struct Market has key { question: vector<u8>, resolution_time: u64, total_yes_stake: u64, total_no_stake: u64, outcome: bool, resolved: bool } public fun create_market(creator: &signer, question: vector<u8>, resolution_time: u64) { let market = Market { question, resolution_time, total_yes_stake: 0, total_no_stake: 0, outcome: false, resolved: false }; move_to(creator, market); } public fun place_bet(better: &signer, prediction: bool, amount: u64) acquires Market { let market = borrow_global_mut<Market>(@market_address); assert!(!market.resolved, 1); coin::transfer<AptosCoin>(better, @market_address, amount); if (prediction) { market.total_yes_stake += amount; } else { market.total_no_stake += amount; } } }",
        "vulnerabilities": [
            "Lack of oracle for result verification",
            "No mechanism to cancel markets",
            "Missing access control for market creation",
            "Absence of fee mechanism",
            "No support for multiple outcomes",
            "Lack of events for market creation and bets",
            "Missing checks for valid resolution time",
            "No mechanism to handle market ties",
            "Absence of partial withdrawal functionality",
            "Potential for manipulation of market outcome"
        ]
    },

    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::event; use aptos_framework::timestamp; struct Listing has key { creator: address, price: u64, expiration: u64, } struct ListingCreatedEvent has drop, store { creator: address, token_id: u64, price: u64, expiration: u64, } struct SaleEvent has drop, store { seller: address, buyer: address, token_id: u64, price: u64, } public fun create_listing<NFTType>(creator: &signer, token_id: u64, price: u64, duration: u64) { let sender = signer::address_of(creator); assert!(!exists<Listing>(sender), 1); let expiration = timestamp::now_seconds() + duration; move_to(creator, Listing { creator: sender, price, expiration }); event::emit(ListingCreatedEvent { creator: sender, token_id, price, expiration }); } public fun buy_nft<NFTType, CoinType>(buyer: &signer, seller: address, token_id: u64) acquires Listing { let listing = move_from<Listing>(seller); assert!(timestamp::now_seconds() < listing.expiration, 2); let price = listing.price; coin::transfer<CoinType>(buyer, seller, price); // Transfer NFT from seller to buyer (implementation depends on NFT standard) event::emit(SaleEvent { seller, buyer: signer::address_of(buyer), token_id, price }); } public fun cancel_listing(seller: &signer) acquires Listing { let sender = signer::address_of(seller); assert!(exists<Listing>(sender), 3); let Listing { creator: _, price: _, expiration: _ } = move_from<Listing>(sender); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Centralized storage of listings"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Listing has key { creator: address, price: u64, is_active: bool, } struct MarketplaceData has key { fee_percentage: u64, total_sales: u64, } const E_NOT_AUTHORIZED: u64 = 1; const E_LISTING_NOT_ACTIVE: u64 = 2; const E_INSUFFICIENT_FUNDS: u64 = 3; public fun initialize(account: &signer, fee_percentage: u64) { let sender = signer::address_of(account); assert!(!exists<MarketplaceData>(sender), E_NOT_AUTHORIZED); move_to(account, MarketplaceData { fee_percentage, total_sales: 0, }); } public fun create_listing<CoinType>(account: &signer, token_id: u64, price: u64) { let sender = signer::address_of(account); move_to(account, Listing { creator: sender, price, is_active: true, }); } public fun buy_nft<CoinType>(buyer: &signer, seller: address, token_id: u64) acquires Listing, MarketplaceData { let listing = borrow_global_mut<Listing>(seller); assert!(listing.is_active, E_LISTING_NOT_ACTIVE); let marketplace_data = borrow_global_mut<MarketplaceData>(@marketplace); let fee = (listing.price * marketplace_data.fee_percentage) / 100; let seller_amount = listing.price - fee; coin::transfer<CoinType>(buyer, seller, seller_amount); coin::transfer<CoinType>(buyer, @marketplace, fee); marketplace_data.total_sales = marketplace_data.total_sales + 1; listing.is_active = false; } public fun cancel_listing(account: &signer, token_id: u64) acquires Listing { let sender = signer::address_of(account); let listing = borrow_global_mut<Listing>(sender); assert!(listing.creator == sender, E_NOT_AUTHORIZED); listing.is_active = false; } public fun update_fee_percentage(account: &signer, new_fee_percentage: u64) acquires MarketplaceData { let sender = signer::address_of(account); assert!(sender == @marketplace, E_NOT_AUTHORIZED); let marketplace_data = borrow_global_mut<MarketplaceData>(@marketplace); marketplace_data.fee_percentage = new_fee_percentage; } }",
        "vulnerabilities": [
            "Lack of access control for create_listing function",
            "No check for duplicate listings",
            "Missing event emissions for important state changes",
            "No verification of NFT ownership before listing",
            "Centralized control of marketplace fees",
            "No mechanism to withdraw accumulated fees",
            "Lack of price validation in create_listing",
            "No slippage protection for buyers",
            "Missing checks for zero address in transfers",
            "Potential integer overflow in total_sales counter"
        ]
    },
    {
        "code": "module DecentralizedIdentity { use std::signer; use std::vector; use aptos_framework::event; struct Identity has key { controller: address, public_key: vector<u8>, attributes: vector<Attribute>, } struct Attribute has store, drop { name: vector<u8>, value: vector<u8>, } struct IdentityCreatedEvent has drop, store { did: address, controller: address, } struct AttributeAddedEvent has drop, store { did: address, name: vector<u8>, value: vector<u8>, } public fun create_identity(account: &signer, public_key: vector<u8>) { let sender = signer::address_of(account); assert!(!exists<Identity>(sender), 1); move_to(account, Identity { controller: sender, public_key, attributes: vector::empty(), }); event::emit(IdentityCreatedEvent { did: sender, controller: sender }); } public fun add_attribute(controller: &signer, did: address, name: vector<u8>, value: vector<u8>) acquires Identity { let identity = borrow_global_mut<Identity>(did); assert!(signer::address_of(controller) == identity.controller, 2); vector::push_back(&mut identity.attributes, Attribute { name, value }); event::emit(AttributeAddedEvent { did, name, value }); } public fun get_public_key(did: address): vector<u8> acquires Identity { borrow_global<Identity>(did).public_key } public fun get_attribute(did: address, name: vector<u8>): vector<u8> acquires Identity { let identity = borrow_global<Identity>(did); let i = 0; let len = vector::length(&identity.attributes); while (i < len) { let attr = vector::borrow(&identity.attributes, i); if (attr.name == name) { return attr.value } ; i = i + 1; }; vector::empty() } }",
        "vulnerabilities": [
            "No mechanism to update the controller address",
            "Lack of attribute revocation functionality"
        ]
    },
    {
        "code": "module TimelockWallet { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct TimeLock<phantom CoinType> has key { beneficiary: address, release_time: u64, amount: u64, } public fun create_timelock<CoinType>(creator: &signer, beneficiary: address, release_time: u64, amount: u64) { let sender = signer::address_of(creator); assert!(!exists<TimeLock<CoinType>>(sender), 1); move_to(creator, TimeLock<CoinType> { beneficiary, release_time, amount }); coin::transfer<CoinType>(creator, @timelock_address, amount); } public fun release<CoinType>(account: &signer) acquires TimeLock<CoinType> { let sender = signer::address_of(account); let timelock = move_from<TimeLock<CoinType>>(sender); assert!(timestamp::now_seconds() >= timelock.release_time, 2); assert!(sender == timelock.beneficiary, 3); coin::transfer<CoinType>(@timelock_address, timelock.beneficiary, timelock.amount); } public fun get_timelock_info<CoinType>(addr: address): (address, u64, u64) acquires TimeLock<CoinType> { let timelock = borrow_global<TimeLock<CoinType>>(addr); (timelock.beneficiary, timelock.release_time, timelock.amount) } }",
        "vulnerabilities": [
            "No mechanism to cancel or update the timelock"
        ]
    },
    {
        "code": "module VotingSystem { use std::signer; use std::vector; use aptos_framework::timestamp; struct Proposal has key { creator: address, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64, } struct VoteRecord has key { proposals: vector<address>, } const E_NOT_AUTHORIZED: u64 = 1; const E_VOTING_ENDED: u64 = 2; const E_ALREADY_VOTED: u64 = 3; public fun create_proposal(account: &signer, description: vector<u8>, duration: u64) { let sender = signer::address_of(account); move_to(account, Proposal { creator: sender, description, yes_votes: 0, no_votes: 0, end_time: timestamp::now_seconds() + duration, }); } public fun vote(account: &signer, proposal_address: address, vote: bool) acquires Proposal, VoteRecord { let sender = signer::address_of(account); let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(timestamp::now_seconds() < proposal.end_time, E_VOTING_ENDED); if (!exists<VoteRecord>(sender)) { move_to(account, VoteRecord { proposals: vector::empty(), }); } let vote_record = borrow_global_mut<VoteRecord>(sender); assert!(!vector::contains(&vote_record.proposals, &proposal_address), E_ALREADY_VOTED); vector::push_back(&mut vote_record.proposals, proposal_address); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } } public fun get_results(proposal_address: address): (u64, u64) acquires Proposal { let proposal = borrow_global<Proposal>(proposal_address); (proposal.yes_votes, proposal.no_votes) } public fun is_active(proposal_address: address): bool acquires Proposal { let proposal = borrow_global<Proposal>(proposal_address); timestamp::now_seconds() < proposal.end_time } }",
        "vulnerabilities": [
            "Lack of access control for create_proposal function",
            "No limit on proposal duration",
            "Missing event emissions for votes and proposal creation",
            "No mechanism to update or cancel proposals",
            "Potential for multiple proposals at the same address",
            "No minimum voting period",
            "Lack of quorum or minimum participation requirements",
            "No weighted voting system",
            "Centralized vote counting without verification",
            "Potential integer overflow in vote counters"
        ]
    },
    {
        "code": "module DAOGovernance { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Proposal has key { id: u64, creator: address, description: vector<u8>, votes_for: u64, votes_against: u64, end_time: u64, executed: bool, } struct VotingPower<phantom CoinType> has key { power: u64, } struct GovernanceConfig has key { proposal_threshold: u64, voting_period: u64, execution_delay: u64, } public fun create_proposal(creator: &signer, description: vector<u8>) acquires GovernanceConfig, VotingPower<CoinType> { let sender = signer::address_of(creator); let config = borrow_global<GovernanceConfig>(@dao_address); let voting_power = borrow_global<VotingPower<CoinType>>(sender); assert!(voting_power.power >= config.proposal_threshold, 1); let proposal_id = get_next_proposal_id(); move_to(creator, Proposal { id: proposal_id, creator: sender, description, votes_for: 0, votes_against: 0, end_time: timestamp::now_seconds() + config.voting_period, executed: false }); } public fun vote<CoinType>(voter: &signer, proposal_id: u64, support: bool) acquires Proposal, VotingPower<CoinType> { let sender = signer::address_of(voter); let proposal = borrow_global_mut<Proposal>(@dao_address); assert!(timestamp::now_seconds() <= proposal.end_time, 2); let voting_power = borrow_global<VotingPower<CoinType>>(sender); let vote_weight = voting_power.power; if (support) { proposal.votes_for = proposal.votes_for + vote_weight; } else { proposal.votes_against = proposal.votes_against + vote_weight; } } public fun execute_proposal(executor: &signer, proposal_id: u64) acquires Proposal, GovernanceConfig { let proposal = borrow_global_mut<Proposal>(@dao_address); let config = borrow_global<GovernanceConfig>(@dao_address); assert!(!proposal.executed, 3); assert!(timestamp::now_seconds() > proposal.end_time + config.execution_delay, 4); assert!(proposal.votes_for > proposal.votes_against, 5); // Execute proposal actions here proposal.executed = true; } public fun initialize_governance<CoinType>(admin: &signer, proposal_threshold: u64, voting_period: u64, execution_delay: u64) { let sender = signer::address_of(admin); assert!(sender == @dao_address, 6); move_to(admin, GovernanceConfig { proposal_threshold, voting_period, execution_delay }); } public(script) fun get_next_proposal_id(): u64 { // Implementation omitted for brevity 0 } }",
        "vulnerabilities": [
            "No quorum requirement for proposal execution",
            "Lack of vote delegation mechanism",
            "Potential for governance attacks with large token acquisitions"
        ]
    },
    {
        "code": "module StablecoinAMM { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: u64, reserve_y: u64, total_shares: u64, } struct LPToken<phantom X, phantom Y> has key { balance: u64, } public fun create_pool<X, Y>(creator: &signer) { let sender = signer::address_of(creator); assert!(!exists<LiquidityPool<X, Y>>(sender), 1); move_to(creator, LiquidityPool<X, Y> { reserve_x: 0, reserve_y: 0, total_shares: 0 }); } public fun add_liquidity<X, Y>(provider: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let sender = signer::address_of(provider); let pool = borrow_global_mut<LiquidityPool<X, Y>>(@amm_address); let shares = if (pool.total_shares == 0) { sqrt(amount_x * amount_y) } else { min((amount_x * pool.total_shares) / pool.reserve_x, (amount_y * pool.total_shares) / pool.reserve_y) }; pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; pool.total_shares = pool.total_shares + shares; if (!exists<LPToken<X, Y>>(sender)) { move_to(provider, LPToken<X, Y> { balance: shares }); } else { let user_tokens = borrow_global_mut<LPToken<X, Y>>(sender); user_tokens.balance = user_tokens.balance + shares; } coin::transfer<X>(provider, @amm_address, amount_x); coin::transfer<Y>(provider, @amm_address, amount_y); } public fun swap<X, Y>(user: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@amm_address); let amount_out = (amount_in * pool.reserve_y) / (pool.reserve_x + amount_in); assert!(amount_out >= min_amount_out, 2); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; coin::transfer<X>(user, @amm_address, amount_in); coin::transfer<Y>(@amm_address, signer::address_of(user), amount_out); } public(script) fun sqrt(y: u64): u64 { if (y < 4) { if (y == 0) { 0 } else { 1 } } else { let z = y; let x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; }; z } } public(script) fun min(a: u64, b: u64): u64 { if (a < b) { a } else { b } } }",
        "vulnerabilities": [
            "No slippage protection in add_liquidity function",
            "Potential for sandwich attacks in swap function",
            "Lack of access control for create_pool function"
        ]
    },
    {
        "code": "module TokenSwap { use std::signer; use aptos_framework::coin; struct LiquidityPool<X, Y> has key { reserve_x: coin::Coin<X>, reserve_y: coin::Coin<Y>, } public fun create_pool<X, Y>(creator: &signer, initial_x: coin::Coin<X>, initial_y: coin::Coin<Y>) { move_to(creator, LiquidityPool { reserve_x: initial_x, reserve_y: initial_y }); } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let coin_in = coin::withdraw<X>(account, amount_in); let reserve_in = coin::value(&pool.reserve_x); let reserve_out = coin::value(&pool.reserve_y); let amount_out = (amount_in * reserve_out) / (reserve_in + amount_in); assert!(amount_out >= min_amount_out, 1); coin::deposit(sender, coin::extract(&mut pool.reserve_y, amount_out)); coin::merge(&mut pool.reserve_x, coin_in); } }",
        "vulnerabilities": [
            "No slippage protection",
            "Vulnerable to flash loan attacks"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::table; struct NFT has key { owner: address, price: u64 } struct Marketplace has key { listings: table::Table<u64, NFT> } public fun list_nft(seller: &signer, id: u64, price: u64) { let nft = NFT { owner: signer::address_of(seller), price: price }; let marketplace = borrow_global_mut<Marketplace>(@0x1); table::add(&mut marketplace.listings, id, nft); } public fun buy_nft(buyer: &signer, id: u64) acquires Marketplace { let marketplace = borrow_global_mut<Marketplace>(@0x1); let nft = table::remove(&mut marketplace.listings, id); assert!(nft.price <= signer::balance(buyer), 101); } }",
        "vulnerabilities": [        
            "No event emissions for listing and buying",        
            "No checks for NFT ownership before listing",        
            "No access control for buy function",        
            "Potential for price manipulation",        
            "No mechanism for updating or removing listings"   
        ]
    },
    {
        "code": "module Subscription { use std::signer; use aptos_framework::timestamp; struct Subscription has key { subscriber: address, end_time: u64 } public fun subscribe(subscriber: &signer, duration: u64) { let subscription = Subscription { subscriber: signer::address_of(subscriber), end_time: timestamp::now_seconds() + duration }; move_to(subscriber, subscription); } public fun check_subscription(subscriber: &signer) acquires Subscription { let subscription = borrow_global<Subscription>(signer::address_of(subscriber)); assert!(timestamp::now_seconds() < subscription.end_time, 101); } }",
        "vulnerabilities": [        
            "No event emissions for subscription and checks",        
            "No checks for existing subscriptions",        
            "No mechanism to extend subscription duration",        
            "Potential for gas limit issues with large number of subscribers",        
            "No access control for check function"    
        ]
    },
    {
        "code": "module Escrow { use std::signer; use aptos_framework::timestamp; struct Escrow has key { buyer: address, seller: address, amount: u64, end_time: u64 } public fun create_escrow(buyer: &signer, seller: address, amount: u64, duration: u64) { let escrow = Escrow { buyer: signer::address_of(buyer), seller: seller, amount: amount, end_time: timestamp::now_seconds() + duration }; move_to(buyer, escrow); } public fun release_funds(buyer: &signer, escrow_address: address) acquires Escrow { let escrow = borrow_global_mut<Escrow>(escrow_address); assert!(timestamp::now_seconds() >= escrow.end_time, 101); assert!(escrow.buyer == signer::address_of(buyer), 102); let amount = escrow.amount; destroy(escrow); } }",
        "vulnerabilities": [        
            "No event emissions for escrow creation and release",        
            "No checks for escrow existence before release",        
            "Potential for early release of funds",        
            "No mechanism for dispute resolution",        
            "No access control for release function"    
        ]
    },
    {
        "code": "module LoyaltyProgram { use std::signer; use aptos_framework::table; struct LoyaltyPoints has key { points: table::Table<address, u64> } public fun initialize(signer: &signer) { let points = LoyaltyPoints { points: table::new() }; move_to(signer, points); } public fun award_points(admin: &signer, customer: address, amount: u64) acquires LoyaltyPoints { let points = borrow_global_mut<LoyaltyPoints>(signer::address_of(admin)); let current_points = if (table::contains(&points.points, customer)) { table::remove(&mut points.points, customer) } else { 0 }; table::add(&mut points.points, customer, current_points + amount); } }",
        "vulnerabilities": [        
            "No event emissions for points awarding",        
            "No access control for initialize and award_points functions",        
            "No checks for integer overflow",        
            "Potential for gas limit issues with large number of customers",        
            "No mechanism to redeem points"    
        ]
    },
    {
        "code": "module Voting { use std::signer; use aptos_framework::event; struct Proposal has key { description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64, } struct VoteEvent has drop, store { voter: address, proposal_id: u64, vote: bool, } public fun create_proposal(creator: &signer, description: vector<u8>, duration: u64) { let proposal_id = get_next_proposal_id(); move_to(creator, Proposal { description, yes_votes: 0, no_votes: 0, end_time: timestamp::now_seconds() + duration }); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address(proposal_id)); assert!(timestamp::now_seconds() < proposal.end_time, 1); if (vote) { proposal.yes_votes += 1; } else { proposal.no_votes += 1; } event::emit(VoteEvent { voter: signer::address_of(voter), proposal_id, vote }); } }",
        "vulnerabilities": [
            "No protection against double voting",
            "Centralized proposal creation"
        ]
    },
    {
        "code": "module StakingRewards { use std::signer; use aptos_framework::coin; struct StakeInfo has key { amount: u64, last_claim_time: u64, } public fun stake<CoinType>(account: &signer, amount: u64) acquires StakeInfo { let sender = signer::address_of(account); if (!exists<StakeInfo>(sender)) { move_to(account, StakeInfo { amount: 0, last_claim_time: timestamp::now_seconds() }); } let stake_info = borrow_global_mut<StakeInfo>(sender); coin::transfer<CoinType>(account, @staking_pool, amount); stake_info.amount += amount; } public fun claim_rewards<CoinType>(account: &signer) acquires StakeInfo { let sender = signer::address_of(account); let stake_info = borrow_global_mut<StakeInfo>(sender); let current_time = timestamp::now_seconds(); let reward = calculate_reward(stake_info.amount, stake_info.last_claim_time, current_time); coin::transfer<CoinType>(@staking_pool, sender, reward); stake_info.last_claim_time = current_time; } }",
        "vulnerabilities": [
            "Potential for reward calculation errors",
            "No mechanism to handle slashing"
        ]
    },
    {
        "code": "module Lottery { use std::signer; use aptos_framework::coin; use aptos_framework::random; struct LotteryInfo has key { participants: vector<address>, ticket_price: u64, prize_pool: coin::Coin<AptosCoin>, end_time: u64, } public fun create_lottery(creator: &signer, ticket_price: u64, duration: u64) { move_to(creator, LotteryInfo { participants: vector::empty(), ticket_price, prize_pool: coin::zero(), end_time: timestamp::now_seconds() + duration }); } public fun buy_ticket(buyer: &signer) acquires LotteryInfo { let sender = signer::address_of(buyer); let lottery_info = borrow_global_mut<LotteryInfo>(@lottery); assert!(timestamp::now_seconds() < lottery_info.end_time, 1); coin::transfer<AptosCoin>(buyer, @lottery, lottery_info.ticket_price); vector::push_back(&mut lottery_info.participants, sender); coin::merge(&mut lottery_info.prize_pool, coin::withdraw<AptosCoin>(buyer, lottery_info.ticket_price)); } public fun draw_winner() acquires LotteryInfo { let lottery_info = borrow_global_mut<LotteryInfo>(@lottery); assert!(timestamp::now_seconds() >= lottery_info.end_time, 2); let winner_index = random::rand_u64() % vector::length(&lottery_info.participants); let winner = *vector::borrow(&lottery_info.participants, winner_index); coin::deposit(winner, coin::extract_all(&mut lottery_info.prize_pool)); } }",
        "vulnerabilities": [
            "Randomness can be manipulated by validators",
            "No mechanism to handle if no tickets are sold"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use aptos_framework::coin; struct MultiSig has key { owners: vector<address>, required_signatures: u64, } struct Transaction has store { to: address, amount: u64, signatures: vector<address>, } public fun create_wallet(creator: &signer, owners: vector<address>, required_signatures: u64) { assert!(vector::length(&owners) >= required_signatures, 1); move_to(creator, MultiSig { owners, required_signatures }); } public fun propose_transaction<CoinType>(proposer: &signer, to: address, amount: u64) acquires MultiSig { let multi_sig = borrow_global_mut<MultiSig>(@wallet); assert!(vector::contains(&multi_sig.owners, &signer::address_of(proposer)), 2); let transaction = Transaction { to, amount, signatures: vector::empty() }; vector::push_back(&mut multi_sig.transactions, transaction); } public fun sign_transaction<CoinType>(signer: &signer, transaction_id: u64) acquires MultiSig { let multi_sig = borrow_global_mut<MultiSig>(@wallet); let transaction = vector::borrow_mut(&mut multi_sig.transactions, transaction_id); assert!(vector::contains(&multi_sig.owners, &signer::address_of(signer)), 3); vector::push_back(&mut transaction.signatures, signer::address_of(signer)); if (vector::length(&transaction.signatures) >= multi_sig.required_signatures) { let Transaction { to, amount, signatures: _ } = vector::remove(&mut multi_sig.transactions, transaction_id); coin::transfer<CoinType>(@wallet, to, amount); } } }",
        "vulnerabilities": [
            "No mechanism to remove or change owners",
            "Potential for transaction ordering issues"
        ]
    },
    {
        "code": "module TimeLock { use std::signer; use aptos_framework::coin; struct LockedFunds<CoinType> has key { amount: u64, unlock_time: u64, } public fun lock_funds<CoinType>(account: &signer, amount: u64, lock_duration: u64) { let sender = signer::address_of(account); assert!(!exists<LockedFunds<CoinType>>(sender), 1); let unlock_time = timestamp::now_seconds() + lock_duration; coin::transfer<CoinType>(account, @time_lock, amount); move_to(account, LockedFunds<CoinType> { amount, unlock_time }); } public fun unlock_funds<CoinType>(account: &signer) acquires LockedFunds { let sender = signer::address_of(account); let LockedFunds { amount, unlock_time } = move_from<LockedFunds<CoinType>>(sender); assert!(timestamp::now_seconds() >= unlock_time, 2); coin::transfer<CoinType>(@time_lock, sender, amount); } }",
        "vulnerabilities": [
            "No partial withdrawal mechanism",
            "Funds could be permanently locked if contract is not properly maintained"
        ]
    },
    {
        "code": "module Escrow { use std::signer; use aptos_framework::coin; struct EscrowAccount has key { buyer: address, seller: address, amount: u64, released: bool, } public fun create_escrow(account: &signer, seller: address, amount: u64) { let buyer = signer::address_of(account); move_to(account, EscrowAccount { buyer, seller, amount, released: false }); coin::transfer(account, buyer, amount); } public fun release_funds(account: &signer) acquires EscrowAccount { let sender = signer::address_of(account); let escrow = borrow_global_mut<EscrowAccount>(sender); assert!(!escrow.released, 1); escrow.released = true; coin::transfer(account, escrow.seller, escrow.amount); } }",
        "vulnerabilities": [
            "No mechanism for dispute resolution",
            "Centralization of escrow release",
            "No event emissions for escrow creation and release",
            "No mechanism for partial releases",
            "No mechanism for escrow cancellation",
            "No deadline for fund release",
            "No prevention of reentrancy attacks",
            "No validation of escrow amount",
            "No mechanism for multiple escrow instances per user",
            "No fee mechanism for escrow service"
        ]
    },
    {
        "code": "module NFTFractionalOwnership { use std::signer; use aptos_framework::coin; struct FractionalNFT has key { total_shares: u64, available_shares: u64, price_per_share: u64, } public fun fractionalize_nft(creator: &signer, total_shares: u64, price_per_share: u64) { move_to(creator, FractionalNFT { total_shares, available_shares: total_shares, price_per_share }); } public fun buy_shares(buyer: &signer, num_shares: u64) acquires FractionalNFT { let nft = borrow_global_mut<FractionalNFT>(@nft_address); assert!(num_shares <= nft.available_shares, 1); let total_cost = num_shares * nft.price_per_share; coin::transfer<AptosCoin>(buyer, @nft_address, total_cost); nft.available_shares -= num_shares; } public fun claim_profits(shareholder: &signer) acquires FractionalNFT { let nft = borrow_global<FractionalNFT>(@nft_address); let shares_owned = get_shares_owned(signer::address_of(shareholder)); let total_profits = coin::balance<AptosCoin>(@nft_address); let profit_share = (total_profits * shares_owned) / nft.total_shares; coin::transfer<AptosCoin>(@nft_address, signer::address_of(shareholder), profit_share); } }",
        "vulnerabilities": [
            "No mechanism to update share price",
            "Potential for rounding errors in profit distribution"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; use aptos_framework::coin; use aptos_framework::event; struct BridgeRequest has key { amount: u64, target_chain: vector<u8>, target_address: vector<u8>, status: u8, } struct BridgeEvent has drop, store { requester: address, amount: u64, target_chain: vector<u8>, target_address: vector<u8>, } public fun initiate_bridge<CoinType>(requester: &signer, amount: u64, target_chain: vector<u8>, target_address: vector<u8>) { let sender = signer::address_of(requester); coin::transfer<CoinType>(requester, @bridge_reserve, amount); move_to(requester, BridgeRequest { amount, target_chain, target_address, status: 0 }); event::emit(BridgeEvent { requester: sender, amount, target_chain, target_address }); } public fun complete_bridge(operator: &signer, requester: address) acquires BridgeRequest { assert!(signer::address_of(operator) == @bridge_operator, 1); let bridge_request = borrow_global_mut<BridgeRequest>(requester); bridge_request.status = 1; } }",
        "vulnerabilities": [
            "Centralized bridge operator",
            "No mechanism to handle failed bridge attempts"
        ]
    },
    {
        "code": "module Auction { use std::signer; use aptos_framework::coin; struct AuctionItem has key { highest_bid: u64, highest_bidder: address, end_time: u64, seller: address, } public fun create_auction(account: &signer, starting_bid: u64, duration: u64) { let seller = signer::address_of(account); let end_time = aptos_framework::timestamp::now_seconds() + duration; move_to(account, AuctionItem { highest_bid: starting_bid, highest_bidder: seller, end_time, seller }); } public fun place_bid(account: &signer, bid: u64) acquires AuctionItem { let sender = signer::address_of(account); let auction = borrow_global_mut<AuctionItem>(sender); assert!(aptos_framework::timestamp::now_seconds() < auction.end_time, 1); assert!(bid > auction.highest_bid, 2); auction.highest_bid = bid; auction.highest_bidder = sender; coin::transfer(account, sender, bid); } public fun finalize_auction(account: &signer) acquires AuctionItem { let sender = signer::address_of(account); let auction = borrow_global_mut<AuctionItem>(sender); assert!(aptos_framework::timestamp::now_seconds() >= auction.end_time, 3); coin::transfer(account, auction.seller, auction.highest_bid); } }",
        "vulnerabilities": [
            "No event emissions for bids and finalization",
            "No mechanism for bid refunding",
            "Potential for bid front-running",
            "No validation of auction duration",
            "No minimum bid increment",
            "No mechanism for auction cancellation",
            "No mechanism for withdrawing non-winning bids",
            "Centralization of auction finalization",
            "No mechanism for auction extensions",
            "No prevention of reentrancy attacks"
        ]
    },
    {
        "code": "module DynamicNFT { use std::signer; use aptos_framework::timestamp; struct NFT has key { dna: vector<u8>, last_evolution: u64, } public fun mint_nft(creator: &signer) { let dna = generate_random_dna(); move_to(creator, NFT { dna, last_evolution: timestamp::now_seconds() }); } public fun evolve_nft(owner: &signer) acquires NFT { let nft = borrow_global_mut<NFT>(signer::address_of(owner)); let current_time = timestamp::now_seconds(); if (current_time - nft.last_evolution > 86400) { nft.dna = mutate_dna(nft.dna); nft.last_evolution = current_time; } } public fun get_nft_image(nft_owner: address): vector<u8> acquires NFT { let nft = borrow_global<NFT>(nft_owner); generate_image_from_dna(nft.dna) } }",
        "vulnerabilities": [
            "Potential for predictable DNA generation",
            "No mechanism to prevent rapid evolution attempts"
        ]
    },
    {
        "code": "module DecentralizedExchange { use std::signer; use aptos_framework::coin; struct LiquidityPool<X, Y> has key { reserve_x: coin::Coin<X>, reserve_y: coin::Coin<Y>, lp_tokens: coin::Coin<LPToken>, } struct LPToken {} public fun create_pool<X, Y>(creator: &signer, amount_x: u64, amount_y: u64) { let coin_x = coin::withdraw<X>(creator, amount_x); let coin_y = coin::withdraw<Y>(creator, amount_y); let lp_tokens = coin::mint<LPToken>(sqrt(amount_x * amount_y)); move_to(creator, LiquidityPool { reserve_x: coin_x, reserve_y: coin_y, lp_tokens }); } public fun add_liquidity<X, Y>(provider: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let coin_x = coin::withdraw<X>(provider, amount_x); let coin_y = coin::withdraw<Y>(provider, amount_y); let lp_amount = min((amount_x * coin::value(&pool.lp_tokens)) / coin::value(&pool.reserve_x), (amount_y * coin::value(&pool.lp_tokens)) / coin::value(&pool.reserve_y)); coin::merge(&mut pool.reserve_x, coin_x); coin::merge(&mut pool.reserve_y, coin_y); let lp_tokens = coin::extract(&mut pool.lp_tokens, lp_amount); coin::deposit(signer::address_of(provider), lp_tokens); } public fun swap<X, Y>(trader: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let coin_in = coin::withdraw<X>(trader, amount_in); let reserve_in = coin::value(&pool.reserve_x); let reserve_out = coin::value(&pool.reserve_y); let amount_out = (amount_in * reserve_out) / (reserve_in + amount_in); assert!(amount_out >= min_amount_out, 1); coin::merge(&mut pool.reserve_x, coin_in); let coin_out = coin::extract(&mut pool.reserve_y, amount_out); coin::deposit(signer::address_of(trader), coin_out); } }",
        "vulnerabilities": [
            "No protection against front-running",
            "Vulnerable to impermanent loss"
        ]
    },
    {
        "code": "module SubscriptionService { use std::signer; use aptos_framework::coin; struct Subscription has key { subscriber: address, amount: u64, start_time: u64, duration: u64, } public fun subscribe(account: &signer, amount: u64, duration: u64) { let subscriber = signer::address_of(account); let start_time = aptos_framework::timestamp::now_seconds(); move_to(account, Subscription { subscriber, amount, start_time, duration }); coin::transfer(account, subscriber, amount); } public fun cancel_subscription(account: &signer) acquires Subscription { let subscriber = signer::address_of(account); let subscription = borrow_global_mut<Subscription>(subscriber); coin::transfer(account, subscriber, subscription.amount); destroy(subscription); } public fun check_subscription_status(account: &signer): bool acquires Subscription { let subscriber = signer::address_of(account); let subscription = borrow_global<Subscription>(subscriber); aptos_framework::timestamp::now_seconds() < subscription.start_time + subscription.duration } }",
        "vulnerabilities": [
            "No event emissions for subscriptions and cancellations",
            "No mechanism for partial refunds",
            "No validation of subscription amount and duration",
            "Centralization of subscription management",
            "No mechanism for subscription renewals",
            "No prevention of reentrancy attacks",
            "No mechanism for subscription transfer",
            "Potential for subscriber impersonation",
            "No mechanism for service provider compensation",
            "No prevention of multiple subscriptions per user"
        ]
    },
    {
        "code": "module NFTStaking { use std::signer; use aptos_framework::timestamp; struct NFT has key, store { id: u64, rarity: u8, } struct StakingPool has key { total_staked: u64, reward_per_second: u64, last_update_time: u64, } struct UserStake has key { nfts: vector<NFT>, last_claim_time: u64, } public fun create_pool(admin: &signer, reward_per_second: u64) { let sender = signer::address_of(admin); assert!(!exists<StakingPool>(sender), 1); move_to(admin, StakingPool { total_staked: 0, reward_per_second, last_update_time: timestamp::now_seconds() }); } public fun stake_nft(user: &signer, nft: NFT) acquires StakingPool, UserStake { let sender = signer::address_of(user); let pool = borrow_global_mut<StakingPool>(@staking_address); pool.total_staked = pool.total_staked + 1; if (!exists<UserStake>(sender)) { move_to(user, UserStake { nfts: vector::empty(), last_claim_time: timestamp::now_seconds() }); } let user_stake = borrow_global_mut<UserStake>(sender); vector::push_back(&mut user_stake.nfts, nft); } public fun unstake_nft(user: &signer, nft_id: u64) acquires StakingPool, UserStake { let sender = signer::address_of(user); let pool = borrow_global_mut<StakingPool>(@staking_address); let user_stake = borrow_global_mut<UserStake>(sender); let (found, index) = vector::index_of(&user_stake.nfts, &nft_id); assert!(found, 2); let nft = vector::remove(&mut user_stake.nfts, index); pool.total_staked = pool.total_staked - 1; move_to(user, nft); } public fun claim_rewards(user: &signer) acquires StakingPool, UserStake { let sender = signer::address_of(user); let pool = borrow_global_mut<StakingPool>(@staking_address); let user_stake = borrow_global_mut<UserStake>(sender); let current_time = timestamp::now_seconds(); let time_elapsed = current_time - user_stake.last_claim_time; let reward = (vector::length(&user_stake.nfts) * pool.reward_per_second * time_elapsed) / pool.total_staked; // Transfer reward to user user_stake.last_claim_time = current_time; } }",
        "vulnerabilities": [
            "No checks for NFT ownership when staking",
            "Reward calculation doesn't account for changes in total staked NFTs",
            "Potential for reward draining if total_staked becomes very small"
        ]
    },
    {
        "code": "module Multisig { use std::signer; use std::vector; struct MultisigWallet has key { owners: vector<address>, required_confirmations: u64, transaction_count: u64, } struct Transaction has key { id: u64, to: address, value: u64, data: vector<u8>, executed: bool, confirmations: u64, } struct Confirmation has key { confirmed: vector<u64>, } public fun create_wallet(creator: &signer, owners: vector<address>, required: u64) { let sender = signer::address_of(creator); assert!(!exists<MultisigWallet>(sender), 1); assert!(vector::length(&owners) >= required, 2); move_to(creator, MultisigWallet { owners, required_confirmations: required, transaction_count: 0 }); move_to(creator, Confirmation { confirmed: vector::empty() }); } public fun submit_transaction(submitter: &signer, to: address, value: u64, data: vector<u8>) acquires MultisigWallet { let sender = signer::address_of(submitter); let wallet = borrow_global_mut<MultisigWallet>(sender); assert!(vector::contains(&wallet.owners, &sender), 3); let tx_id = wallet.transaction_count; wallet.transaction_count = wallet.transaction_count + 1; move_to(submitter, Transaction { id: tx_id, to, value, data, executed: false, confirmations: 0 }); } public fun confirm_transaction(confirmer: &signer, tx_id: u64) acquires MultisigWallet, Transaction, Confirmation { let sender = signer::address_of(confirmer); let wallet = borrow_global<MultisigWallet>(@wallet_address); assert!(vector::contains(&wallet.owners, &sender), 4); let tx = borrow_global_mut<Transaction>(@wallet_address); assert!(tx.id == tx_id, 5); assert!(!tx.executed, 6); let confirmation = borrow_global_mut<Confirmation>(sender); if (!vector::contains(&confirmation.confirmed, &tx_id)) { vector::push_back(&mut confirmation.confirmed, tx_id); tx.confirmations = tx.confirmations + 1; } if (tx.confirmations >= wallet.required_confirmations) { // Execute transaction tx.executed = true; } } }",
        "vulnerabilities": [
            "No mechanism to remove or change owners",
            "Lack of access control for submit_transaction",
            "No way to cancel or revoke confirmations"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Market<phantom CoinType> has key { id: u64, description: vector<u8>, resolution_time: u64, total_yes_amount: u64, total_no_amount: u64, resolved: bool, outcome: bool, } struct Position<phantom CoinType> has key { market_id: u64, is_yes: bool, amount: u64, } public fun create_market<CoinType>(creator: &signer, description: vector<u8>, resolution_time: u64) { let sender = signer::address_of(creator); let market_id = get_next_market_id(); move_to(creator, Market<CoinType> { id: market_id, description, resolution_time, total_yes_amount: 0, total_no_amount: 0, resolved: false, outcome: false }); } public fun place_bet<CoinType>(bettor: &signer, market_id: u64, is_yes: bool, amount: u64) acquires Market { let sender = signer::address_of(bettor); let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(!market.resolved, 1); assert!(timestamp::now_seconds() < market.resolution_time, 2); if (is_yes) { market.total_yes_amount = market.total_yes_amount + amount; } else { market.total_no_amount = market.total_no_amount + amount; } coin::transfer<CoinType>(bettor, @market_address, amount); if (!exists<Position<CoinType>>(sender)) { move_to(bettor, Position<CoinType> { market_id, is_yes, amount }); } else { let position = borrow_global_mut<Position<CoinType>>(sender); assert!(position.market_id == market_id, 3); assert!(position.is_yes == is_yes, 4); position.amount = position.amount + amount; } } public fun resolve_market<CoinType>(resolver: &signer, market_id: u64, outcome: bool) acquires Market { let sender = signer::address_of(resolver); assert!(sender == @market_address, 5); let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(market.id == market_id, 6); assert!(!market.resolved, 7); assert!(timestamp::now_seconds() >= market.resolution_time, 8); market.resolved = true; market.outcome = outcome; } public fun claim_winnings<CoinType>(user: &signer, market_id: u64) acquires Market, Position { let sender = signer::address_of(user); let market = borrow_global<Market<CoinType>>(@market_address); assert!(market.id == market_id, 9); assert!(market.resolved, 10); let position = move_from<Position<CoinType>>(sender); assert!(position.market_id == market_id, 11); assert!(position.is_yes == market.outcome, 12); let total_pool = market.total_yes_amount + market.total_no_amount; let winning_pool = if (market.outcome) { market.total_yes_amount } else { market.total_no_amount }; let winnings = (position.amount * total_pool) / winning_pool; coin::transfer<CoinType>(@market_address, sender, winnings); } public(script) fun get_next_market_id(): u64 { // Implementation omitted for brevity 0 } }",
        "vulnerabilities": [
            "No mechanism for early market settlement or cancellation",
            "Potential for front-running in place_bet function",
            "Rounding errors in winnings calculation may favor larger bets"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; use aptos_framework::coin; struct BridgeConfig has key { admin: address, fee_percentage: u64, min_transfer: u64, } struct PendingTransfer has key { id: u64, recipient: address, amount: u64, target_chain: u64, } public fun initialize_bridge(admin: &signer, fee_percentage: u64, min_transfer: u64) { let sender = signer::address_of(admin); assert!(!exists<BridgeConfig>(sender), 1); move_to(admin, BridgeConfig { admin: sender, fee_percentage, min_transfer }); } public fun initiate_transfer<CoinType>(sender: &signer, recipient: address, amount: u64, target_chain: u64) acquires BridgeConfig { let config = borrow_global<BridgeConfig>(@bridge_address); assert!(amount >= config.min_transfer, 2); let fee = (amount * config.fee_percentage) / 10000; let transfer_amount = amount - fee; coin::transfer<CoinType>(sender, @bridge_address, amount); let transfer_id = get_next_transfer_id(); move_to(sender, PendingTransfer { id: transfer_id, recipient, amount: transfer_amount, target_chain }); } public fun complete_transfer<CoinType>(admin: &signer, transfer_id: u64) acquires BridgeConfig, PendingTransfer { let sender = signer::address_of(admin); let config = borrow_global<BridgeConfig>(@bridge_address); assert!(sender == config.admin, 3); let PendingTransfer { id, recipient, amount, target_chain: _ } = move_from<PendingTransfer>(@bridge_address); assert!(id == transfer_id, 4); coin::transfer<CoinType>(@bridge_address, recipient, amount); } public fun update_config(admin: &signer, new_fee_percentage: u64, new_min_transfer: u64) acquires BridgeConfig { let sender = signer::address_of(admin); let config = borrow_global_mut<BridgeConfig>(@bridge_address); assert!(sender == config.admin, 5); config.fee_percentage = new_fee_percentage; config.min_transfer = new_min_transfer; } public(script) fun get_next_transfer_id(): u64 { // Implementation omitted for brevity 0 } }",
        "vulnerabilities": [
            "Single point of failure with admin role",
            "No mechanism to pause transfers in case of emergencies",
            "Lack of validation for target_chain parameter"
        ]
    },
    {
        "code": "module Lottery { use std::signer; use aptos_framework::coin; struct Ticket has key { number: u64, buyer: address, } struct Lottery has key { tickets: vector<Ticket>, prize_pool: u64, end_time: u64, } public fun create_lottery(account: &signer, duration: u64) { let organizer = signer::address_of(account); let end_time = aptos_framework::timestamp::now_seconds() + duration; move_to(account, Lottery { tickets: vector::empty(), prize_pool: 0, end_time }); } public fun buy_ticket(account: &signer, number: u64) acquires Lottery { let buyer = signer::address_of(account); let lottery = borrow_global_mut<Lottery>(buyer); assert!(aptos_framework::timestamp::now_seconds() < lottery.end_time, 1); lottery.prize_pool = lottery.prize_pool + 1; vector::push_back(&mut lottery.tickets, Ticket { number, buyer }); coin::transfer(account, buyer, 1); } public fun draw_winner(account: &signer) acquires Lottery { let organizer = signer::address_of(account); let lottery = borrow_global_mut<Lottery>(organizer); assert!(aptos_framework::timestamp::now_seconds() >= lottery.end_time, 2); let winner = vector::index(lottery.tickets, 0); coin::transfer(account, winner.buyer, lottery.prize_pool); destroy(lottery); } }",
        "vulnerabilities": [
            "No randomness in winner selection",
            "No event emissions for ticket purchases and winner announcement",
            "No mechanism for ticket refunds",
            "Centralization of lottery management",
            "No prevention of multiple ticket purchases by one user",
            "No mechanism for prize distribution",
            "No mechanism for lottery cancellation",
            "No validation of ticket number uniqueness",
            "No prevention of ticket number prediction",
            "No prevention of reentrancy attacks"
        ]
    },
    {
        "code": "module Insurance { use std::signer; use aptos_framework::coin; struct Policy has key { holder: address, premium: u64, coverage: u64, valid_until: u64, } public fun purchase_policy(account: &signer, premium: u64, coverage: u64, duration: u64) { let holder = signer::address_of(account); let valid_until = aptos_framework::timestamp::now_seconds() + duration; move_to(account, Policy { holder, premium, coverage, valid_until }); coin::transfer(account, holder, premium); } public fun claim(account: &signer, policy: &mut Policy) { assert!(aptos_framework::timestamp::now_seconds() < policy.valid_until, 1); coin::transfer(account, policy.holder, policy.coverage); policy.valid_until = aptos_framework::timestamp::now_seconds(); } }",
        "vulnerabilities": [
            "No event emissions for policy purchase and claims",
            "No mechanism for policy cancellation",
            "No validation of policy parameters",
            "Centralization of claim approval",
            "No mechanism for partial claims",
            "No prevention of multiple claims on one policy",
            "No mechanism for policy renewals",
            "No prevention of policy impersonation",
            "No prevention of reentrancy attacks",
            "No mechanism for premium adjustments"
        ]
    },
    {
        "code": "module StakingContract { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakingPool<phantom CoinType> has key { total_staked: u64, reward_per_second: u64, last_update_time: u64, } struct UserStake<phantom CoinType> has key { amount: u64, reward_debt: u64, } const E_NOT_INITIALIZED: u64 = 1; const E_INSUFFICIENT_BALANCE: u64 = 2; public fun initialize<CoinType>(account: &signer, reward_per_second: u64) { let sender = signer::address_of(account); assert!(!exists<StakingPool<CoinType>>(sender), E_NOT_INITIALIZED); move_to(account, StakingPool<CoinType> { total_staked: 0, reward_per_second, last_update_time: timestamp::now_seconds(), }); } public fun stake<CoinType>(account: &signer, amount: u64) acquires StakingPool, UserStake { let sender = signer::address_of(account); let pool = borrow_global_mut<StakingPool<CoinType>>(@staking_pool); update_rewards<CoinType>(); if (!exists<UserStake<CoinType>>(sender)) { move_to(account, UserStake<CoinType> { amount: 0, reward_debt: 0, }); } let user_stake = borrow_global_mut<UserStake<CoinType>>(sender); user_stake.amount = user_stake.amount + amount; user_stake.reward_debt = user_stake.reward_debt + (amount * pool.reward_per_second); pool.total_staked = pool.total_staked + amount; coin::transfer<CoinType>(account, @staking_pool, amount); } public fun unstake<CoinType>(account: &signer, amount: u64) acquires StakingPool, UserStake { let sender = signer::address_of(account); let pool = borrow_global_mut<StakingPool<CoinType>>(@staking_pool); let user_stake = borrow_global_mut<UserStake<CoinType>>(sender); assert!(user_stake.amount >= amount, E_INSUFFICIENT_BALANCE); update_rewards<CoinType>(); user_stake.amount = user_stake.amount - amount; user_stake.reward_debt = user_stake.reward_debt - (amount * pool.reward_per_second); pool.total_staked = pool.total_staked - amount; coin::transfer<CoinType>(@staking_pool, sender, amount); } public fun claim_rewards<CoinType>(account: &signer) acquires StakingPool, UserStake { let sender = signer::address_of(account); update_rewards<CoinType>(); let user_stake = borrow_global_mut<UserStake<CoinType>>(sender); let rewards = calculate_rewards<CoinType>(sender); user_stake.reward_debt = user_stake.reward_debt + rewards; coin::transfer<CoinType>(@staking_pool, sender, rewards); } fun update_rewards<CoinType>() acquires StakingPool { let pool = borrow_global_mut<StakingPool<CoinType>>(@staking_pool); let current_time = timestamp::now_seconds(); let time_elapsed = current_time - pool.last_update_time; pool.last_update_time = current_time; } fun calculate_rewards<CoinType>(user_address: address): u64 acquires StakingPool, UserStake { let pool = borrow_global<StakingPool<CoinType>>(@staking_pool); let user_stake = borrow_global<UserStake<CoinType>>(user_address); let time_elapsed = timestamp::now_seconds() - pool.last_update_time; (user_stake.amount * pool.reward_per_second * time_elapsed) / pool.total_staked } }",
        "vulnerabilities": [
            "Lack of access control for initialize function",
            "No mechanism to update reward rate",
            "Missing event emissions for staking and unstaking",
            "Potential integer overflow in reward calculations",
            "No slippage protection for large stakes/unstakes",
            "Centralized control of the staking pool",
            "No minimum staking period",
            "Lack of emergency withdrawal mechanism",
            "No cap on total staked amount",
            "Potential for flash loan attacks in reward claiming"
        ]
    },
    {
        "code": "module MultisigWallet { use std::signer; use std::vector; use aptos_framework::coin; struct MultiSigWallet<phantom CoinType> has key { owners: vector<address>, required_signatures: u64, transaction_count: u64, } struct Transaction<phantom CoinType> has key { to: address, amount: u64, approvals: vector<address>, executed: bool, } public fun create_wallet<CoinType>(creator: &signer, owners: vector<address>, required_signatures: u64) { let sender = signer::address_of(creator); assert!(!exists<MultiSigWallet<CoinType>>(sender), 1); assert!(vector::length(&owners) >= required_signatures, 2); move_to(creator, MultiSigWallet<CoinType> { owners, required_signatures, transaction_count: 0 }); } public fun submit_transaction<CoinType>(submitter: &signer, to: address, amount: u64) acquires MultiSigWallet { let sender = signer::address_of(submitter); let wallet = borrow_global_mut<MultiSigWallet<CoinType>>(@wallet_address); assert!(vector::contains(&wallet.owners, &sender), 3); let transaction_id = wallet.transaction_count; wallet.transaction_count = wallet.transaction_count + 1; move_to(submitter, Transaction<CoinType> { to, amount, approvals: vector::empty(), executed: false }); vector::push_back(&mut borrow_global_mut<Transaction<CoinType>>(@wallet_address).approvals, sender); } public fun approve_transaction<CoinType>(approver: &signer, transaction_id: u64) acquires MultiSigWallet, Transaction { let sender = signer::address_of(approver); let wallet = borrow_global<MultiSigWallet<CoinType>>(@wallet_address); assert!(vector::contains(&wallet.owners, &sender), 3); let transaction = borrow_global_mut<Transaction<CoinType>>(@wallet_address); assert!(!transaction.executed, 4); assert!(!vector::contains(&transaction.approvals, &sender), 5); vector::push_back(&mut transaction.approvals, sender); if (vector::length(&transaction.approvals) >= wallet.required_signatures) { transaction.executed = true; coin::transfer<CoinType>(@wallet_address, transaction.to, transaction.amount); } } public fun get_transaction_info<CoinType>(transaction_id: u64): (address, u64, u64, bool) acquires Transaction { let transaction = borrow_global<Transaction<CoinType>>(@wallet_address); (transaction.to, transaction.amount, vector::length(&transaction.approvals), transaction.executed) } }",
        "vulnerabilities": [
            "Lack of mechanism to change owners or required signatures"
        ]
    },
    {
        "code": "module TokenSwap { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: u64, reserve_y: u64, lp_token_supply: u64, } struct LPToken<phantom X, phantom Y> {} public fun initialize<X, Y>(account: &signer) { let sender = signer::address_of(account); assert!(!exists<LiquidityPool<X, Y>>(sender), 1); move_to(account, LiquidityPool<X, Y> { reserve_x: 0, reserve_y: 0, lp_token_supply: 0, }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<X, Y>>(@token_swap); let lp_tokens = if (pool.lp_token_supply == 0) { amount_x } else { (amount_x * pool.lp_token_supply) / pool.reserve_x }; pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; pool.lp_token_supply = pool.lp_token_supply + lp_tokens; coin::transfer<X>(account, @token_swap, amount_x); coin::transfer<Y>(account, @token_swap, amount_y); coin::mint<LPToken<X, Y>>(lp_tokens, account); } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@token_swap); let amount_out = (amount_in * pool.reserve_y) / (pool.reserve_x + amount_in); assert!(amount_out >= min_amount_out, 2); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; coin::transfer<X>(account, @token_swap, amount_in); coin::transfer<Y>(@token_swap, signer::address_of(account), amount_out); } }",
        "vulnerabilities": [
            "No slippage protection in add_liquidity function",
            "Lack of access control for initialize function",
            "Potential for price manipulation through large swaps",
            "No mechanism to pause the contract in case of emergencies",
            "Absence of events for important operations",
            "Potential integer overflow in swap calculations",
            "No time-weighted average price (TWAP) oracle",
            "Lack of fee mechanism for swaps",
            "No protection against flash loan attacks",
            "Centralized control of the liquidity pool"
        ]
    },
    {
        "code": "module SimpleToken { use std::signer; struct Token has key { balance: u64 } public fun mint(account: &signer, amount: u64) { let token = Token { balance: amount }; move_to(account, token); } public fun transfer(from: &signer, to: address, amount: u64) acquires Token { let from_token = borrow_global_mut<Token>(signer::address_of(from)); assert!(from_token.balance >= amount, 101); from_token.balance = from_token.balance - amount; let to_token = borrow_global_mut<Token>(to); to_token.balance = to_token.balance + amount; } }",
        "vulnerabilities": [
            "Integer overflow in transfer function",
            "Lack of access control for mint function",
            "No event emissions for minting and transfers",
            "Missing total supply tracking",
            "Absence of burn functionality"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::timestamp; struct Auction has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64 } public fun create_auction(seller: &signer, duration: u64) { let auction = Auction { seller: signer::address_of(seller), highest_bidder: @0x0, highest_bid: 0, end_time: timestamp::now_seconds() + duration }; move_to(seller, auction); } public fun bid(bidder: &signer, amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@0x1); assert!(timestamp::now_seconds() < auction.end_time, 101); assert!(amount > auction.highest_bid, 102); auction.highest_bidder = signer::address_of(bidder); auction.highest_bid = amount; } }",
        "vulnerabilities": [
            "Lack of refund mechanism for outbid participants",
            "No check for auction existence in bid function",
            "Missing event emissions for bids and auction creation",
            "Centralization risk with fixed auction address",
            "No mechanism to extend auction time"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Auction has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64, ended: bool, } struct PendingReturns has key { returns: u64, } const E_NOT_INITIALIZED: u64 = 1; const E_AUCTION_ENDED: u64 = 2; const E_BID_TOO_LOW: u64 = 3; const E_AUCTION_NOT_ENDED: u64 = 4; public fun create_auction<CoinType>(seller: &signer, duration: u64) { let sender = signer::address_of(seller); move_to(seller, Auction { seller: sender, highest_bidder: sender, highest_bid: 0, end_time: timestamp::now_seconds() + duration, ended: false, }); } public fun bid<CoinType>(bidder: &signer, amount: u64) acquires Auction, PendingReturns { let sender = signer::address_of(bidder); let auction = borrow_global_mut<Auction>(@auction_address); assert!(!auction.ended, E_AUCTION_ENDED); assert!(amount > auction.highest_bid, E_BID_TOO_LOW); if (auction.highest_bidder != auction.seller) { let pending_returns = borrow_global_mut<PendingReturns>(auction.highest_bidder); pending_returns.returns = pending_returns.returns + auction.highest_bid; } auction.highest_bidder = sender; auction.highest_bid = amount; coin::transfer<CoinType>(bidder, @auction_address, amount); } public fun end_auction<CoinType>() acquires Auction { let auction = borrow_global_mut<Auction>(@auction_address); assert!(timestamp::now_seconds() >= auction.end_time, E_AUCTION_NOT_ENDED); assert!(!auction.ended, E_AUCTION_ENDED); auction.ended = true; coin::transfer<CoinType>(@auction_address, auction.seller, auction.highest_bid); } public fun withdraw<CoinType>(account: &signer) acquires PendingReturns { let sender = signer::address_of(account); let pending_returns = borrow_global_mut<PendingReturns>(sender); let amount = pending_returns.returns; pending_returns.returns = 0; coin::transfer<CoinType>(@auction_address, sender, amount); } }",
        "vulnerabilities": [
            "Lack of access control for create_auction function",
            "No minimum bid increment",
            "Missing event emissions for bids and auction end",
            "Potential reentrancy in withdraw function",
            "No mechanism to cancel an auction",
            "Centralized control of the auction contract",
            "Lack of slippage protection for bids",
            "No checks for contract balance before transfers",
            "Potential integer overflow in bid amounts",
            "Missing checks for zero address in transfers"
        ]
    },
    {
        "code": "module DecentralizedInsurance { use std::signer; use std::vector; struct InsurancePool has key { balance: u64, policies: vector<Policy>, } struct Policy has store { policyholder: address, coverage_amount: u64, premium: u64, expiry: u64, } public fun create_pool(creator: &signer) { move_to(creator, InsurancePool { balance: 0, policies: vector::empty(), }); } public fun buy_policy(buyer: &signer, coverage: u64, duration: u64) acquires InsurancePool { let sender = signer::address_of(buyer); let pool = borrow_global_mut<InsurancePool>(@0x1); let premium = calculate_premium(coverage, duration); // Transfer premium (simplified) pool.balance = pool.balance + premium; let policy = Policy { policyholder: sender, coverage_amount: coverage, premium, expiry: timestamp::now_seconds() + duration, }; vector::push_back(&mut pool.policies, policy); } public fun claim(claimer: &signer, amount: u64) acquires InsurancePool { let sender = signer::address_of(claimer); let pool = borrow_global_mut<InsurancePool>(@0x1); let (found, index) = find_valid_policy(sender, &pool.policies); assert!(found, 1); let policy = vector::borrow(&pool.policies, index); assert!(amount <= policy.coverage_amount, 2); assert!(pool.balance >= amount, 3); // Transfer claim amount (simplified) pool.balance = pool.balance - amount; } fun calculate_premium(coverage: u64, duration: u64): u64 { // Premium calculation logic (simplified) coverage * duration / 10000 } fun find_valid_policy(policyholder: address, policies: &vector<Policy>): (bool, u64) { let i = 0; while (i < vector::length(policies)) { let policy = vector::borrow(policies, i); if (policy.policyholder == policyholder && policy.expiry > timestamp::now_seconds()) { return (true, i) } i = i + 1; } (false, 0) } }",
        "vulnerabilities": [
            "Lack of oracle for real-world event verification",
            "No mechanism for partial claims",
            "Potential for insolvency if too many claims occur simultaneously"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use std::vector; struct Market has key { id: u64, question: vector<u8>, options: vector<vector<u8>>, bets: vector<Bet>, end_time: u64, resolved: bool, winning_option: u64, } struct Bet has store { bettor: address, option: u64, amount: u64, } public fun create_market(creator: &signer, question: vector<u8>, options: vector<vector<u8>>, duration: u64) acquires Market { let sender = signer::address_of(creator); let market_id = borrow_global<Market>(@0x1).id + 1; move_to(creator, Market { id: market_id, question, options, bets: vector::empty(), end_time: timestamp::now_seconds() + duration, resolved: false, winning_option: 0, }); } public fun place_bet(bettor: &signer, market_id: u64, option: u64, amount: u64) acquires Market { let sender = signer::address_of(bettor); let market = borrow_global_mut<Market>(@0x1); assert!(!market.resolved && timestamp::now_seconds() < market.end_time, 1); assert!(option < vector::length(&market.options), 2); // Transfer funds (simplified) let bet = Bet { bettor: sender, option, amount }; vector::push_back(&mut market.bets, bet); } public fun resolve_market(resolver: &signer, market_id: u64, winning_option: u64) acquires Market { let market = borrow_global_mut<Market>(@0x1); assert!(timestamp::now_seconds() >= market.end_time && !market.resolved, 3); assert!(winning_option < vector::length(&market.options), 4); market.resolved = true; market.winning_option = winning_option; } public fun claim_winnings(claimer: &signer, market_id: u64) acquires Market { let sender = signer::address_of(claimer); let market = borrow_global<Market>(@0x1); assert!(market.resolved, 5); let total_pot = calculate_total_pot(&market.bets); let winning_pot = calculate_winning_pot(&market.bets, market.winning_option); let claimer_bet = find_bet(&market.bets, sender, market.winning_option); let winnings = (claimer_bet.amount * total_pot) / winning_pot; // Transfer winnings (simplified) } fun calculate_total_pot(bets: &vector<Bet>): u64 { let total = 0; let i = 0; while (i < vector::length(bets)) { total = total + vector::borrow(bets, i).amount; i = i + 1; } total } fun calculate_winning_pot(bets: &vector<Bet>, winning_option: u64): u64 { let total = 0; let i = 0; while (i < vector::length(bets)) { let bet = vector::borrow(bets, i); if (bet.option == winning_option) { total = total + bet.amount; } i = i + 1; } total } fun find_bet(bets: &vector<Bet>, bettor: address, option: u64): &Bet { let i = 0; while (i < vector::length(bets)) { let bet = vector::borrow(bets, i); if (bet.bettor == bettor && bet.option == option) { return bet } i = i + 1; } abort 6 } }",
        "vulnerabilities": [
            "Centralized market resolution",
            "No mechanism for handling disputed outcomes",
            "Potential for front-running when placing bets"
        ]
    },
    {
        "code": "module DeFiLendingPlatform { use std::signer; use aptos_framework::coin; struct LendingPool<phantom CoinType> has key { total_deposits: u64, total_borrows: u64, interest_rate: u64, } struct UserPosition<phantom CoinType> has key { deposited: u64, borrowed: u64, } public fun initialize_pool<CoinType>(admin: &signer, initial_rate: u64) { let sender = signer::address_of(admin); assert!(!exists<LendingPool<CoinType>>(sender), 1); move_to(admin, LendingPool<CoinType> { total_deposits: 0, total_borrows: 0, interest_rate: initial_rate }); } public fun deposit<CoinType>(user: &signer, amount: u64) acquires LendingPool, UserPosition { let sender = signer::address_of(user); let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_address); coin::transfer<CoinType>(user, @lending_address, amount); pool.total_deposits = pool.total_deposits + amount; if (!exists<UserPosition<CoinType>>(sender)) { move_to(user, UserPosition<CoinType> { deposited: amount, borrowed: 0 }); } else { let position = borrow_global_mut<UserPosition<CoinType>>(sender); position.deposited = position.deposited + amount; } } public fun borrow<CoinType>(user: &signer, amount: u64) acquires LendingPool, UserPosition { let sender = signer::address_of(user); let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_address); assert!(pool.total_deposits - pool.total_borrows >= amount, 2); coin::transfer<CoinType>(@lending_address, sender, amount); pool.total_borrows = pool.total_borrows + amount; if (!exists<UserPosition<CoinType>>(sender)) { move_to(user, UserPosition<CoinType> { deposited: 0, borrowed: amount }); } else { let position = borrow_global_mut<UserPosition<CoinType>>(sender); position.borrowed = position.borrowed + amount; } } }",
        "vulnerabilities": [
            "Lack of collateralization checks for borrowing",
            "No mechanism for liquidation of undercollateralized positions",
            "Interest rate calculation not implemented"
        ]
    },
    {
        "code": "module SimpleToken { use std::signer; struct Token has key { balance: u64 } public fun mint(account: &signer, amount: u64) { let token = Token { balance: amount }; move_to(account, token); } public fun transfer(from: &signer, to: address, amount: u64) acquires Token { let from_token = borrow_global_mut<Token>(signer::address_of(from)); assert!(from_token.balance >= amount, 101); from_token.balance = from_token.balance - amount; if (!exists<Token>(to)) { move_to(&signer::create_signer(to), Token { balance: amount }); } else { let to_token = borrow_global_mut<Token>(to); to_token.balance = to_token.balance + amount; } } }",
        "vulnerabilities": [
            "No access control for minting",
            "Integer overflow in transfer function",
            "Lack of events for important state changes",
            "No total supply tracking",
            "Centralized minting mechanism"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::timestamp; struct Auction has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64 } public fun create_auction(seller: &signer, duration: u64) { let auction = Auction { seller: signer::address_of(seller), highest_bidder: @0x0, highest_bid: 0, end_time: timestamp::now_seconds() + duration }; move_to(seller, auction); } public fun bid(bidder: &signer, amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@0x1); assert!(timestamp::now_seconds() < auction.end_time, 101); assert!(amount > auction.highest_bid, 102); auction.highest_bidder = signer::address_of(bidder); auction.highest_bid = amount; } }",
        "vulnerabilities": [
            "No mechanism to return funds to previous highest bidder",
            "Lack of access control for auction creation",
            "No events emitted for bids or auction end",
            "Potential for timestamp manipulation",
            "Missing auction finalization function"
        ]
    },
    {
        "code": "module SimplePetRegistry { use std::string::String; use aptos_framework::table; struct Pet has copy, drop { name: String, species: String, age: u8 } struct PetStore has key { pets: table::Table<address, Pet> } public fun initialize(account: &signer) { move_to(account, PetStore { pets: table::new() }); } public fun register_pet(owner: &signer, name: String, species: String, age: u8) acquires PetStore { let pet_store = borrow_global_mut<PetStore>(@0x1); let pet = Pet { name, species, age }; table::add(&mut pet_store.pets, signer::address_of(owner), pet); } public fun update_pet_age(owner: &signer, new_age: u8) acquires PetStore { let pet_store = borrow_global_mut<PetStore>(@0x1); let pet = table::borrow_mut(&mut pet_store.pets, signer::address_of(owner)); pet.age = new_age; } }",
        "vulnerabilities": [
            "Lack of access control for initialization",
            "No mechanism to remove pets",
            "Missing event emissions for pet registration and updates",
            "No checks for duplicate pet registrations",
            "Centralized pet store design"
        ]
    },
    {
        "code": "module LendingProtocol { use std::signer; use std::vector; struct LendingPool has key { deposits: vector<Deposit>, loans: vector<Loan>, total_deposits: u64, total_borrowed: u64, } struct Deposit has store { depositor: address, amount: u64, } struct Loan has store { borrower: address, amount: u64, collateral: u64, } public fun initialize_pool(creator: &signer) { move_to(creator, LendingPool { deposits: vector::empty(), loans: vector::empty(), total_deposits: 0, total_borrowed: 0, }); } public fun deposit(depositor: &signer, amount: u64) acquires LendingPool { let sender = signer::address_of(depositor); let pool = borrow_global_mut<LendingPool>(@0x1); // Transfer funds (simplified) let deposit = Deposit { depositor: sender, amount }; vector::push_back(&mut pool.deposits, deposit); pool.total_deposits = pool.total_deposits + amount; } public fun borrow(borrower: &signer, amount: u64, collateral: u64) acquires LendingPool { let sender = signer::address_of(borrower); let pool = borrow_global_mut<LendingPool>(@0x1); assert!(pool.total_deposits - pool.total_borrowed >= amount, 1); assert!(collateral >= amount * 15 / 10, 2); // 150% collateralization ratio // Transfer collateral and loan amount (simplified) let loan = Loan { borrower: sender, amount, collateral }; vector::push_back(&mut pool.loans, loan); pool.total_borrowed = pool.total_borrowed + amount; } public fun repay(borrower: &signer, amount: u64) acquires LendingPool { let sender = signer::address_of(borrower); let pool = borrow_global_mut<LendingPool>(@0x1); let (found, index) = find_loan(&pool.loans, sender); assert!(found, 3); let loan = vector::borrow_mut(&mut pool.loans, index); assert!(amount <= loan.amount, 4); // Transfer repayment (simplified) loan.amount = loan.amount - amount; pool.total_borrowed = pool.total_borrowed - amount; if (loan.amount == 0) { let Loan { borrower: _, amount: _, collateral } = vector::remove(&mut pool.loans, index); // Return collateral (simplified) } } fun find_loan(loans: &vector<Loan>, borrower: address): (bool, u64) { let i = 0; while (i < vector::length(loans)) { if (vector::borrow(loans, i).borrower == borrower) { return (true, i) } i = i + 1; } (false, 0) } }",
        "vulnerabilities": [
            "No interest rate mechanism",
            "Lack of liquidation process for undercollateralized loans",
            "No consideration for different asset types and their volatilities"
        ]
    },
    {
        "code": "module SimpleNFT { use std::string; use std::signer; struct NFT has key, store { id: u64, name: string::String, description: string::String } struct Collection has key { nfts: vector<NFT>, next_id: u64 } public fun create_collection(creator: &signer) { move_to(creator, Collection { nfts: vector::empty(), next_id: 0 }); } public fun mint_nft(creator: &signer, name: string::String, description: string::String) acquires Collection { let creator_address = signer::address_of(creator); let collection = borrow_global_mut<Collection>(creator_address); let new_nft = NFT { id: collection.next_id, name, description }; vector::push_back(&mut collection.nfts, new_nft); collection.next_id = collection.next_id + 1; } }",
        "vulnerabilities": [
            "Lack of access control for minting",
            "No transfer functionality implemented",
            "Missing event emissions for minting and collection creation",
            "Potential for unbounded collection growth",
            "No mechanism to burn or destroy NFTs"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct NFT has key, store { creator: address, id: u64, metadata: vector<u8>, } struct Listing has key { nft: NFT, price: u64, expiration: u64, } struct MarketplaceFee has key { fee_percentage: u64, } public fun create_nft(creator: &signer, metadata: vector<u8>): NFT { let sender = signer::address_of(creator); NFT { creator: sender, id: get_next_nft_id(), metadata } } public fun list_nft(seller: &signer, nft: NFT, price: u64, duration: u64) { let sender = signer::address_of(seller); let expiration = timestamp::now_seconds() + duration; move_to(seller, Listing { nft, price, expiration }); } public fun buy_nft<CoinType>(buyer: &signer, seller: address) acquires Listing, MarketplaceFee { let listing = move_from<Listing>(seller); assert!(timestamp::now_seconds() <= listing.expiration, 1); let fee = borrow_global<MarketplaceFee>(@marketplace_address); let fee_amount = (listing.price * fee.fee_percentage) / 100; let seller_amount = listing.price - fee_amount; coin::transfer<CoinType>(buyer, seller, seller_amount); coin::transfer<CoinType>(buyer, @marketplace_address, fee_amount); move_to(buyer, listing.nft); } public fun cancel_listing(seller: &signer) acquires Listing { let sender = signer::address_of(seller); let Listing { nft, price: _, expiration: _ } = move_from<Listing>(sender); move_to(seller, nft); } public fun initialize_marketplace(admin: &signer, fee_percentage: u64) { let sender = signer::address_of(admin); assert!(sender == @marketplace_address, 2); move_to(admin, MarketplaceFee { fee_percentage }); } public(script) fun get_next_nft_id(): u64 { // Implementation omitted for brevity 0 } }",
        "vulnerabilities": [
            "Lack of royalty payments to original creators",
            "No mechanism to update or remove expired listings",
            "Potential for front-running in buy transactions"
        ]
    },
    {
        "code": "module TokenSwap { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom TokenX, phantom TokenY> has key { reserve_x: u64, reserve_y: u64, lp_token_supply: u64 } public fun create_pool<TokenX, TokenY>(creator: &signer, initial_x: u64, initial_y: u64) { let sender = signer::address_of(creator); assert!(!exists<LiquidityPool<TokenX, TokenY>>(sender), 1); coin::transfer<TokenX>(creator, @pool_address, initial_x); coin::transfer<TokenY>(creator, @pool_address, initial_y); move_to(creator, LiquidityPool<TokenX, TokenY> { reserve_x: initial_x, reserve_y: initial_y, lp_token_supply: (initial_x * initial_y).sqrt() }); } public fun add_liquidity<TokenX, TokenY>(provider: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<TokenX, TokenY>>(@pool_address); let sender = signer::address_of(provider); let lp_tokens = std::math::min((amount_x * pool.lp_token_supply) / pool.reserve_x, (amount_y * pool.lp_token_supply) / pool.reserve_y); coin::transfer<TokenX>(provider, @pool_address, amount_x); coin::transfer<TokenY>(provider, @pool_address, amount_y); pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; pool.lp_token_supply = pool.lp_token_supply + lp_tokens; coin::mint<LPToken>(lp_tokens, provider); } public fun swap<TokenX, TokenY>(user: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<TokenX, TokenY>>(@pool_address); let amount_out = (amount_in * 997 * pool.reserve_y) / (pool.reserve_x * 1000 + amount_in * 997); assert!(amount_out >= min_amount_out, 2); coin::transfer<TokenX>(user, @pool_address, amount_in); coin::transfer<TokenY>(@pool_address, signer::address_of(user), amount_out); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; } }",
        "vulnerabilities": [
            "No slippage protection in add_liquidity function",
            "Potential for sandwich attacks in swap function",
            "Lack of access control for creating pools"
        ]
    },
    {
        "code": "module SimpleNFT { use std::string; use std::signer; struct NFT has key, store { id: u64, name: string::String, description: string::String } struct Collection has key { nfts: vector<NFT>, next_id: u64 } public fun create_collection(creator: &signer) { move_to(creator, Collection { nfts: vector::empty(), next_id: 0 }); } public fun mint_nft(creator: &signer, name: string::String, description: string::String) acquires Collection { let creator_address = signer::address_of(creator); let collection = borrow_global_mut<Collection>(creator_address); let new_nft = NFT { id: collection.next_id, name, description }; vector::push_back(&mut collection.nfts, new_nft); collection.next_id = collection.next_id + 1; } }",
        "vulnerabilities": [
            "Lack of access control for minting",
            "No transfer functionality implemented",
            "Missing event emissions for minting and collection creation",
            "Potential for unbounded collection growth",
            "No mechanism to burn or destroy NFTs"
        ]
    },
    {
        "code": "module SimpleStaking { use std::signer; use aptos_framework::coin; struct StakingPool<phantom CoinType> has key { total_staked: u64, reward_per_token: u64, last_update_time: u64 } struct UserStake<phantom CoinType> has key { amount: u64, reward_debt: u64 } public fun create_pool<CoinType>(creator: &signer) { move_to(creator, StakingPool<CoinType> { total_staked: 0, reward_per_token: 0, last_update_time: aptos_framework::timestamp::now_seconds() }); } public fun stake<CoinType>(staker: &signer, amount: u64) acquires StakingPool, UserStake { let pool = borrow_global_mut<StakingPool<CoinType>>(@0x1); pool.total_staked = pool.total_staked + amount; if (!exists<UserStake<CoinType>>(signer::address_of(staker))) { move_to(staker, UserStake<CoinType> { amount: 0, reward_debt: 0 }); } let user_stake = borrow_global_mut<UserStake<CoinType>>(signer::address_of(staker)); user_stake.amount = user_stake.amount + amount; user_stake.reward_debt = user_stake.reward_debt + (amount * pool.reward_per_token); coin::transfer<CoinType>(staker, @0x1, amount); } }",
        "vulnerabilities": [
            "Lack of unstake functionality",
            "Missing reward distribution mechanism",
            "No access control for pool creation",
            "Centralization risk with fixed pool address",
            "Potential for precision loss in reward calculations"
        ]
    },
    {
        "code": "module SimpleGovernance { use std::signer; use aptos_framework::table; struct Proposal has key { description: vector<u8>, votes: u64, executed: bool, execution_time: u64 } struct GovernanceConfig has key { voting_period: u64, execution_delay: u64, proposal_threshold: u64 } public fun create_proposal(creator: &signer, description: vector<u8>) acquires GovernanceConfig { let config = borrow_global<GovernanceConfig>(@0x1); assert!(coin::balance<GovernanceToken>(signer::address_of(creator)) >= config.proposal_threshold, 101); let proposal = Proposal { description, votes: 0, executed: false, execution_time: 0 }; move_to(creator, proposal); } public fun vote(voter: &signer, proposal_address: address) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(!proposal.executed, 102); proposal.votes = proposal.votes + coin::balance<GovernanceToken>(signer::address_of(voter)); } }",
        "vulnerabilities": [
            "Lack of vote delegation mechanism",
            "Missing vote weight decay over time",
            "No quorum requirement for proposal execution",
            "Potential for sybil attacks if token distribution is not careful",
            "Missing event emissions for proposals and votes"
        ]
    },
    {
        "code": "module SimplePredictionMarket { use std::signer; struct Market has key { question: vector<u8>, total_yes_stake: u64, total_no_stake: u64, resolution: Option<bool>, end_time: u64 } public fun create_market(creator: &signer, question: vector<u8>, duration: u64) { let market = Market { question, total_yes_stake: 0, total_no_stake: 0, resolution: Option::none(), end_time: aptos_framework::timestamp::now_seconds() + duration }; move_to(creator, market); } public fun place_bet(bettor: &signer, market_address: address, amount: u64, bet_yes: bool) acquires Market { let market = borrow_global_mut<Market>(market_address); assert!(Option::is_none(&market.resolution), 101); assert!(aptos_framework::timestamp::now_seconds() < market.end_time, 102); if (bet_yes) { market.total_yes_stake = market.total_yes_stake + amount; } else { market.total_no_stake = market.total_no_stake + amount; } coin::transfer<AptosCoin>(bettor, market_address, amount); } }",
        "vulnerabilities": [
            "Lack of oracle for result verification",
            "Missing mechanism for bet withdrawal",
            "No slippage protection for large bets",
            "Potential for market manipulation with large stakes",
            "Absence of dispute resolution process"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::nft; struct Listing has key { creator: address, token_id: u64, price: u64 } public fun list_nft(seller: &signer, token_id: u64, price: u64) { let sender = signer::address_of(seller); assert!(nft::balance_of(sender, token_id) > 0, 1); move_to(seller, Listing { creator: sender, token_id, price }); } public fun buy_nft<CoinType>(buyer: &signer, seller: address, token_id: u64) acquires Listing { let listing = move_from<Listing>(seller); assert!(listing.token_id == token_id, 2); coin::transfer<CoinType>(buyer, seller, listing.price); nft::transfer(seller, signer::address_of(buyer), token_id); } public fun cancel_listing(seller: &signer, token_id: u64) acquires Listing { let sender = signer::address_of(seller); let Listing { creator, token_id: _, price: _ } = move_from<Listing>(sender); assert!(creator == sender, 3); } }",
        "vulnerabilities": [
            "No royalty distribution mechanism for NFT creators",
            "Lack of escrow for NFT trades",
            "No mechanism to update listing price"
        ]
    },
    {
        "code": "module Governance { use std::signer; use aptos_framework::coin; struct Proposal has key { id: u64, description: vector<u8>, votes_for: u64, votes_against: u64, end_time: u64 } struct Vote has key { proposal_id: u64, amount: u64 } public fun create_proposal(creator: &signer, description: vector<u8>, voting_period: u64) { let proposal_id = get_next_proposal_id(); move_to(creator, Proposal { id: proposal_id, description, votes_for: 0, votes_against: 0, end_time: aptos_framework::timestamp::now_seconds() + voting_period }); } public fun vote<GovernanceToken>(voter: &signer, proposal_id: u64, vote_for: bool, amount: u64) acquires Proposal, Vote { let sender = signer::address_of(voter); let proposal = borrow_global_mut<Proposal>(@governance_address); assert!(proposal.id == proposal_id, 1); assert!(aptos_framework::timestamp::now_seconds() < proposal.end_time, 2); coin::transfer<GovernanceToken>(voter, @governance_address, amount); if (vote_for) { proposal.votes_for = proposal.votes_for + amount; } else { proposal.votes_against = proposal.votes_against + amount; } if (!exists<Vote>(sender)) { move_to(voter, Vote { proposal_id, amount }); } else { let vote = borrow_global_mut<Vote>(sender); vote.amount = vote.amount + amount; } } public fun execute_proposal(executor: &signer, proposal_id: u64) acquires Proposal { let sender = signer::address_of(executor); assert!(sender == @governance_address, 3); let proposal = move_from<Proposal>(@governance_address); assert!(proposal.id == proposal_id, 4); assert!(aptos_framework::timestamp::now_seconds() >= proposal.end_time, 5); assert!(proposal.votes_for > proposal.votes_against, 6); // Execute proposal logic here } }",
        "vulnerabilities": [
            "No quorum requirement for proposal execution",
            "Lack of time lock for proposal execution",
            "No mechanism to prevent duplicate voting"
        ]
    },
    {
        "code": "module SimpleGovernance { use std::signer; use aptos_framework::table; struct Proposal has key { description: vector<u8>, votes: u64, executed: bool, execution_time: u64 } struct GovernanceConfig has key { voting_period: u64, execution_delay: u64, proposal_threshold: u64 } public fun create_proposal(creator: &signer, description: vector<u8>) acquires GovernanceConfig { let config = borrow_global<GovernanceConfig>(@0x1); assert!(coin::balance<GovernanceToken>(signer::address_of(creator)) >= config.proposal_threshold, 101); let proposal = Proposal { description, votes: 0, executed: false, execution_time: 0 }; move_to(creator, proposal); } public fun vote(voter: &signer, proposal_address: address) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(!proposal.executed, 102); proposal.votes = proposal.votes + coin::balance<GovernanceToken>(signer::address_of(voter)); } }",
        "vulnerabilities": [
            "Lack of vote delegation mechanism",
            "Missing vote weight decay over time",
            "No quorum requirement for proposal execution",
            "Potential for sybil attacks if token distribution is not careful",
            "Missing event emissions for proposals and votes"
        ]
    },
    {
        "code": "module SimpleNFT { use std::string; use std::signer; struct NFT has key, store { id: u64, name: string::String, description: string::String } struct Collection has key { nfts: vector<NFT>, next_id: u64 } public fun create_collection(creator: &signer) { move_to(creator, Collection { nfts: vector::empty(), next_id: 0 }); } public fun mint_nft(creator: &signer, name: string::String, description: string::String) acquires Collection { let creator_address = signer::address_of(creator); let collection = borrow_global_mut<Collection>(creator_address); let new_nft = NFT { id: collection.next_id, name, description }; vector::push_back(&mut collection.nfts, new_nft); collection.next_id = collection.next_id + 1; } }",
        "vulnerabilities": [
            "Lack of access control for minting",
            "No transfer functionality implemented",
            "Missing event emissions for minting and collection creation",
            "Potential for unbounded collection growth",
            "No mechanism to burn or destroy NFTs"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::timestamp; struct Auction has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64 } public fun create_auction(seller: &signer, duration: u64) { let auction = Auction { seller: signer::address_of(seller), highest_bidder: @0x0, highest_bid: 0, end_time: timestamp::now_seconds() + duration }; move_to(seller, auction); } public fun bid(bidder: &signer, amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@0x1); assert!(timestamp::now_seconds() < auction.end_time, 101); assert!(amount > auction.highest_bid, 102); auction.highest_bidder = signer::address_of(bidder); auction.highest_bid = amount; } }",
        "vulnerabilities": [
            "Lack of refund mechanism for outbid participants",
            "No check for auction existence in bid function",
            "Missing event emissions for bids and auction creation",
            "Centralization risk with fixed auction address",
            "No mechanism to extend auction time"
        ]
    },
    {
        "code": "module StableCoin { use std::signer; use aptos_framework::coin; struct ReserveToken {} struct StableCoin {} struct Oracle has key { price: u64 } public fun mint(minter: &signer, amount: u64) acquires Oracle { let oracle = borrow_global<Oracle>(@oracle_address); let collateral_required = (amount * oracle.price) / 1000000; // Assuming 6 decimal places coin::transfer<ReserveToken>(minter, @reserve_address, collateral_required); coin::mint<StableCoin>(amount, minter); } public fun burn(burner: &signer, amount: u64) acquires Oracle { let oracle = borrow_global<Oracle>(@oracle_address); let collateral_to_return = (amount * oracle.price) / 1000000; // Assuming 6 decimal places coin::burn<StableCoin>(amount, burner); coin::transfer<ReserveToken>(@reserve_address, signer::address_of(burner), collateral_to_return); } public fun update_price(oracle_admin: &signer, new_price: u64) acquires Oracle { assert!(signer::address_of(oracle_admin) == @oracle_address, 1); let oracle = borrow_global_mut<Oracle>(@oracle_address); oracle.price = new_price; } }",
        "vulnerabilities": [
            "Single point of failure with centralized oracle",
            "No liquidation mechanism for undercollateralized positions",
            "Lack of governance for important parameters"
        ]
    },
    {
        "code": "module Escrow { use std::signer; use aptos_framework::coin; struct EscrowAgreement has key { seller: address, buyer: address, amount: u64, completed: bool } public fun create_escrow<CoinType>(buyer: &signer, seller: address, amount: u64) { let sender = signer::address_of(buyer); coin::transfer<CoinType>(buyer, @escrow_address, amount); move_to(buyer, EscrowAgreement { seller, buyer: sender, amount, completed: false }); } public fun release_funds<CoinType>(releaser: &signer) acquires EscrowAgreement { let sender = signer::address_of(releaser); let agreement = move_from<EscrowAgreement>(sender); assert!(!agreement.completed, 1); assert!(sender == agreement.buyer || sender == agreement.seller, 2); coin::transfer<CoinType>(@escrow_address, agreement.seller, agreement.amount); } public fun refund<CoinType>(refunder: &signer) acquires EscrowAgreement { let sender = signer::address_of(refunder); let agreement = move_from<EscrowAgreement>(sender); assert!(!agreement.completed, 1); assert!(sender == agreement.seller, 2); coin::transfer<CoinType>(@escrow_address, agreement.buyer, agreement.amount); } }",
        "vulnerabilities": [
            "No dispute resolution mechanism",
            "Lack of timelock for automatic refund",
            "No partial release of funds option"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use std::vector; use aptos_framework::coin; struct MultiSigWallet has key { owners: vector<address>, required_confirmations: u64 } struct Transaction has key { id: u64, to: address, amount: u64, confirmations: u64, executed: bool } public fun create_wallet(creator: &signer, owners: vector<address>, required_confirmations: u64) { assert!(vector::length(&owners) >= required_confirmations, 1); move_to(creator, MultiSigWallet { owners, required_confirmations }); } public fun submit_transaction<CoinType>(submitter: &signer, to: address, amount: u64) acquires MultiSigWallet { let wallet = borrow_global<MultiSigWallet>(@wallet_address); assert!(vector::contains(&wallet.owners, &signer::address_of(submitter)), 2); let tx_id = get_next_tx_id(); move_to(submitter, Transaction { id: tx_id, to, amount, confirmations: 1, executed: false }); } public fun confirm_transaction<CoinType>(confirmer: &signer, tx_id: u64) acquires MultiSigWallet, Transaction { let wallet = borrow_global<MultiSigWallet>(@wallet_address); let sender = signer::address_of(confirmer); assert!(vector::contains(&wallet.owners, &sender), 3); let tx = borrow_global_mut<Transaction>(@wallet_address); assert!(tx.id == tx_id, 4); assert!(!tx.executed, 5); tx.confirmations = tx.confirmations + 1; if (tx.confirmations >= wallet.required_confirmations) { coin::transfer<CoinType>(@wallet_address, tx.to, tx.amount); tx.executed = true; } } }",
        "vulnerabilities": [
            "No mechanism to remove or change owners",
            "Lack of transaction expiration",
            "Potential for transaction front-running"
        ]
    },
    {
        "code": "module LendingProtocol { use std::signer; use aptos_framework::coin; struct LendingPool<phantom AssetType> has key { total_deposited: u64, total_borrowed: u64, interest_rate: u64 } struct UserPosition<phantom AssetType> has key { deposited: u64, borrowed: u64, last_update: u64 } public fun deposit<AssetType>(depositor: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<AssetType>>(@pool_address); coin::transfer<AssetType>(depositor, @pool_address, amount); pool.total_deposited = pool.total_deposited + amount; let sender = signer::address_of(depositor); if (!exists<UserPosition<AssetType>>(sender)) { move_to(depositor, UserPosition<AssetType> { deposited: amount, borrowed: 0, last_update: aptos_framework::timestamp::now_seconds() }); } else { let position = borrow_global_mut<UserPosition<AssetType>>(sender); position.deposited = position.deposited + amount; position.last_update = aptos_framework::timestamp::now_seconds(); } } public fun borrow<AssetType>(borrower: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<AssetType>>(@pool_address); assert!(pool.total_deposited - pool.total_borrowed >= amount, 1); coin::transfer<AssetType>(@pool_address, signer::address_of(borrower), amount); pool.total_borrowed = pool.total_borrowed + amount; let position = borrow_global_mut<UserPosition<AssetType>>(signer::address_of(borrower)); position.borrowed = position.borrowed + amount; position.last_update = aptos_framework::timestamp::now_seconds(); } public fun repay<AssetType>(repayer: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<AssetType>>(@pool_address); coin::transfer<AssetType>(repayer, @pool_address, amount); pool.total_borrowed = pool.total_borrowed - amount; let position = borrow_global_mut<UserPosition<AssetType>>(signer::address_of(repayer)); position.borrowed = position.borrowed - amount; position.last_update = aptos_framework::timestamp::now_seconds(); } }",
        "vulnerabilities": [
            "No collateralization ratio enforcement",
            "Lack of liquidation mechanism",
            "Interest accrual not implemented"
        ]
    },
    {
        "code": "module SimpleStaking { use std::signer; struct StakeInfo has key { amount: u64, last_claim_time: u64 } public fun stake(account: &signer, amount: u64) { if (!exists<StakeInfo>(signer::address_of(account))) { move_to(account, StakeInfo { amount: 0, last_claim_time: aptos_framework::timestamp::now_seconds() }); } let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); stake_info.amount = stake_info.amount + amount; } public fun unstake(account: &signer, amount: u64) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); assert!(stake_info.amount >= amount, 101); stake_info.amount = stake_info.amount - amount; } public fun claim_rewards(account: &signer) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); let current_time = aptos_framework::timestamp::now_seconds(); let time_elapsed = current_time - stake_info.last_claim_time; let reward = (stake_info.amount * time_elapsed) / 100; // 1% per second for simplicity stake_info.last_claim_time = current_time; // Transfer reward to account (not implemented) } }",
        "vulnerabilities": [
            "Unrealistic reward calculation",
            "No actual token transfer implementation",
            "Potential for timestamp manipulation",
            "Lack of events for staking, unstaking, and reward claims",
            "Missing access control for initialization"
        ]
    },
    {
        "code": "module DecentralizedIdentity { use std::signer; use std::vector; struct Identity has key { did: vector<u8>, attributes: vector<Attribute>, verifications: vector<Verification>, reputation_score: u64, } struct Attribute has store { name: vector<u8>, value: vector<u8>, } struct Verification has store { attribute_index: u64, verifier: address, timestamp: u64, } public fun create_identity(account: &signer, did: vector<u8>) { let sender = signer::address_of(account); assert!(!exists<Identity>(sender), 1); move_to(account, Identity { did, attributes: vector::empty(), verifications: vector::empty(), reputation_score: 0, }); } public fun add_attribute(account: &signer, name: vector<u8>, value: vector<u8>) acquires Identity { let sender = signer::address_of(account); let identity = borrow_global_mut<Identity>(sender); let attribute = Attribute { name, value }; vector::push_back(&mut identity.attributes, attribute); } public fun verify_attribute(verifier: &signer, identity_address: address, attribute_index: u64) acquires Identity { let sender = signer::address_of(verifier); let identity = borrow_global_mut<Identity>(identity_address); assert!(attribute_index < vector::length(&identity.attributes), 2); let verification = Verification { attribute_index, verifier: sender, timestamp: timestamp::now_seconds(), }; vector::push_back(&mut identity.verifications, verification); } public fun update_reputation(updater: &signer, identity_address: address, score_change: i64) acquires Identity { let sender = signer::address_of(updater); // Assume updater has authority to change reputation scores assert!(sender == @0x1, 3); let identity = borrow_global_mut<Identity>(identity_address); if (score_change > 0) { identity.reputation_score = identity.reputation_score + (score_change as u64); } else { let abs_change = if (score_change < 0) { 0 - score_change } else { score_change }; identity.reputation_score = if (identity.reputation_score > (abs_change as u64)) { identity.reputation_score - (abs_change as u64) } else { 0 }; } } public fun get_reputation(identity_address: address): u64 acquires Identity { borrow_global<Identity>(identity_address).reputation_score } }",
        "vulnerabilities": [
            "Centralized reputation score updates",
            "No mechanism for revoking verifications",
            "Lack of privacy considerations for sensitive attributes"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use std::vector; struct NFT has key, store { id: u64, creator: address, metadata: vector<u8>, } struct Listing has key { nft_id: u64, price: u64, } struct Marketplace has key { nfts: vector<NFT>, listings: vector<Listing>, next_id: u64, } public fun initialize_marketplace(creator: &signer) { move_to(creator, Marketplace { nfts: vector::empty(), listings: vector::empty(), next_id: 0, }); } public fun mint_nft(creator: &signer, metadata: vector<u8>) acquires Marketplace { let sender = signer::address_of(creator); let marketplace = borrow_global_mut<Marketplace>(@0x1); let nft = NFT { id: marketplace.next_id, creator: sender, metadata }; vector::push_back(&mut marketplace.nfts, nft); marketplace.next_id = marketplace.next_id + 1; } public fun list_nft(seller: &signer, nft_id: u64, price: u64) acquires Marketplace { let sender = signer::address_of(seller); let marketplace = borrow_global_mut<Marketplace>(@0x1); let (found, index) = vector::index_of(&marketplace.nfts, &nft_id); assert!(found, 1); assert!(marketplace.nfts[index].creator == sender, 2); let listing = Listing { nft_id, price }; vector::push_back(&mut marketplace.listings, listing); } public fun buy_nft(buyer: &signer, listing_index: u64) acquires Marketplace { let sender = signer::address_of(buyer); let marketplace = borrow_global_mut<Marketplace>(@0x1); let listing = vector::remove(&mut marketplace.listings, listing_index); let (found, index) = vector::index_of(&marketplace.nfts, &listing.nft_id); assert!(found, 3); let nft = vector::remove(&mut marketplace.nfts, index); // Transfer funds and NFT ownership (simplified) move_to(buyer, nft); } }",
        "vulnerabilities": [
            "No royalty mechanism for creators",
            "Lack of access control for marketplace initialization",
            "No mechanism to cancel listings"
        ]
    },
    {
        "code": "module SimpleSwap { use std::signer; struct LiquidityPool<phantom CoinTypeA, phantom CoinTypeB> has key { reserve_a: u64, reserve_b: u64 } public fun initialize<CoinTypeA, CoinTypeB>(account: &signer) { move_to(account, LiquidityPool<CoinTypeA, CoinTypeB> { reserve_a: 0, reserve_b: 0 }); } public fun add_liquidity<CoinTypeA, CoinTypeB>(account: &signer, amount_a: u64, amount_b: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(@0x1); pool.reserve_a = pool.reserve_a + amount_a; pool.reserve_b = pool.reserve_b + amount_b; } public fun swap<CoinTypeA, CoinTypeB>(account: &signer, amount_in: u64, is_a_to_b: bool) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(@0x1); if (is_a_to_b) { let amount_out = (amount_in * pool.reserve_b) / (pool.reserve_a + amount_in); pool.reserve_a = pool.reserve_a + amount_in; pool.reserve_b = pool.reserve_b - amount_out; } else { let amount_out = (amount_in * pool.reserve_a) / (pool.reserve_b + amount_in); pool.reserve_b = pool.reserve_b + amount_in; pool.reserve_a = pool.reserve_a - amount_out; } } }",
        "vulnerabilities": [
            "No slippage protection",
            "Lack of access control for initialization",
            "Missing events for liquidity changes and swaps",
            "No mechanism to remove liquidity",
            "Potential for price manipulation with large swaps"
        ]
    },
    {
        "code": "module SimpleNFT { use std::string::String; use aptos_framework::table; struct NFT has key, store { id: u64, name: String, metadata: String } struct NFTCollection has key { nfts: table::Table<u64, NFT>, next_token_id: u64 } public fun initialize_collection(account: &signer) { move_to(account, NFTCollection { nfts: table::new(), next_token_id: 0 }); } public fun mint_nft(creator: &signer, name: String, metadata: String) acquires NFTCollection { let collection = borrow_global_mut<NFTCollection>(signer::address_of(creator)); let token_id = collection.next_token_id; let nft = NFT { id: token_id, name, metadata }; table::add(&mut collection.nfts, token_id, nft); collection.next_token_id = token_id + 1; } public fun transfer_nft(from: &signer, to: address, token_id: u64) acquires NFTCollection { let collection = borrow_global_mut<NFTCollection>(signer::address_of(from)); let nft = table::remove(&mut collection.nfts, token_id); move_to(&signer::create_signer(to), nft); } }",
        "vulnerabilities": [
            "Lack of access control for minting",
            "No royalty mechanism for creators",
            "Missing events for minting and transfers",
            "Centralized collection ownership",
            "No mechanism to update NFT metadata"
        ]
    },
    {
        "code": "module SimpleSwap { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom CoinTypeA, phantom CoinTypeB> has key { reserve_a: u64, reserve_b: u64, } const E_INSUFFICIENT_LIQUIDITY: u64 = 1; const E_INSUFFICIENT_INPUT_AMOUNT: u64 = 2; const E_INSUFFICIENT_OUTPUT_AMOUNT: u64 = 3; public fun initialize<CoinTypeA, CoinTypeB>(account: &signer) { move_to(account, LiquidityPool<CoinTypeA, CoinTypeB> { reserve_a: 0, reserve_b: 0, }); } public fun add_liquidity<CoinTypeA, CoinTypeB>(account: &signer, amount_a: u64, amount_b: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(@pool_address); pool.reserve_a = pool.reserve_a + amount_a; pool.reserve_b = pool.reserve_b + amount_b; coin::transfer<CoinTypeA>(account, @pool_address, amount_a); coin::transfer<CoinTypeB>(account, @pool_address, amount_b); } public fun swap_a_to_b<CoinTypeA, CoinTypeB>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(@pool_address); let amount_out = (amount_in * pool.reserve_b) / (pool.reserve_a + amount_in); assert!(amount_out >= min_amount_out, E_INSUFFICIENT_OUTPUT_AMOUNT); pool.reserve_a = pool.reserve_a + amount_in; pool.reserve_b = pool.reserve_b - amount_out; coin::transfer<CoinTypeA>(account, @pool_address, amount_in); coin::transfer<CoinTypeB>(@pool_address, signer::address_of(account), amount_out); } public fun swap_b_to_a<CoinTypeA, CoinTypeB>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(@pool_address); let amount_out = (amount_in * pool.reserve_a) / (pool.reserve_b + amount_in); assert!(amount_out >= min_amount_out, E_INSUFFICIENT_OUTPUT_AMOUNT); pool.reserve_b = pool.reserve_b + amount_in; pool.reserve_a = pool.reserve_a - amount_out; coin::transfer<CoinTypeB>(account, @pool_address, amount_in); coin::transfer<CoinTypeA>(@pool_address, signer::address_of(account), amount_out); } }",
        "vulnerabilities": [
            "Lack of access control for initialize function",
            "No mechanism to remove liquidity",
            "Missing event emissions for swaps and liquidity changes",
            "Potential for price manipulation with large swaps",
            "No protection against flash loan attacks",
            "Centralized control of the swap contract",
            "Lack of fees for liquidity providers",
            "No checks for contract balance before transfers",
            "Potential integer overflow in swap calculations",
            "Missing checks for zero liquidity in swaps"
        ]
    },
    {
        "code": "module LendingPlatform { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct LendingPool<phantom CoinType> has key { available_funds: coin::Coin<CoinType>, total_borrowed: u64, interest_rate: u64, } struct Loan<phantom CoinType> has key { amount: u64, interest: u64, due_date: u64, } public fun create_pool<CoinType>(creator: &signer, initial_funds: coin::Coin<CoinType>, interest_rate: u64) { move_to(creator, LendingPool<CoinType> { available_funds: initial_funds, total_borrowed: 0, interest_rate }); } public fun borrow<CoinType>(borrower: &signer, amount: u64, duration: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_address); assert!(coin::value(&pool.available_funds) >= amount, 1); let borrowed_coin = coin::extract(&mut pool.available_funds, amount); coin::deposit(signer::address_of(borrower), borrowed_coin); pool.total_borrowed = pool.total_borrowed + amount; let interest = (amount * pool.interest_rate * duration) / (365 * 100); let due_date = timestamp::now_seconds() + duration * 86400; move_to(borrower, Loan<CoinType> { amount, interest, due_date }); } public fun repay<CoinType>(borrower: &signer) acquires Loan, LendingPool { let loan = move_from<Loan<CoinType>>(signer::address_of(borrower)); let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_address); let repay_amount = coin::withdraw<CoinType>(borrower, loan.amount + loan.interest); coin::merge(&mut pool.available_funds, repay_amount); pool.total_borrowed = pool.total_borrowed - loan.amount; } }",
        "vulnerabilities": [
            "No collateral mechanism",
            "Interest calculation doesn't account for partial repayments",
            "Lack of liquidation process for defaulted loans"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Market<phantom CoinType> has key { id: u64, question: vector<u8>, yes_pool: coin::Coin<CoinType>, no_pool: coin::Coin<CoinType>, resolution_time: u64, resolved: bool, outcome: bool, } struct Prediction<phantom CoinType> has key { market_id: u64, amount: u64, prediction: bool, } public fun create_market<CoinType>(creator: &signer, id: u64, question: vector<u8>, resolution_time: u64) { move_to(creator, Market<CoinType> { id, question, yes_pool: coin::zero<CoinType>(), no_pool: coin::zero<CoinType>(), resolution_time, resolved: false, outcome: false }); } public fun predict<CoinType>(predictor: &signer, market_id: u64, amount: u64, prediction: bool) acquires Market { let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(!market.resolved && timestamp::now_seconds() < market.resolution_time, 1); let prediction_coin = coin::withdraw<CoinType>(predictor, amount); if (prediction) { coin::merge(&mut market.yes_pool, prediction_coin); } else { coin::merge(&mut market.no_pool, prediction_coin); } move_to(predictor, Prediction<CoinType> { market_id, amount, prediction }); } public fun resolve_market<CoinType>(resolver: &signer, market_id: u64, outcome: bool) acquires Market { let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(signer::address_of(resolver) == @market_resolver && timestamp::now_seconds() >= market.resolution_time, 2); market.resolved = true; market.outcome = outcome; } public fun claim_winnings<CoinType>(predictor: &signer, market_id: u64) acquires Market, Prediction { let prediction = move_from<Prediction<CoinType>>(signer::address_of(predictor)); let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(market.resolved && prediction.market_id == market_id, 3); if (prediction.prediction == market.outcome) { let total_pool = coin::value(&market.yes_pool) + coin::value(&market.no_pool); let winning_pool = if (market.outcome) { &mut market.yes_pool } else { &mut market.no_pool }; let winnings = (prediction.amount * total_pool) / coin::value(winning_pool); let payout = coin::extract(winning_pool, winnings); coin::deposit(signer::address_of(predictor), payout); } } }",
        "vulnerabilities": [
            "Central resolver for market outcomes",
            "No mechanism to handle disputes on market resolutions",
            "Potential for market manipulation with large stakes"
        ]
    },
    {
        "code": "module TimeLockedWallet { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct LockedFunds<phantom CoinType> has key { amount: u64, unlock_time: u64 } public fun lock_funds<CoinType>(account: &signer, amount: u64, lock_duration: u64) { let sender = signer::address_of(account); assert!(!exists<LockedFunds<CoinType>>(sender), 1); let unlock_time = timestamp::now_seconds() + lock_duration; move_to(account, LockedFunds<CoinType> { amount, unlock_time }); coin::transfer<CoinType>(account, @time_locked_wallet, amount); } public fun withdraw<CoinType>(account: &signer) acquires LockedFunds { let sender = signer::address_of(account); let LockedFunds { amount, unlock_time } = move_from<LockedFunds<CoinType>>(sender); assert!(timestamp::now_seconds() >= unlock_time, 2); coin::transfer<CoinType>(@time_locked_wallet, sender, amount); } }",
        "vulnerabilities": [
            "No partial withdrawal mechanism",
            "Lack of emergency withdrawal function",
            "No ability to extend lock duration",
            "Potential for lost funds if contract is not properly maintained",
            "No event emissions for important actions",
            "Centralized control of the locked funds",
            "No mechanism to cancel a lock before the unlock time",
            "Lack of access control for the withdraw function",
            "No support for multiple locks per user",
            "Potential for timestamp manipulation in a blockchain environment"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use aptos_framework::coin; struct MultiSigAccount has key { owners: vector<address>, required_confirmations: u64, } struct Transaction has key { to: address, amount: u64, confirmations: u64, executed: bool, } public fun create_wallet(account: &signer, owners: vector<address>, required_confirmations: u64) { let sender = signer::address_of(account); assert!(!exists<MultiSigAccount>(sender), 1); move_to(account, MultiSigAccount { owners, required_confirmations }); } public fun submit_transaction<CoinType>(account: &signer, to: address, amount: u64) acquires MultiSigAccount { let sender = signer::address_of(account); let multi_sig = borrow_global<MultiSigAccount>(sender); assert!(vector::contains(&multi_sig.owners, &sender), 2); let tx_id = get_next_tx_id(); move_to(account, Transaction { to, amount, confirmations: 1, executed: false }); } public fun confirm_transaction<CoinType>(account: &signer, tx_id: u64) acquires MultiSigAccount, Transaction { let sender = signer::address_of(account); let multi_sig = borrow_global<MultiSigAccount>(@multi_sig_wallet); let tx = borrow_global_mut<Transaction>(@multi_sig_wallet); assert!(vector::contains(&multi_sig.owners, &sender), 3); assert!(!tx.executed, 4); tx.confirmations = tx.confirmations + 1; if (tx.confirmations >= multi_sig.required_confirmations) { tx.executed = true; coin::transfer<CoinType>(@multi_sig_wallet, tx.to, tx.amount); } } fun get_next_tx_id(): u64 { // Implementation omitted 0 } }",
        "vulnerabilities": [
            "Lack of mechanism to remove or change owners",
            "No way to cancel a submitted transaction",
            "Potential for transaction ordering manipulation",
            "Absence of time limit for transaction execution",
            "No support for custom transaction data beyond simple transfers",
            "Lack of event emissions for important actions",
            "No mechanism to change required confirmations after creation",
            "Potential for lost funds if all owners lose access",
            "No support for batched transactions",
            "Absence of role-based permissions within owners"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; struct Market<phantom CoinType> has key { question: vector<u8>, end_time: u64, total_yes_bets: u64, total_no_bets: u64, outcome: bool, resolved: bool, } struct UserBet<phantom CoinType> has key { yes_amount: u64, no_amount: u64, } public fun create_market<CoinType>(account: &signer, question: vector<u8>, duration: u64) { let sender = signer::address_of(account); assert!(!exists<Market<CoinType>>(sender), 1); move_to(account, Market<CoinType> { question, end_time: aptos_framework::timestamp::now_seconds() + duration, total_yes_bets: 0, total_no_bets: 0, outcome: false, resolved: false, }); } public fun place_bet<CoinType>(account: &signer, market_address: address, amount: u64, bet_yes: bool) acquires Market, UserBet { let sender = signer::address_of(account); let market = borrow_global_mut<Market<CoinType>>(market_address); assert!(!market.resolved, 2); if (!exists<UserBet<CoinType>>(sender)) { move_to(account, UserBet<CoinType> { yes_amount: 0, no_amount: 0 }); } let user_bet = borrow_global_mut<UserBet<CoinType>>(sender); if (bet_yes) { market.total_yes_bets = market.total_yes_bets + amount; user_bet.yes_amount = user_bet.yes_amount + amount; } else { market.total_no_bets = market.total_no_bets + amount; user_bet.no_amount = user_bet.no_amount + amount; } coin::transfer<CoinType>(account, market_address, amount); } public fun resolve_market<CoinType>(account: &signer, outcome: bool) acquires Market { let sender = signer::address_of(account); let market = borrow_global_mut<Market<CoinType>>(sender); assert!(!market.resolved, 3); assert!(aptos_framework::timestamp::now_seconds() > market.end_time, 4); market.outcome = outcome; market.resolved = true; } public fun claim_winnings<CoinType>(account: &signer, market_address: address) acquires Market, UserBet { let sender = signer::address_of(account); let market = borrow_global<Market<CoinType>>(market_address); assert!(market.resolved, 5); let user_bet = borrow_global_mut<UserBet<CoinType>>(sender); let winnings = if (market.outcome) { user_bet.yes_amount * (market.total_yes_bets + market.total_no_bets) / market.total_yes_bets } else { user_bet.no_amount * (market.total_yes_bets + market.total_no_bets) / market.total_no_bets }; user_bet.yes_amount = 0; user_bet.no_amount = 0; coin::transfer<CoinType>(market_address, sender, winnings); } }",
        "vulnerabilities": [
            "Centralized market resolution",
            "No mechanism for disputing the outcome",
            "Potential for front-running in bet placement",
            "Lack of oracle integration for automated resolution",
            "No partial withdrawal of bets",
            "Absence of market creation fee to prevent spam",
            "Potential for precision loss in winnings calculation",
            "No mechanism to cancel a market",
            "Lack of event emissions for important actions",
            "No support for multiple outcomes beyond binary yes/no"
        ]
    },
    {
        "code": "module SimpleNFT { use std::string; use std::signer; use aptos_framework::account; struct NFT has key { id: u64, name: string::String, } let next_token_id: u64 = 0; public fun mint(creator: &signer, name: string::String) { let token = NFT { id: next_token_id, name }; move_to(creator, token); next_token_id = next_token_id + 1; } public fun transfer(from: &signer, to: address, id: u64) acquires NFT { let nft = move_from<NFT>(signer::address_of(from)); assert!(nft.id == id, 1); move_to<NFT>(account::create_signer_with_capability(&account::create_test_signer_cap(to)), nft); } }",
        "vulnerabilities": [
            "No access control for minting",
            "Global counter for token IDs can be manipulated",
            "No checks for duplicate token names"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; struct Auction has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64, } public fun create_auction(creator: &signer, end_time: u64) { move_to(creator, Auction { seller: signer::address_of(creator), highest_bidder: @0x0, highest_bid: 0, end_time }); } public fun bid(bidder: &signer, amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@0x1); assert!(aptos_framework::timestamp::now_seconds() < auction.end_time, 1); assert!(amount > auction.highest_bid, 2); auction.highest_bidder = signer::address_of(bidder); auction.highest_bid = amount; } public fun end_auction(seller: &signer) acquires Auction { let auction = move_from<Auction>(signer::address_of(seller)); assert!(aptos_framework::timestamp::now_seconds() >= auction.end_time, 3); // Transfer funds to seller and item to highest bidder (simplified) } }",
        "vulnerabilities": [
            "No mechanism to return funds to outbid participants",
            "Lack of checks for auction cancellation",
            "Centralized control of auction end time"
        ]
    },
    {
        "code": "module SimpleVoting { use std::signer; use std::vector; struct Proposal has key { creator: address, yes_votes: u64, no_votes: u64, voters: vector<address>, } public fun create_proposal(creator: &signer) { move_to(creator, Proposal { creator: signer::address_of(creator), yes_votes: 0, no_votes: 0, voters: vector::empty() }); } public fun vote(voter: &signer, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@0x1); let voter_address = signer::address_of(voter); assert!(!vector::contains(&proposal.voters, &voter_address), 1); vector::push_back(&mut proposal.voters, voter_address); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } } }",
        "vulnerabilities": [
            "No mechanism to end voting or execute proposal",
            "Single proposal limitation",
            "Lack of access control for proposal creation"
        ]
    },
    {
        "code": "module TokenSwap { use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: coin::Coin<X>, reserve_y: coin::Coin<Y> } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@owner); let coin_in = coin::withdraw<X>(account, amount_in); let amount_out = calculate_output(coin::value(&coin_in), coin::value(&pool.reserve_x), coin::value(&pool.reserve_y)); assert!(amount_out >= min_amount_out, 1); coin::deposit(signer::address_of(account), coin::extract(&mut pool.reserve_y, amount_out)); coin::merge(&mut pool.reserve_x, coin_in); } }",
        "vulnerabilities": [
            "No slippage protection",
            "Centralized ownership of liquidity pool",
            "Lack of access control for critical functions"
        ]
    },
    {
        "code": "module Governance { use std::vector; struct Proposal has key { id: u64, description: vector<u8>, votes_for: u64, votes_against: u64, status: u8 } public fun create_proposal(creator: &signer, description: vector<u8>) { let proposal = Proposal { id: get_next_id(), description, votes_for: 0, votes_against: 0, status: 0 }; move_to(creator, proposal); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@governance_address); if (vote) { proposal.votes_for = proposal.votes_for + 1; } else { proposal.votes_against = proposal.votes_against + 1; } } }",
        "vulnerabilities": [
            "No checks for duplicate votes",
            "Lack of time-bound voting periods",
            "No quorum requirements for proposal execution"
        ]
    },
    {
        "code": "module StakingRewards { use aptos_framework::coin; struct StakeInfo has key { amount: u64, last_claim_time: u64 } public fun stake(account: &signer, amount: u64) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); stake_info.amount = stake_info.amount + amount; stake_info.last_claim_time = timestamp::now_seconds(); } public fun claim_rewards(account: &signer) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); let rewards = calculate_rewards(stake_info.amount, stake_info.last_claim_time); coin::deposit(signer::address_of(account), coin::mint<RewardCoin>(rewards)); stake_info.last_claim_time = timestamp::now_seconds(); } }",
        "vulnerabilities": [
            "Unbounded reward minting",
            "No checks for sufficient reward pool balance",
            "Potential for reward calculation overflow"
        ]
    },
    {
        "code": "module SimpleDAO { use std::vector; struct Proposal has key { id: u64, description: vector<u8>, votes: u64 } struct Member has key { voting_power: u64 } public fun create_proposal(creator: &signer, description: vector<u8>) { let proposal = Proposal { id: get_next_proposal_id(), description, votes: 0 }; move_to(creator, proposal); } public fun vote(voter: &signer, proposal_id: u64) acquires Proposal, Member { let member = borrow_global<Member>(signer::address_of(voter)); let proposal = borrow_global_mut<Proposal>(@dao_address); proposal.votes = proposal.votes + member.voting_power; } }",
        "vulnerabilities": [
            "No checks for duplicate votes",
            "Lack of proposal execution mechanism",
            "No time limit for voting"
        ]
    },
    {
        "code": "module NFTMarketplace { use aptos_framework::coin; struct Listing has key { token_id: u64, price: u64, seller: address } public fun list_nft(seller: &signer, token_id: u64, price: u64) { let listing = Listing { token_id, price, seller: signer::address_of(seller) }; move_to(seller, listing); } public fun buy_nft(buyer: &signer, token_id: u64) acquires Listing { let listing = move_from<Listing>(@marketplace_address); assert!(coin::balance<AptosCoin>(signer::address_of(buyer)) >= listing.price, 1); coin::transfer<AptosCoin>(buyer, listing.seller, listing.price); // Transfer NFT logic here } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow for secure transactions",
            "No checks for NFT ownership before listing"
        ]
    },
    {
        "code": "module TimelockWallet { use aptos_framework::coin; struct TimeLock has key { release_time: u64, amount: u64 } public fun create_timelock(owner: &signer, amount: u64, release_time: u64) { let timelock = TimeLock { release_time, amount }; move_to(owner, timelock); } public fun withdraw(owner: &signer) acquires TimeLock { let timelock = move_from<TimeLock>(signer::address_of(owner)); assert!(timestamp::now_seconds() >= timelock.release_time, 1); coin::deposit(signer::address_of(owner), coin::mint<AptosCoin>(timelock.amount)); } }",
        "vulnerabilities": [
            "No partial withdrawal mechanism",
            "Lack of emergency withdrawal function",
            "Potential for permanently locked funds if release time is set incorrectly"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::vector; struct MultiSig has key { owners: vector<address>, required_confirmations: u64 } struct Transaction has key { to: address, amount: u64, confirmations: u64 } public fun create_multisig(creator: &signer, owners: vector<address>, required_confirmations: u64) { let multisig = MultiSig { owners, required_confirmations }; move_to(creator, multisig); } public fun submit_transaction(submitter: &signer, to: address, amount: u64) acquires MultiSig { let multisig = borrow_global<MultiSig>(@multisig_address); assert!(vector::contains(&multisig.owners, &signer::address_of(submitter)), 1); let transaction = Transaction { to, amount, confirmations: 1 }; move_to(submitter, transaction); } }",
        "vulnerabilities": [
            "No mechanism to change owners or required confirmations",
            "Lack of transaction execution logic",
            "No checks for duplicate confirmations"
        ]
    },
    {
        "code": "module FlashLoan { use aptos_framework::coin; struct LoanPool has key { balance: coin::Coin<AptosCoin> } public fun flash_loan(borrower: &signer, amount: u64) acquires LoanPool { let pool = borrow_global_mut<LoanPool>(@pool_address); let loan = coin::extract(&mut pool.balance, amount); coin::deposit(signer::address_of(borrower), loan); // Callback to borrower's contract assert!(coin::balance<AptosCoin>(signer::address_of(borrower)) >= amount, 1); let repayment = coin::withdraw<AptosCoin>(borrower, amount); coin::merge(&mut pool.balance, repayment); } }",
        "vulnerabilities": [
            "No fee mechanism for flash loans",
            "Lack of access control for borrowing",
            "Potential for reentrancy attacks"
        ]
    },
    {
        "code": "module SimpleAuction { use aptos_framework::coin; struct Auction has key { highest_bidder: address, highest_bid: u64, end_time: u64 } public fun create_auction(creator: &signer, end_time: u64) { let auction = Auction { highest_bidder: @zero_address, highest_bid: 0, end_time }; move_to(creator, auction); } public fun place_bid(bidder: &signer, bid_amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@auction_address); assert!(timestamp::now_seconds() < auction.end_time, 1); assert!(bid_amount > auction.highest_bid, 2); if (auction.highest_bidder != @zero_address) { coin::transfer<AptosCoin>(bidder, auction.highest_bidder, auction.highest_bid); } auction.highest_bidder = signer::address_of(bidder); auction.highest_bid = bid_amount; } }",
        "vulnerabilities": [
            "No mechanism to extend auction time on last-minute bids",
            "Lack of withdrawal function for non-winning bids",
            "Potential for auction creator to bid on their own auction"
        ]
    },
    {
        "code": "module TokenVesting { use aptos_framework::coin; struct VestingSchedule has key { beneficiary: address, total_amount: u64, released_amount: u64, start_time: u64, duration: u64 } public fun create_vesting(creator: &signer, beneficiary: address, total_amount: u64, start_time: u64, duration: u64) { let schedule = VestingSchedule { beneficiary, total_amount, released_amount: 0, start_time, duration }; move_to(creator, schedule); } public fun release() acquires VestingSchedule { let schedule = borrow_global_mut<VestingSchedule>(@vesting_address); let vested_amount = calculate_vested_amount(schedule); let to_release = vested_amount - schedule.released_amount; coin::transfer<AptosCoin>(@vesting_address, schedule.beneficiary, to_release); schedule.released_amount = vested_amount; } }",
        "vulnerabilities": [
            "No mechanism to handle token price fluctuations",
            "Lack of revocation mechanism for the vesting creator",
            "Potential for calculation errors in vested amount due to integer division"
        ]
    },
    {
        "code": "module SimpleDEX { use std::signer; struct LiquidityPool has key { token_a_reserve: u64, token_b_reserve: u64, } public fun initialize_pool(creator: &signer) { move_to(creator, LiquidityPool { token_a_reserve: 0, token_b_reserve: 0 }); } public fun add_liquidity(provider: &signer, amount_a: u64, amount_b: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@0x1); pool.token_a_reserve = pool.token_a_reserve + amount_a; pool.token_b_reserve = pool.token_b_reserve + amount_b; } public fun swap(trader: &signer, amount_in: u64, is_a_to_b: bool) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@0x1); let (in_reserve, out_reserve) = if (is_a_to_b) (pool.token_a_reserve, pool.token_b_reserve) else (pool.token_b_reserve, pool.token_a_reserve); let amount_out = (amount_in * out_reserve) / (in_reserve + amount_in); if (is_a_to_b) { pool.token_a_reserve = pool.token_a_reserve + amount_in; pool.token_b_reserve = pool.token_b_reserve - amount_out; } else { pool.token_b_reserve = pool.token_b_reserve + amount_in; pool.token_a_reserve = pool.token_a_reserve - amount_out; } // Transfer tokens (simplified) } }",
        "vulnerabilities": [
            "No slippage protection",
            "Vulnerability to flash loan attacks",
            "Lack of fee mechanism for liquidity providers"
        ]
    },
    {
        "code": "module SimpleStaking { use std::signer; struct StakingPool has key { total_staked: u64, rewards_per_token: u64, } struct UserStake has key { amount: u64, rewards_paid: u64, } public fun initialize_pool(creator: &signer) { move_to(creator, StakingPool { total_staked: 0, rewards_per_token: 0 }); } public fun stake(staker: &signer, amount: u64) acquires StakingPool, UserStake { let pool = borrow_global_mut<StakingPool>(@0x1); pool.total_staked = pool.total_staked + amount; if (!exists<UserStake>(signer::address_of(staker))) { move_to(staker, UserStake { amount: 0, rewards_paid: 0 }); } let user_stake = borrow_global_mut<UserStake>(signer::address_of(staker)); user_stake.amount = user_stake.amount + amount; } public fun claim_rewards(staker: &signer) acquires StakingPool, UserStake { let pool = borrow_global<StakingPool>(@0x1); let user_stake = borrow_global_mut<UserStake>(signer::address_of(staker)); let rewards = (user_stake.amount * pool.rewards_per_token) - user_stake.rewards_paid; user_stake.rewards_paid = user_stake.amount * pool.rewards_per_token; // Transfer rewards (simplified) } }",
        "vulnerabilities": [
            "No mechanism to distribute rewards",
            "Lack of time-based reward calculation",
            "No unstaking functionality"
        ]
    },
    {
        "code": "module SimpleMultiSig { use std::vector; struct MultiSigWallet has key { owners: vector<address>, required_confirmations: u64, transaction_count: u64 } struct Transaction has store { to: address, value: u64, data: vector<u8>, executed: bool, confirmations: u64 } public fun create_wallet(account: &signer, owners: vector<address>, required_confirmations: u64) { assert!(vector::length(&owners) >= required_confirmations, 101); move_to(account, MultiSigWallet { owners, required_confirmations, transaction_count: 0 }); } public fun submit_transaction(account: &signer, to: address, value: u64, data: vector<u8>) acquires MultiSigWallet { let wallet = borrow_global_mut<MultiSigWallet>(@0x1); assert!(vector::contains(&wallet.owners, &signer::address_of(account)), 102); let transaction = Transaction { to, value, data, executed: false, confirmations: 0 }; // Store transaction (not implemented) wallet.transaction_count = wallet.transaction_count + 1; } public fun confirm_transaction(account: &signer, transaction_id: u64) acquires MultiSigWallet { let wallet = borrow_global_mut<MultiSigWallet>(@0x1); assert!(vector::contains(&wallet.owners, &signer::address_of(account)), 102); // Implement confirmation logic } public fun execute_transaction(account: &signer, transaction_id: u64) acquires MultiSigWallet { let wallet = borrow_global_mut<MultiSigWallet>(@0x1); // Implement execution logic } }",
        "vulnerabilities": [
            "Incomplete implementation of transaction storage and management",
            "Lack of access control for wallet creation",
            "Missing events for transaction submission, confirmation, and execution",
            "No mechanism to change owners or required confirmations",
            "Potential for transaction front-running"
        ]
    },
    {
        "code": "module SimpleGovernance { use std::signer; use aptos_framework::table; struct Proposal has key { description: vector<u8>, vote_count: u64, executed: bool, execution_time: u64 } struct GovernanceModule has key { proposals: table::Table<u64, Proposal>, voting_period: u64, execution_delay: u64, proposal_count: u64 } public fun initialize(admin: &signer, voting_period: u64, execution_delay: u64) { move_to(admin, GovernanceModule { proposals: table::new(), voting_period, execution_delay, proposal_count: 0 }); } public fun create_proposal(proposer: &signer, description: vector<u8>) acquires GovernanceModule { let governance = borrow_global_mut<GovernanceModule>(@0x1); let proposal = Proposal { description, vote_count: 0, executed: false, execution_time: 0 }; table::add(&mut governance.proposals, governance.proposal_count, proposal); governance.proposal_count = governance.proposal_count + 1; } public fun vote(voter: &signer, proposal_id: u64) acquires GovernanceModule { let governance = borrow_global_mut<GovernanceModule>(@0x1); let proposal = table::borrow_mut(&mut governance.proposals, proposal_id); proposal.vote_count = proposal.vote_count + 1; } public fun queue_proposal(admin: &signer, proposal_id: u64) acquires GovernanceModule { let governance = borrow_global_mut<GovernanceModule>(@0x1); let proposal = table::borrow_mut(&mut governance.proposals, proposal_id); proposal.execution_time = aptos_framework::timestamp::now_seconds() + governance.execution_delay; } public fun execute_proposal(admin: &signer, proposal_id: u64) acquires GovernanceModule { let governance = borrow_global_mut<GovernanceModule>(@0x1); let proposal = table::borrow_mut(&mut governance.proposals, proposal_id); assert!(aptos_framework::timestamp::now_seconds() >= proposal.execution_time, 101); assert!(!proposal.executed, 102); // Execute proposal (not implemented) proposal.executed = true; } }",
        "vulnerabilities": [
            "Lack of access control for proposal creation and voting",
            "Missing vote weight consideration",
            "No mechanism to cancel or update proposals",
            "Potential for timestamp manipulation",
            "Incomplete implementation of proposal execution"
        ]
    },
    {
        "code": "module SimpleGovernance { use std::signer; use std::vector; struct Proposal has key { proposer: address, votes: u64, executed: bool, action: vector<u8>, } public fun create_proposal(proposer: &signer, action: vector<u8>) { move_to(proposer, Proposal { proposer: signer::address_of(proposer), votes: 0, executed: false, action }); } public fun vote(voter: &signer) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@0x1); proposal.votes = proposal.votes + 1; } public fun execute_proposal() acquires Proposal { let proposal = borrow_global_mut<Proposal>(@0x1); assert!(!proposal.executed, 1); assert!(proposal.votes > 100, 2); // Arbitrary threshold // Execute action (simplified) proposal.executed = true; } }",
        "vulnerabilities": [
            "No way to vote against proposals",
            "Lack of time-based voting periods",
            "No access control for proposal creation and execution"
        ]
    },
    {
        "code": "module SimpleLottery { use std::signer; use std::vector; struct Lottery has key { participants: vector<address>, winner: address, } public fun create_lottery(creator: &signer) { move_to(creator, Lottery { participants: vector::empty(), winner: @0x0 }); } public fun enter_lottery(participant: &signer) acquires Lottery { let lottery = borrow_global_mut<Lottery>(@0x1); vector::push_back(&mut lottery.participants, signer::address_of(participant)); } public fun draw_winner() acquires Lottery { let lottery = borrow_global_mut<Lottery>(@0x1); let winner_index = aptos_framework::timestamp::now_microseconds() % vector::length(&lottery.participants); lottery.winner = *vector::borrow(&lottery.participants, winner_index); // Transfer prize to winner (simplified) } }",
        "vulnerabilities": [
            "Predictable randomness for winner selection",
            "No mechanism to prevent multiple entries",
            "Lack of time-based lottery rounds"
        ]
    },
    {
        "code": "module SimpleOracle { use std::signer; struct PriceData has key { price: u64, timestamp: u64, } public fun update_price(oracle: &signer, new_price: u64) acquires PriceData { let price_data = borrow_global_mut<PriceData>(signer::address_of(oracle)); price_data.price = new_price; price_data.timestamp = aptos_framework::timestamp::now_seconds(); } public fun get_price(): u64 acquires PriceData { borrow_global<PriceData>(@0x1).price } }",
        "vulnerabilities": [
            "Single point of failure with one oracle",
            "No checks for price manipulation",
            "Lack of delay mechanism for price updates"
        ]
    },
    {
        "code": "module SimpleMultisig { use std::signer; use std::vector; struct MultisigWallet has key { owners: vector<address>, required_confirmations: u64, } struct Transaction has key { to: address, amount: u64, confirmations: u64, executed: bool, } public fun create_wallet(creator: &signer, owners: vector<address>, required_confirmations: u64) { move_to(creator, MultisigWallet { owners, required_confirmations }); } public fun submit_transaction(submitter: &signer, to: address, amount: u64) acquires MultisigWallet { let wallet = borrow_global<MultisigWallet>(@0x1); assert!(vector::contains(&wallet.owners, &signer::address_of(submitter)), 1); move_to(submitter, Transaction { to, amount, confirmations: 0, executed: false }); } public fun confirm_transaction(confirmer: &signer) acquires MultisigWallet, Transaction { let wallet = borrow_global<MultisigWallet>(@0x1); let transaction = borrow_global_mut<Transaction>(@0x1); assert!(vector::contains(&wallet.owners, &signer::address_of(confirmer)), 2); transaction.confirmations = transaction.confirmations + 1; if (transaction.confirmations >= wallet.required_confirmations && !transaction.executed) { transaction.executed = true; // Execute transaction (simplified) } } }",
        "vulnerabilities": [
            "No mechanism to change owners or required confirmations",
            "Lack of transaction expiration",
            "Single transaction limitation"
        ]
    },
    {
        "code": "module TokenSwap { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: coin::Coin<X>, reserve_y: coin::Coin<Y>, lp_tokens: u64 } public fun create_pool<X, Y>(creator: &signer) { move_to(creator, LiquidityPool<X, Y> { reserve_x: coin::zero<X>(), reserve_y: coin::zero<Y>(), lp_tokens: 0 }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@0x1); let coin_x = coin::withdraw<X>(account, amount_x); let coin_y = coin::withdraw<Y>(account, amount_y); coin::merge(&mut pool.reserve_x, coin_x); coin::merge(&mut pool.reserve_y, coin_y); pool.lp_tokens = pool.lp_tokens + (amount_x * amount_y).sqrt(); } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@0x1); let coin_in = coin::withdraw<X>(account, amount_in); let reserve_in = coin::value(&pool.reserve_x); let reserve_out = coin::value(&pool.reserve_y); let amount_out = (amount_in * reserve_out) / (reserve_in + amount_in); assert!(amount_out >= min_amount_out, 101); coin::merge(&mut pool.reserve_x, coin_in); let coin_out = coin::extract(&mut pool.reserve_y, amount_out); coin::deposit(signer::address_of(account), coin_out); } }",
        "vulnerabilities": [
            "No slippage protection for liquidity providers",
            "Potential for front-running in swaps",
            "Lack of access control for pool creation",
            "No mechanism to remove liquidity",
            "Vulnerable to flash loan attacks"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::table; use aptos_framework::token; struct Listing has store { price: u64, seller: address } struct Marketplace has key { listings: table::Table<token::TokenId, Listing> } public fun initialize(creator: &signer) { move_to(creator, Marketplace { listings: table::new() }); } public fun list_nft(seller: &signer, token_id: token::TokenId, price: u64) acquires Marketplace { let marketplace = borrow_global_mut<Marketplace>(@0x1); let listing = Listing { price, seller: signer::address_of(seller) }; table::add(&mut marketplace.listings, token_id, listing); token::transfer(seller, @0x1, token_id); } public fun buy_nft(buyer: &signer, token_id: token::TokenId) acquires Marketplace { let marketplace = borrow_global_mut<Marketplace>(@0x1); let listing = table::remove(&mut marketplace.listings, token_id); coin::transfer<AptosCoin>(buyer, listing.seller, listing.price); token::transfer(@0x1, signer::address_of(buyer), token_id); } public fun cancel_listing(seller: &signer, token_id: token::TokenId) acquires Marketplace { let marketplace = borrow_global_mut<Marketplace>(@0x1); let listing = table::remove(&mut marketplace.listings, token_id); assert!(listing.seller == signer::address_of(seller), 101); token::transfer(@0x1, signer::address_of(seller), token_id); } }",
        "vulnerabilities": [
            "No royalty support for original creators",
            "Centralized control of the marketplace",
            "Lack of price validation",
            "No mechanism for updating listing prices",
            "Potential for reentrancy attacks in buy_nft function"
        ]
    },
    {
        "code": "module StakingRewards { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakeInfo has key { amount: u64, last_claim_time: u64 } struct RewardsPool has key { total_staked: u64, reward_per_second: u64 } public fun initialize(admin: &signer, reward_per_second: u64) { move_to(admin, RewardsPool { total_staked: 0, reward_per_second }); } public fun stake(staker: &signer, amount: u64) acquires RewardsPool, StakeInfo { let pool = borrow_global_mut<RewardsPool>(@0x1); pool.total_staked = pool.total_staked + amount; if (!exists<StakeInfo>(signer::address_of(staker))) { move_to(staker, StakeInfo { amount: 0, last_claim_time: timestamp::now_seconds() }); } let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(staker)); stake_info.amount = stake_info.amount + amount; coin::transfer<AptosCoin>(staker, @0x1, amount); } public fun claim_rewards(staker: &signer) acquires RewardsPool, StakeInfo { let pool = borrow_global<RewardsPool>(@0x1); let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(staker)); let current_time = timestamp::now_seconds(); let time_elapsed = current_time - stake_info.last_claim_time; let reward = (stake_info.amount * pool.reward_per_second * time_elapsed) / pool.total_staked; stake_info.last_claim_time = current_time; coin::mint<AptosCoin>(reward, staker); } public fun unstake(staker: &signer, amount: u64) acquires RewardsPool, StakeInfo { let pool = borrow_global_mut<RewardsPool>(@0x1); let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(staker)); assert!(stake_info.amount >= amount, 101); stake_info.amount = stake_info.amount - amount; pool.total_staked = pool.total_staked - amount; coin::transfer<AptosCoin>(@0x1, signer::address_of(staker), amount); } }",
        "vulnerabilities": [
            "Potential for reward calculation errors due to integer division",
            "No mechanism to update reward rate",
            "Lack of access control for initialization",
            "Vulnerable to sandwich attacks during unstaking",
            "No slashing mechanism for malicious actors"
        ]
    },
    {
        "code": "module SimpleFlashLoan { use std::signer; struct LendingPool has key { balance: u64, } public fun initialize_pool(creator: &signer) { move_to(creator, LendingPool { balance: 0 }); } public fun deposit(depositor: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool>(@0x1); pool.balance = pool.balance + amount; } public fun flash_loan(borrower: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool>(@0x1); assert!(amount <= pool.balance, 1); pool.balance = pool.balance - amount; // Transfer amount to borrower (simplified) // Assume some arbitrary actions by the borrower here // Repayment pool.balance = pool.balance + amount + (amount / 100); // 1% fee } }",
        "vulnerabilities": [
            "No checks for borrower's ability to repay",
            "Vulnerability to reentrancy attacks",
            "Lack of access control for flash loan initiation"
        ]
    },
    {
        "code": "module SimpleMultisig { use std::signer; use std::vector; struct MultisigWallet has key { owners: vector<address>, required_confirmations: u64, } struct Transaction has key { to: address, amount: u64, confirmations: u64, executed: bool, } public fun create_wallet(creator: &signer, owners: vector<address>, required_confirmations: u64) { move_to(creator, MultisigWallet { owners, required_confirmations }); } public fun submit_transaction(submitter: &signer, to: address, amount: u64) acquires MultisigWallet { let wallet = borrow_global<MultisigWallet>(@0x1); assert!(vector::contains(&wallet.owners, &signer::address_of(submitter)), 1); move_to(submitter, Transaction { to, amount, confirmations: 0, executed: false }); } public fun confirm_transaction(confirmer: &signer) acquires MultisigWallet, Transaction { let wallet = borrow_global<MultisigWallet>(@0x1); let transaction = borrow_global_mut<Transaction>(@0x1); assert!(vector::contains(&wallet.owners, &signer::address_of(confirmer)), 2); transaction.confirmations = transaction.confirmations + 1; if (transaction.confirmations >= wallet.required_confirmations && !transaction.executed) { transaction.executed = true; // Execute transaction (simplified) } } }",
        "vulnerabilities": [
            "No mechanism to change owners or required confirmations",
            "Lack of transaction expiration",
            "Single transaction limitation"
        ]
    },
    {
        "code": "module DynamicNFT { use std::signer; use aptos_framework::token; struct NFTData has key { level: u64, experience: u64, } public fun mint_nft(account: &signer, name: vector<u8>, description: vector<u8>, uri: vector<u8>) { let sender = signer::address_of(account); token::create_token_script(account, collection_name(), name, description, 1, 1, uri, sender, 100, 0, vector::empty(), vector::empty(), vector::empty()); move_to(account, NFTData { level: 1, experience: 0 }); } public fun gain_experience(account: &signer, amount: u64) acquires NFTData { let sender = signer::address_of(account); let nft_data = borrow_global_mut<NFTData>(sender); nft_data.experience = nft_data.experience + amount; if (nft_data.experience >= level_up_threshold(nft_data.level)) { nft_data.level = nft_data.level + 1; nft_data.experience = 0; update_nft_metadata(account); } } fun update_nft_metadata(account: &signer) acquires NFTData { let sender = signer::address_of(account); let nft_data = borrow_global<NFTData>(sender); let token_id = token::create_token_id_raw(sender, collection_name(), token::get_token_data_id_fields(sender, collection_name(), 0).name, 0); token::mutate_token_properties(account, sender, collection_name(), token::get_token_data_id_fields(sender, collection_name(), 0).name, 0, 1, vector::empty(), vector::empty(), vector::empty()); } fun collection_name(): vector<u8> { b\"DynamicNFTCollection\" } fun level_up_threshold(level: u64): u64 { level * 100 } }",
        "vulnerabilities": [
            "Lack of access control for experience gain",
            "No mechanism to transfer NFT with its associated data",
            "Potential for experience overflow",
            "Absence of events for level-ups and experience gains",
            "No way to customize level-up thresholds",
            "Lack of mechanism to reduce level or experience",
            "No support for multiple NFTs per user",
            "Absence of admin functions to adjust NFT properties",
            "Potential for lost NFT data if token is burned",
            "No mechanism to pause leveling or experience gain"
        ]
    },
    {
        "code": "module TokenSwap { use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: coin::Coin<X>, reserve_y: coin::Coin<Y>, } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let coins_in = coin::withdraw<X>(account, amount_in); let coins_out = calculate_output_amount(amount_in, coin::value(&pool.reserve_x), coin::value(&pool.reserve_y)); assert!(coins_out >= min_amount_out, 101); coin::deposit(signer::address_of(account), coin::extract(&mut pool.reserve_y, coins_out)); coin::merge(&mut pool.reserve_x, coins_in); } }",
        "vulnerabilities": [
            "No slippage protection",
            "Lack of access control for pool management",
            "Potential for front-running attacks"
        ]
    },
    {
        "code": "module NFTMarketplace { use aptos_framework::token; struct Listing has key { token_id: token::TokenId, price: u64, seller: address, } public fun list_nft(seller: &signer, token_id: token::TokenId, price: u64) { let listing = Listing { token_id, price, seller: signer::address_of(seller) }; move_to(seller, listing); token::transfer(seller, @marketplace_address, token_id); } public fun buy_nft(buyer: &signer, token_id: token::TokenId) acquires Listing { let listing = move_from<Listing>(token::owner(token_id)); coin::transfer<AptosCoin>(buyer, listing.seller, listing.price); token::transfer(@marketplace_address, signer::address_of(buyer), token_id); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow system for secure transactions",
            "Potential for price manipulation through self-trading"
        ]
    },
    {
        "code": "module StakingContract { use aptos_framework::coin; struct StakeInfo has key { amount: u64, reward: u64, } public fun stake(account: &signer, amount: u64) acquires StakeInfo { let coins = coin::withdraw<AptosCoin>(account, amount); if (!exists<StakeInfo>(signer::address_of(account))) { move_to(account, StakeInfo { amount: 0, reward: 0 }); } let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); stake_info.amount = stake_info.amount + amount; } public fun claim_reward(account: &signer) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); let reward = stake_info.reward; stake_info.reward = 0; coin::deposit(signer::address_of(account), coin::mint<AptosCoin>(reward)); } }",
        "vulnerabilities": [
            "No access control for reward distribution",
            "Lack of time-based staking mechanism",
            "Potential for reward calculation errors",
            "No mechanism to unstake funds",
            "Absence of events for staking and claiming",
            "No protection against flash loan attacks",
            "Lack of total supply tracking for rewards",
            "No emergency withdrawal function",
            "Potential for front-running on reward claims",
            "Absence of slashing mechanism for bad actors"
        ]
    },
    {
        "code": "module VotingSystem { struct Proposal has key { id: u64, votes_for: u64, votes_against: u64, } public fun create_proposal(creator: &signer, id: u64) { move_to(creator, Proposal { id, votes_for: 0, votes_against: 0 }); } public fun vote(voter: &signer, proposal_address: address, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); if (vote) { proposal.votes_for = proposal.votes_for + 1; } else { proposal.votes_against = proposal.votes_against + 1; } } }",
        "vulnerabilities": [
            "No mechanism to prevent double voting",
            "Lack of access control for proposal creation",
            "Absence of voting period or deadline",
            "No voter eligibility checks",
            "Potential for proposal ID conflicts",
            "Lack of vote weight consideration",
            "No mechanism to close or finalize proposals",
            "Absence of events for voting actions",
            "No way to change votes once cast",
            "Lack of quorum requirements for proposal validity"
        ]
    },
    {
        "code": "module SimpleDEX { use aptos_framework::coin; struct OrderBook<phantom BaseToken, phantom QuoteToken> has key { buy_orders: vector<Order>, sell_orders: vector<Order>, } struct Order has store, drop { price: u64, amount: u64, trader: address, } public fun place_order<BaseToken, QuoteToken>(trader: &signer, is_buy: bool, price: u64, amount: u64) acquires OrderBook { let order_book = borrow_global_mut<OrderBook<BaseToken, QuoteToken>>(@dex_address); let order = Order { price, amount, trader: signer::address_of(trader) }; if (is_buy) { vector::push_back(&mut order_book.buy_orders, order); } else { vector::push_back(&mut order_book.sell_orders, order); } } }",
        "vulnerabilities": [
            "Lack of order matching logic",
            "No mechanism to cancel orders",
            "Absence of fee collection system",
            "Potential for front-running attacks",
            "No slippage protection for traders",
            "Lack of access control for order placement",
            "Absence of events for order actions",
            "No protection against price manipulation",
            "Lack of order expiration mechanism",
            "No checks for sufficient balance before placing orders"
        ]
    },
    {
        "code": "module TimeLockedWallet { use aptos_framework::timestamp; struct LockedFunds has key { amount: u64, unlock_time: u64, } public fun deposit(account: &signer, amount: u64, lock_duration: u64) { let unlock_time = timestamp::now_seconds() + lock_duration; move_to(account, LockedFunds { amount, unlock_time }); } public fun withdraw(account: &signer) acquires LockedFunds { let locked_funds = move_from<LockedFunds>(signer::address_of(account)); assert!(timestamp::now_seconds() >= locked_funds.unlock_time, 1); coin::deposit(signer::address_of(account), coin::mint<AptosCoin>(locked_funds.amount)); } }",
        "vulnerabilities": [
            "No partial withdrawal mechanism",
            "Lack of access control for deposits",
            "Absence of events for deposits and withdrawals",
            "No emergency withdrawal function",
            "Potential for timestamp manipulation",
            "Lack of mechanism to extend lock duration",
            "No way to cancel a time-locked deposit",
            "Absence of multiple lock periods for the same user",
            "No protection against frontrunning on withdrawals",
            "Lack of interest accrual during lock period"
        ]
    },
    {
        "code": "module Voting { use std::signer; struct Proposal has key { id: u64, votes: u64, passed: bool } struct VotingPower has key { power: u64 } public fun create_proposal(creator: &signer, id: u64) { move_to(creator, Proposal { id, votes: 0, passed: false }); } public fun vote(voter: &signer, proposal_address: address) acquires Proposal, VotingPower { let power = borrow_global<VotingPower>(signer::address_of(voter)); let proposal = borrow_global_mut<Proposal>(proposal_address); proposal.votes = proposal.votes + power.power; if (proposal.votes > 100) { proposal.passed = true; } } public fun get_voting_power(account: address): u64 acquires VotingPower { borrow_global<VotingPower>(account).power } }",
        "vulnerabilities": [
            "No mechanism to prevent double voting",
            "Fixed threshold for proposal passing",
            "Lack of time limit for voting period"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::nft; struct Listing has key { creator: address, price: u64, token_id: nft::TokenId } public fun list_nft(seller: &signer, token_id: nft::TokenId, price: u64) { let seller_addr = signer::address_of(seller); nft::transfer(seller, @marketplace_address, token_id); move_to(seller, Listing { creator: seller_addr, price, token_id }); } public fun buy_nft<CoinType>(buyer: &signer, seller: address) acquires Listing { let listing = move_from<Listing>(seller); coin::transfer<CoinType>(buyer, listing.creator, listing.price); nft::transfer(@marketplace_address, signer::address_of(buyer), listing.token_id); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of price validation",
            "No option to cancel listing"
        ]
    },
    {
        "code": "module StakingRewards { use std::signer; use aptos_framework::coin; struct StakeInfo has key { amount: u64, last_claim: u64 } public fun stake<CoinType>(staker: &signer, amount: u64) { let staker_addr = signer::address_of(staker); coin::transfer<CoinType>(staker, @staking_pool, amount); if (!exists<StakeInfo>(staker_addr)) { move_to(staker, StakeInfo { amount, last_claim: 0 }); } else { let stake_info = borrow_global_mut<StakeInfo>(staker_addr); stake_info.amount = stake_info.amount + amount; } } public fun claim_rewards<CoinType>(claimer: &signer) acquires StakeInfo { let claimer_addr = signer::address_of(claimer); let stake_info = borrow_global_mut<StakeInfo>(claimer_addr); let current_time = aptos_framework::timestamp::now_seconds(); let reward = (current_time - stake_info.last_claim) * stake_info.amount / 100; coin::transfer<CoinType>(@staking_pool, claimer_addr, reward); stake_info.last_claim = current_time; } }",
        "vulnerabilities": [
            "Potential for overflow in reward calculation",
            "No slashing mechanism for bad actors",
            "Lack of minimum staking period"
        ]
    },
    {
        "code": "module DEX { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: u64, reserve_y: u64 } public fun add_liquidity<X, Y>(provider: &signer, amount_x: u64, amount_y: u64) { let provider_addr = signer::address_of(provider); if (!exists<LiquidityPool<X, Y>>(provider_addr)) { move_to(provider, LiquidityPool<X, Y> { reserve_x: 0, reserve_y: 0 }); } let pool = borrow_global_mut<LiquidityPool<X, Y>>(provider_addr); coin::transfer<X>(provider, @dex_address, amount_x); coin::transfer<Y>(provider, @dex_address, amount_y); pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; } public fun swap<X, Y>(trader: &signer, amount_in: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex_address); let amount_out = (amount_in * pool.reserve_y) / (pool.reserve_x + amount_in); coin::transfer<X>(trader, @dex_address, amount_in); coin::transfer<Y>(@dex_address, signer::address_of(trader), amount_out); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; } }",
        "vulnerabilities": [
            "No slippage protection",
            "Vulnerable to flash loan attacks",
            "Lack of fee mechanism for liquidity providers"
        ]
    },
    {
        "code": "module TimeLock { use std::signer; use aptos_framework::timestamp; struct LockedFunds<phantom CoinType> has key { amount: u64, unlock_time: u64 } public fun lock_funds<CoinType>(locker: &signer, amount: u64, lock_duration: u64) { let locker_addr = signer::address_of(locker); coin::transfer<CoinType>(locker, @timelock_address, amount); let unlock_time = timestamp::now_seconds() + lock_duration; move_to(locker, LockedFunds<CoinType> { amount, unlock_time }); } public fun withdraw<CoinType>(withdrawer: &signer) acquires LockedFunds { let withdrawer_addr = signer::address_of(withdrawer); let LockedFunds { amount, unlock_time } = move_from<LockedFunds<CoinType>>(withdrawer_addr); assert!(timestamp::now_seconds() >= unlock_time, 1); coin::transfer<CoinType>(@timelock_address, withdrawer_addr, amount); } }",
        "vulnerabilities": [
            "No partial withdrawal option",
            "Lack of emergency unlock mechanism",
            "Potential for griefing by locking small amounts frequently"
        ]
    },
    {
        "code": "module MultiSig { use std::signer; use std::vector; struct MultiSigWallet has key { owners: vector<address>, required_confirmations: u64 } struct Transaction has key { to: address, amount: u64, confirmations: u64, executed: bool } public fun create_wallet(creator: &signer, owners: vector<address>, required: u64) { move_to(creator, MultiSigWallet { owners, required_confirmations: required }); } public fun submit_transaction(submitter: &signer, to: address, amount: u64) acquires MultiSigWallet { let wallet = borrow_global<MultiSigWallet>(@multisig_address); assert!(vector::contains(&wallet.owners, &signer::address_of(submitter)), 1); move_to(submitter, Transaction { to, amount, confirmations: 1, executed: false }); } public fun confirm_transaction(confirmer: &signer, tx_address: address) acquires MultiSigWallet, Transaction { let wallet = borrow_global<MultiSigWallet>(@multisig_address); let tx = borrow_global_mut<Transaction>(tx_address); assert!(vector::contains(&wallet.owners, &signer::address_of(confirmer)), 1); tx.confirmations = tx.confirmations + 1; if (tx.confirmations >= wallet.required_confirmations && !tx.executed) { coin::transfer<AptosCoin>(@multisig_address, tx.to, tx.amount); tx.executed = true; } } }",
        "vulnerabilities": [
            "No mechanism to change owners or required confirmations",
            "Lack of transaction expiration",
            "Potential for transaction front-running"
        ]
    },
    {
        "code": "module Lottery { use std::signer; use aptos_framework::coin; use aptos_framework::random; struct LotteryPool has key { total_tickets: u64, prize: u64, winner: address } struct Ticket has key { number: u64 } public fun buy_ticket<CoinType>(buyer: &signer) acquires LotteryPool { let buyer_addr = signer::address_of(buyer); coin::transfer<CoinType>(buyer, @lottery_address, 1); let pool = borrow_global_mut<LotteryPool>(@lottery_address); pool.total_tickets = pool.total_tickets + 1; pool.prize = pool.prize + 1; move_to(buyer, Ticket { number: pool.total_tickets }); } public fun draw_winner(drawer: &signer) acquires LotteryPool { assert!(signer::address_of(drawer) == @lottery_admin, 1); let pool = borrow_global_mut<LotteryPool>(@lottery_address); let winning_number = random::rand_u64() % pool.total_tickets + 1; pool.winner = @winner_address; // In a real implementation, we would find the address with the winning ticket coin::transfer<CoinType>(@lottery_address, pool.winner, pool.prize); pool.prize = 0; pool.total_tickets = 0; } }",
        "vulnerabilities": [
            "Centralized drawing mechanism",
            "Lack of randomness source entropy",
            "No mechanism to refund tickets if lottery is cancelled"
        ]
    },
    {
        "code": "module DAO { use std::signer; struct Proposal has key { id: u64, votes_for: u64, votes_against: u64, executed: bool } struct MemberInfo has key { voting_power: u64 } public fun create_proposal(creator: &signer, id: u64) { move_to(creator, Proposal { id, votes_for: 0, votes_against: 0, executed: false }); } public fun vote(voter: &signer, proposal_address: address, vote_for: bool) acquires Proposal, MemberInfo { let member_info = borrow_global<MemberInfo>(signer::address_of(voter)); let proposal = borrow_global_mut<Proposal>(proposal_address); if (vote_for) { proposal.votes_for = proposal.votes_for + member_info.voting_power; } else { proposal.votes_against = proposal.votes_against + member_info.voting_power; } } public fun execute_proposal(executor: &signer, proposal_address: address) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(proposal.votes_for > proposal.votes_against, 1); assert!(!proposal.executed, 2); // Execute proposal logic here proposal.executed = true; } }",
        "vulnerabilities": [
            "No quorum requirement",
            "Lack of time limit for voting",
            "No mechanism to prevent double voting"
        ]
    },
    {
        "code": "module NFTFractionalization { use std::signer; use aptos_framework::coin; use aptos_framework::nft; struct FractionalNFT has key { token_id: nft::TokenId, total_shares: u64, price_per_share: u64 } public fun fractionalize_nft(owner: &signer, token_id: nft::TokenId, total_shares: u64, price_per_share: u64) { nft::transfer(owner, @fractional_vault, token_id); move_to(owner, FractionalNFT { token_id, total_shares, price_per_share }); } public fun buy_share<CoinType>(buyer: &signer, nft_address: address) acquires FractionalNFT { let nft = borrow_global_mut<FractionalNFT>(nft_address); assert!(nft.total_shares > 0, 1); coin::transfer<CoinType>(buyer, nft_address, nft.price_per_share); nft.total_shares = nft.total_shares - 1; } public fun redeem_nft(redeemer: &signer, nft_address: address) acquires FractionalNFT { let FractionalNFT { token_id, total_shares, price_per_share: _ } = move_from<FractionalNFT>(nft_address); assert!(total_shares == 0, 1); nft::transfer(@fractional_vault, signer::address_of(redeemer), token_id); } }",
        "vulnerabilities": [
            "No mechanism for share transfers",
            "Lack of price discovery for initial fractionalization",
            "Potential for permanent fractional state if not all shares are sold"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; use aptos_framework::coin; struct BridgeRequest has key { id: u64, amount: u64, recipient: address, completed: bool } public fun initiate_transfer<CoinType>(sender: &signer, amount: u64, recipient: address) { let sender_addr = signer::address_of(sender); coin::transfer<CoinType>(sender, @bridge_address, amount); let id = generate_unique_id(); // Implementation of this function is omitted move_to(sender, BridgeRequest { id, amount, recipient, completed: false }); } public fun complete_transfer<CoinType>(completer: &signer, request_address: address) acquires BridgeRequest { assert!(signer::address_of(completer) == @bridge_operator, 1); let request = move_from<BridgeRequest>(request_address); assert!(!request.completed, 2); coin::transfer<CoinType>(@bridge_address, request.recipient, request.amount); } public fun verify_transfer(verifier: &signer, request_address: address) acquires BridgeRequest { assert!(signer::address_of(verifier) == @bridge_operator, 1); let request = borrow_global_mut<BridgeRequest>(request_address); request.completed = true; } }",
        "vulnerabilities": [
            "Centralized bridge operator",
            "Lack of multi-sig for large transfers",
            "No mechanism to handle failed transfers"
        ]
    },
    {
        "code": "module SimpleDAO { use aptos_framework::coin; struct Proposal has key { id: u64, creator: address, amount: u64, votes: u64, executed: bool, } public fun create_proposal(creator: &signer, id: u64, amount: u64) { move_to(creator, Proposal { id, creator: signer::address_of(creator), amount, votes: 0, executed: false }); } public fun vote(voter: &signer, proposal_address: address) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); proposal.votes = proposal.votes + 1; } public fun execute_proposal(executor: &signer, proposal_address: address) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(!proposal.executed, 1); coin::transfer<AptosCoin>(executor, proposal.creator, proposal.amount); proposal.executed = true; } }",
        "vulnerabilities": [
            "No quorum or minimum vote threshold for execution",
            "Lack of voting power consideration",
            "Absence of proposal duration or deadline",
            "No mechanism to prevent double voting",
            "Lack of access control for proposal creation and execution",
            "No events emitted for proposal actions",
            "Absence of proposal cancellation mechanism",
            "Potential for frontrunning on proposal execution",
            "No checks for sufficient DAO treasury balance",
            "Lack of time delay between proposal passing and execution"
        ]
    },
    {
        "code": "module SimpleNFTMarketplace { use aptos_framework::token; struct Listing has key { price: u64, seller: address, } public fun list_nft(seller: &signer, token_id: token::TokenId, price: u64) { move_to(seller, Listing { price, seller: signer::address_of(seller) }); token::opt_in_direct_transfer(seller, true); } public fun buy_nft(buyer: &signer, token_address: address) acquires Listing { let listing = move_from<Listing>(token_address); coin::transfer<AptosCoin>(buyer, listing.seller, listing.price); token::transfer(listing.seller, token_address, signer::address_of(buyer), 1); } }",
        "vulnerabilities": [
            "No mechanism to delist NFTs",
            "Lack of access control for buying",
            "Absence of events for listing and buying",
            "No protection against price manipulation",
            "Lack of escrow mechanism for safer trades",
            "No royalty distribution system",
            "Absence of bid functionality",
            "Potential for lost listings if NFT is transferred",
            "No checks for NFT ownership before listing",
            "Lack of marketplace fee collection"
        ]
    },
    {
        "code": "module SimpleLendingProtocol { use aptos_framework::coin; struct LendingPool<phantom TokenType> has key { total_deposits: u64, total_borrows: u64, } struct UserAccount<phantom TokenType> has key { deposited: u64, borrowed: u64, } public fun deposit<TokenType>(user: &signer, amount: u64) acquires LendingPool, UserAccount { let pool = borrow_global_mut<LendingPool<TokenType>>(@pool_address); pool.total_deposits = pool.total_deposits + amount; let account = borrow_global_mut<UserAccount<TokenType>>(signer::address_of(user)); account.deposited = account.deposited + amount; coin::transfer<TokenType>(user, @pool_address, amount); } public fun borrow<TokenType>(user: &signer, amount: u64) acquires LendingPool, UserAccount { let pool = borrow_global_mut<LendingPool<TokenType>>(@pool_address); assert!(pool.total_deposits - pool.total_borrows >= amount, 1); pool.total_borrows = pool.total_borrows + amount; let account = borrow_global_mut<UserAccount<TokenType>>(signer::address_of(user)); account.borrowed = account.borrowed + amount; coin::transfer<TokenType>(@pool_address, signer::address_of(user), amount); } }",
        "vulnerabilities": [
            "No interest rate calculation",
            "Lack of collateralization mechanism",
            "Absence of liquidation process",
            "No debt ceiling or borrow limits",
            "Lack of oracle integration for price feeds",
            "No mechanism for partial repayments",
            "Absence of events for lending actions",
            "Potential for insolvency due to unchecked borrowing",
            "No emergency pause functionality",
            "Lack of governance for parameter adjustments"
        ]
    },
    {
        "code": "module TokenSwap { struct Pool has key { token_a: address, token_b: address, reserve_a: u64, reserve_b: u64, } public fun create_pool(creator: &signer, token_a: address, token_b: address) { let pool = Pool { token_a, token_b, reserve_a: 0, reserve_b: 0 }; move_to(creator, pool); } public fun swap(user: &signer, amount_in: u64, token_in: address, min_amount_out: u64) acquires Pool { // Swap logic here } }",
        "vulnerabilities": [
            "No slippage protection",
            "Lack of access control for pool creation",
            "Absence of fee mechanism",
            "Vulnerable to flash loan attacks"
        ]
    },
    {
        "code": "module NFTMarketplace { struct Listing has key { nft_id: u64, price: u64, seller: address, } public fun create_listing(seller: &signer, nft_id: u64, price: u64) { let listing = Listing { nft_id, price, seller: signer::address_of(seller) }; move_to(seller, listing); } public fun buy_nft(buyer: &signer, listing_address: address) acquires Listing { // Buy logic here } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow for secure transactions",
            "No option to cancel listings",
            "Potential for front-running attacks"
        ]
    },
    {
        "code": "module GovernanceToken { struct TokenInfo has key { total_supply: u64, circulating_supply: u64, } public fun mint(admin: &signer, amount: u64) acquires TokenInfo { // Minting logic here } public fun burn(holder: &signer, amount: u64) acquires TokenInfo { // Burning logic here } }",
        "vulnerabilities": [
            "Centralized minting control",
            "No cap on total supply",
            "Lack of transfer restrictions for regulatory compliance",
            "Absence of vote delegation mechanism"
        ]
    },
    {
        "code": "module StakingRewards { struct StakeInfo has key { amount: u64, reward_debt: u64, } public fun stake(user: &signer, amount: u64) acquires StakeInfo { // Staking logic here } public fun claim_rewards(user: &signer) acquires StakeInfo { // Reward claiming logic here } }",
        "vulnerabilities": [
            "No time-lock on staked tokens",
            "Potential for reward calculation errors",
            "Lack of slashing mechanism for validator misbehavior",
            "No protection against flash loan exploits"
        ]
    },
    {
        "code": "module MultiSigWallet { struct Transaction has key { to: address, value: u64, data: vector<u8>, executed: bool, } public fun submit_transaction(owner: &signer, to: address, value: u64, data: vector<u8>) { // Transaction submission logic } public fun confirm_transaction(owner: &signer, tx_id: u64) { // Confirmation logic } public fun execute_transaction(owner: &signer, tx_id: u64) acquires Transaction { // Execution logic } }",
        "vulnerabilities": [
            "No mechanism to change owners",
            "Lack of transaction expiration",
            "Potential for transaction ordering manipulation",
            "No option to cancel submitted transactions"
        ]
    },
    {
        "code": "module LiquidityMining { struct UserInfo has key { amount: u64, reward_debt: u64, } public fun deposit(user: &signer, amount: u64) acquires UserInfo { // Deposit logic here } public fun withdraw(user: &signer, amount: u64) acquires UserInfo { // Withdrawal logic here } public fun claim_rewards(user: &signer) acquires UserInfo { // Reward claiming logic here } }",
        "vulnerabilities": [
            "Potential for first depositor advantage",
            "No mechanism to handle reward token price fluctuations",
            "Lack of emergency withdrawal function",
            "Vulnerable to sandwich attacks"
        ]
    },
    {
        "code": "module CrossChainBridge { struct BridgeConfig has key { relayer: address, fee: u64, } public fun initialize(admin: &signer, relayer: address, fee: u64) { let config = BridgeConfig { relayer, fee }; move_to(admin, config); } public fun lock_tokens(user: &signer, amount: u64, target_chain: u64) { // Lock tokens logic } public fun release_tokens(relayer: &signer, recipient: address, amount: u64, source_chain: u64) acquires BridgeConfig { // Release tokens logic } }",
        "vulnerabilities": [
            "Centralized relayer control",
            "Lack of proper event emission for cross-chain tracking",
            "No mechanism to pause bridge operations",
            "Absence of multi-signature validation for large transfers"
        ]
    },
    {
        "code": "module DAO { use std::signer; use aptos_framework::table; struct Proposal has key { description: vector<u8>, yes_votes: u64, no_votes: u64, status: u8, execution_time: u64 } struct DAOConfig has key { proposals: table::Table<u64, Proposal>, voting_period: u64, execution_delay: u64, proposal_count: u64, quorum: u64 } public fun initialize(admin: &signer, voting_period: u64, execution_delay: u64, quorum: u64) { move_to(admin, DAOConfig { proposals: table::new(), voting_period, execution_delay, proposal_count: 0, quorum }); } public fun create_proposal(proposer: &signer, description: vector<u8>) acquires DAOConfig { let dao = borrow_global_mut<DAOConfig>(@0x1); let proposal = Proposal { description, yes_votes: 0, no_votes: 0, status: 0, execution_time: 0 }; table::add(&mut dao.proposals, dao.proposal_count, proposal); dao.proposal_count = dao.proposal_count + 1; } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires DAOConfig { let dao = borrow_global_mut<DAOConfig>(@0x1); let proposal = table::borrow_mut(&mut dao.proposals, proposal_id); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } } public fun execute_proposal(executor: &signer, proposal_id: u64) acquires DAOConfig { let dao = borrow_global_mut<DAOConfig>(@0x1); let proposal = table::borrow_mut(&mut dao.proposals, proposal_id); assert!(proposal.yes_votes >= dao.quorum, 101); assert!(proposal.yes_votes > proposal.no_votes, 102); assert!(aptos_framework::timestamp::now_seconds() >= proposal.execution_time, 103); // Execute proposal (not implemented) proposal.status = 2; } }",
        "vulnerabilities": [
            "No mechanism to prevent double voting",
            "Lack of access control for proposal creation and execution",
            "Missing time-bound voting period",
            "No ability to cancel or update proposals",
            "Potential for manipulation of execution timing"
        ]
    },
    {
        "code": "module DeFiLending { use std::signer; use aptos_framework::coin; struct LendingPool<phantom CoinType> has key { total_deposits: u64, total_borrows: u64, interest_rate: u64 } struct UserAccount<phantom CoinType> has key { deposited: u64, borrowed: u64, last_interest_update: u64 } public fun initialize<CoinType>(admin: &signer, interest_rate: u64) { move_to(admin, LendingPool<CoinType> { total_deposits: 0, total_borrows: 0, interest_rate }); } public fun deposit<CoinType>(user: &signer, amount: u64) acquires LendingPool, UserAccount { let pool = borrow_global_mut<LendingPool<CoinType>>(@0x1); pool.total_deposits = pool.total_deposits + amount; if (!exists<UserAccount<CoinType>>(signer::address_of(user))) { move_to(user, UserAccount<CoinType> { deposited: 0, borrowed: 0, last_interest_update: aptos_framework::timestamp::now_seconds() }); } let account = borrow_global_mut<UserAccount<CoinType>>(signer::address_of(user)); account.deposited = account.deposited + amount; coin::transfer<CoinType>(user, @0x1, amount); } public fun borrow<CoinType>(user: &signer, amount: u64) acquires LendingPool, UserAccount { let pool = borrow_global_mut<LendingPool<CoinType>>(@0x1); assert!(pool.total_deposits - pool.total_borrows >= amount, 101); pool.total_borrows = pool.total_borrows + amount; let account = borrow_global_mut<UserAccount<CoinType>>(signer::address_of(user)); account.borrowed = account.borrowed + amount; coin::transfer<CoinType>(@0x1, signer::address_of(user), amount); } public fun repay<CoinType>(user: &signer, amount: u64) acquires LendingPool, UserAccount { let pool = borrow_global_mut<LendingPool<CoinType>>(@0x1); pool.total_borrows = pool.total_borrows - amount; let account = borrow_global_mut<UserAccount<CoinType>>(signer::address_of(user)); account.borrowed = account.borrowed - amount; coin::transfer<CoinType>(user, @0x1, amount); } public fun withdraw<CoinType>(user: &signer, amount: u64) acquires LendingPool, UserAccount { let pool = borrow_global_mut<LendingPool<CoinType>>(@0x1); pool.total_deposits = pool.total_deposits - amount; let account = borrow_global_mut<UserAccount<CoinType>>(signer::address_of(user)); account.deposited = account.deposited - amount; coin::transfer<CoinType>(@0x1, signer::address_of(user), amount); } }",
        "vulnerabilities": [
            "No collateral requirements for borrowing",
            "Missing liquidation mechanism",
            "Lack of interest accrual implementation",
            "No checks for user solvency before withdrawal",
            "Potential for reentrancy attacks in deposit and withdraw functions"
        ]
    },
    {
        "code": "module FlashLoan { struct LendingPool has key { total_liquidity: u64, } public fun borrow_flash_loan(borrower: &signer, amount: u64) acquires LendingPool { // Borrow logic here } public fun repay_flash_loan(borrower: &signer, amount: u64, fee: u64) acquires LendingPool { // Repayment logic here } }",
        "vulnerabilities": [
            "No check for borrower's ability to repay",
            "Lack of access control for flash loan initiation",
            "Potential for reentrancy attacks",
            "No mechanism to adjust fees based on utilization"
        ]
    },
    {
        "code": "module OptionsTrading { struct Option has key { underlying_asset: address, strike_price: u64, expiration: u64, is_call: bool, } public fun create_option(creator: &signer, underlying_asset: address, strike_price: u64, expiration: u64, is_call: bool) { let option = Option { underlying_asset, strike_price, expiration, is_call }; move_to(creator, option); } public fun exercise_option(holder: &signer, option_address: address) acquires Option { // Exercise logic here } }",
        "vulnerabilities": [
            "Lack of price oracle integration for accurate pricing",
            "No mechanism for option trading or transfer",
            "Absence of liquidation process for undercollateralized positions",
            "Potential for front-running on option exercise"
        ]
    },
    {
        "code": "module PredictionMarket { struct Market has key { question: vector<u8>, resolution_time: u64, total_yes_stake: u64, total_no_stake: u64, } public fun create_market(creator: &signer, question: vector<u8>, resolution_time: u64) { let market = Market { question, resolution_time, total_yes_stake: 0, total_no_stake: 0 }; move_to(creator, market); } public fun place_bet(user: &signer, market_address: address, amount: u64, bet_yes: bool) acquires Market { // Betting logic here } public fun resolve_market(oracle: &signer, market_address: address, outcome: bool) acquires Market { // Resolution logic here } }",
        "vulnerabilities": [
            "Centralized oracle for market resolution",
            "No mechanism to handle market cancellations",
            "Lack of fee distribution for market creators",
            "Potential for manipulation through large bet placements"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use aptos_framework::table; struct Transaction has store { to: address, amount: u64, executed: bool } struct MultiSigWallet has key { owners: vector<address>, required_confirmations: u64, transactions: table::Table<u64, Transaction>, confirmations: table::Table<u64, table::Table<address, bool>>, transaction_count: u64 } public fun initialize(creator: &signer, owners: vector<address>, required_confirmations: u64) { assert!(vector::length(&owners) >= required_confirmations, 101); move_to(creator, MultiSigWallet { owners, required_confirmations, transactions: table::new(), confirmations: table::new(), transaction_count: 0 }); } public fun submit_transaction(submitter: &signer, to: address, amount: u64) acquires MultiSigWallet { let wallet = borrow_global_mut<MultiSigWallet>(@0x1); assert!(vector::contains(&wallet.owners, &signer::address_of(submitter)), 102); let tx = Transaction { to, amount, executed: false }; table::add(&mut wallet.transactions, wallet.transaction_count, tx); table::add(&mut wallet.confirmations, wallet.transaction_count, table::new()); wallet.transaction_count = wallet.transaction_count + 1; } public fun confirm_transaction(confirmer: &signer, tx_id: u64) acquires MultiSigWallet { let wallet = borrow_global_mut<MultiSigWallet>(@0x1); assert!(vector::contains(&wallet.owners, &signer::address_of(confirmer)), 103); let confirmations = table::borrow_mut(&mut wallet.confirmations, tx_id); table::add(confirmations, signer::address_of(confirmer), true); } public fun execute_transaction(executor: &signer, tx_id: u64) acquires MultiSigWallet { let wallet = borrow_global_mut<MultiSigWallet>(@0x1); let tx = table::borrow_mut(&mut wallet.transactions, tx_id); assert!(!tx.executed, 104); let confirmations = table::borrow(&wallet.confirmations, tx_id); let mut confirmed = 0; let i = 0; while (i < vector::length(&wallet.owners)) { if (table::contains(confirmations, *vector::borrow(&wallet.owners, i))) { confirmed = confirmed + 1; } i = i + 1; } assert!(confirmed >= wallet.required_confirmations, 105); coin::transfer<AptosCoin>(@0x1, tx.to, tx.amount); tx.executed = true; } }",
        "vulnerabilities": [
            "No mechanism to change owners or required confirmations",
            "Lack of access control for transaction execution",
            "Potential for transaction frontrunning",
            "No ability to cancel or update submitted transactions",
            "Missing checks for sufficient balance before executing transactions"
        ]
    },
    {
        "code": "module SimpleAuction { struct Auction has key { end_time: u64, highest_bid: u64, highest_bidder: address, } public fun create_auction(creator: &signer, duration: u64) { let end_time = timestamp::now_seconds() + duration; move_to(creator, Auction { end_time, highest_bid: 0, highest_bidder: @0x0 }); } public fun place_bid(bidder: &signer, auction_address: address, bid_amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(auction_address); assert!(timestamp::now_seconds() < auction.end_time, 1); assert!(bid_amount > auction.highest_bid, 2); if (auction.highest_bidder != @0x0) { coin::transfer<AptosCoin>(bidder, auction.highest_bidder, auction.highest_bid); } auction.highest_bid = bid_amount; auction.highest_bidder = signer::address_of(bidder); coin::transfer<AptosCoin>(bidder, auction_address, bid_amount); } }",
        "vulnerabilities": [
            "No mechanism to end auction early",
            "Lack of minimum bid increment",
            "Absence of events for bidding actions",
            "No protection against last-minute bidding",
            "Lack of access control for auction creation",
            "No mechanism to cancel bids",
            "Absence of reserve price",
            "Potential for auction extension on last-minute bids",
            "No checks for sufficient balance before bidding",
            "Lack of mechanism to handle tied bids"
        ]
    },
    {
        "code": "module SimpleInsurance { struct Policy has key { premium: u64, coverage: u64, expiry: u64, } public fun create_policy(insurer: &signer, policyholder: address, premium: u64, coverage: u64, duration: u64) { let expiry = timestamp::now_seconds() + duration; move_to(insurer, Policy { premium, coverage, expiry }); coin::transfer<AptosCoin>(policyholder, signer::address_of(insurer), premium); } public fun claim(policyholder: &signer, policy_address: address, claim_amount: u64) acquires Policy { let policy = borrow_global<Policy>(policy_address); assert!(timestamp::now_seconds() < policy.expiry, 1); assert!(claim_amount <= policy.coverage, 2); coin::transfer<AptosCoin>(policy_address, signer::address_of(policyholder), claim_amount); } }",
        "vulnerabilities": [
            "No verification of claim validity",
            "Lack of mechanism to adjust premiums",
            "Absence of events for policy actions",
            "No support for multiple policies per user",
            "Lack of access control for claim processing",
            "No mechanism to cancel or transfer policies",
            "Absence of deductibles or co-pays",
            "Potential for frontrunning on claims",
            "No mechanism to handle policy renewals",
            "Lack of tiered coverage options"
        ]
    },
    {
        "code": "module SimpleGovernance { struct Proposal has key { id: u64, description: vector<u8>, votes: u64, executed: bool, } struct VotingPower has key { amount: u64, } public fun create_proposal(creator: &signer, id: u64, description: vector<u8>) { move_to(creator, Proposal { id, description, votes: 0, executed: false }); } public fun vote(voter: &signer, proposal_address: address) acquires Proposal, VotingPower { let voting_power = borrow_global<VotingPower>(signer::address_of(voter)); let proposal = borrow_global_mut<Proposal>(proposal_address); proposal.votes = proposal.votes + voting_power.amount; } public fun execute_proposal(executor: &signer, proposal_address: address) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(!proposal.executed, 1); assert!(proposal.votes >= 1000, 2); // Assume 1000 is the threshold proposal.executed = true; } }",
        "vulnerabilities": [
            "No mechanism to remove or update proposals",
            "Lack of time-based voting periods",
            "Absence of events for governance actions",
            "No protection against double voting",
            "Lack of quorum requirements",
            "No mechanism to delegate voting power",
            "Absence of vote locking or cooldown periods",
            "Potential for governance attacks with large voting power",
            "No support for different proposal types",
            "Lack of timelock for proposal execution"
        ]
    },
    {
        "code": "module Governance { use std::vector; struct Proposal has key { id: u64, description: vector<u8>, votes_for: u64, votes_against: u64, expiration: u64, } public fun create_proposal(creator: &signer, description: vector<u8>, expiration: u64) { let proposal = Proposal { id: get_next_proposal_id(), description, votes_for: 0, votes_against: 0, expiration }; move_to(creator, proposal); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@governance_address); assert!(aptos_framework::timestamp::now_seconds() < proposal.expiration, 102); if (vote) { proposal.votes_for += 1; } else { proposal.votes_against += 1; } } }",
        "vulnerabilities": [
            "No quorum requirement for proposal execution",
            "Lack of vote delegation mechanism",
            "Potential for spam proposals without submission cost"
        ]
    },
    {
        "code": "module TokenSwap { struct LiquidityPool has key { token_a_reserve: u64, token_b_reserve: u64, lp_token_supply: u64, } public fun add_liquidity(account: &signer, token_a_amount: u64, token_b_amount: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); pool.token_a_reserve += token_a_amount; pool.token_b_reserve += token_b_amount; let lp_tokens = (token_a_amount * pool.lp_token_supply) / pool.token_a_reserve; pool.lp_token_supply += lp_tokens; } public fun swap(account: &signer, token_in_amount: u64, token_in_is_a: bool) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); let (in_reserve, out_reserve) = if (token_in_is_a) (pool.token_a_reserve, pool.token_b_reserve) else (pool.token_b_reserve, pool.token_a_reserve); let token_out_amount = (token_in_amount * out_reserve) / (in_reserve + token_in_amount); if (token_in_is_a) { pool.token_a_reserve += token_in_amount; pool.token_b_reserve -= token_out_amount; } else { pool.token_b_reserve += token_in_amount; pool.token_a_reserve -= token_out_amount; } } }",
        "vulnerabilities": [
            "No slippage protection for swaps",
            "Vulnerable to front-running attacks",
            "Lack of access control for adding liquidity",
            "No mechanism to remove liquidity",
            "Potential for integer overflow in calculations",
            "No fees for liquidity providers",
            "Absence of price oracle integration",
            "No support for multi-hop swaps"
        ]
    },
    {
        "code": "module NFTMarketplace { struct Listing has key { token_id: u64, price: u64, seller: address, } public fun create_listing(seller: &signer, token_id: u64, price: u64) { let listing = Listing { token_id, price, seller: signer::address_of(seller) }; move_to(seller, listing); } public fun buy_nft(buyer: &signer, seller: address, token_id: u64) acquires Listing { let listing = move_from<Listing>(seller); assert!(coin::balance<AptosCoin>(signer::address_of(buyer)) >= listing.price, 1); coin::transfer<AptosCoin>(buyer, seller, listing.price); // Transfer NFT logic here } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow for secure transactions",
            "No support for auctions or bidding",
            "Absence of listing expiration",
            "Potential for seller to transfer listed NFT",
            "No mechanism to update listing price"
        ]
    },
    {
        "code": "module StakingPool { struct Pool has key { total_staked: u64, reward_per_token: u64, last_update_time: u64, } struct UserInfo has key { amount: u64, reward_debt: u64, } public fun stake(account: &signer, amount: u64) acquires Pool, UserInfo { let pool = borrow_global_mut<Pool>(@pool_address); let user_info = borrow_global_mut<UserInfo>(signer::address_of(account)); update_pool(); let pending_reward = (user_info.amount * pool.reward_per_token) - user_info.reward_debt; user_info.amount += amount; user_info.reward_debt = user_info.amount * pool.reward_per_token; pool.total_staked += amount; } public fun claim_rewards(account: &signer) acquires Pool, UserInfo { let pool = borrow_global_mut<Pool>(@pool_address); let user_info = borrow_global_mut<UserInfo>(signer::address_of(account)); update_pool(); let pending_reward = (user_info.amount * pool.reward_per_token) - user_info.reward_debt; user_info.reward_debt = user_info.amount * pool.reward_per_token; // Transfer pending_reward to user } fun update_pool() acquires Pool { let pool = borrow_global_mut<Pool>(@pool_address); let current_time = timestamp::now_seconds(); let time_elapsed = current_time - pool.last_update_time; let reward = time_elapsed * REWARD_RATE; pool.reward_per_token += (reward * PRECISION) / pool.total_staked; pool.last_update_time = current_time; } }",
        "vulnerabilities": [
            "Potential for integer overflow in reward calculations",
            "Lack of minimum staking period",
            "No mechanism to pause or emergency withdraw",
            "Absence of access control for pool management",
            "Vulnerability to flash loan attacks"
        ]
    },
    {
        "code": "module LendingProtocol { struct Market has key { collateral_factor: u64, borrow_rate: u64, supply_rate: u64, total_cash: u64, total_borrows: u64, total_reserves: u64, } struct UserAccount has key { collateral: u64, borrowed: u64, } public fun supply(account: &signer, amount: u64) acquires Market, UserAccount { let market = borrow_global_mut<Market>(@market_address); let user_account = borrow_global_mut<UserAccount>(signer::address_of(account)); market.total_cash += amount; user_account.collateral += amount; } public fun borrow(account: &signer, amount: u64) acquires Market, UserAccount { let market = borrow_global_mut<Market>(@market_address); let user_account = borrow_global_mut<UserAccount>(signer::address_of(account)); assert!(user_account.collateral * market.collateral_factor >= (user_account.borrowed + amount) * PRECISION, 1); market.total_cash -= amount; market.total_borrows += amount; user_account.borrowed += amount; } }",
        "vulnerabilities": [
            "Lack of interest accrual mechanism",
            "No liquidation process for undercollateralized positions",
            "Absence of oracle integration for price feeds",
            "Potential for interest rate manipulation",
            "No support for multiple asset types",
            "Lack of borrowing limits or utilization-based interest rates"
        ]
    },
    {
        "code": "module DecentralizedExchange { struct LiquidityPool has key { token_a: address, token_b: address, reserve_a: u64, reserve_b: u64, total_shares: u64, } public fun add_liquidity(account: &signer, amount_a: u64, amount_b: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); let share_amount = if (pool.total_shares == 0) { sqrt(amount_a * amount_b) } else { min((amount_a * pool.total_shares) / pool.reserve_a, (amount_b * pool.total_shares) / pool.reserve_b) }; pool.reserve_a += amount_a; pool.reserve_b += amount_b; pool.total_shares += share_amount; } public fun swap(account: &signer, amount_in: u64, token_in: address) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); let (reserve_in, reserve_out) = if (token_in == pool.token_a) (pool.reserve_a, pool.reserve_b) else (pool.reserve_b, pool.reserve_a); let amount_out = (amount_in * reserve_out) / (reserve_in + amount_in); if (token_in == pool.token_a) { pool.reserve_a += amount_in; pool.reserve_b -= amount_out; } else { pool.reserve_b += amount_in; pool.reserve_a -= amount_out; } } }",
        "vulnerabilities": [
            "No slippage protection for traders",
            "Vulnerable to sandwich attacks",
            "Lack of fee mechanism for liquidity providers",
            "No support for flash swaps",
            "Absence of price impact limits",
            "Potential for impermanent loss without mitigation"
        ]
    },
    {
        "code": "module Vault { struct VaultInfo has key { total_shares: u64, total_assets: u64, } struct UserShares has key { amount: u64, } public fun deposit(account: &signer, amount: u64) acquires VaultInfo, UserShares { let vault = borrow_global_mut<VaultInfo>(@vault_address); let user_shares = borrow_global_mut<UserShares>(signer::address_of(account)); let shares_to_mint = if (vault.total_shares == 0) { amount } else { (amount * vault.total_shares) / vault.total_assets }; vault.total_shares += shares_to_mint; vault.total_assets += amount; user_shares.amount += shares_to_mint; } public fun withdraw(account: &signer, shares: u64) acquires VaultInfo, UserShares { let vault = borrow_global_mut<VaultInfo>(@vault_address); let user_shares = borrow_global_mut<UserShares>(signer::address_of(account)); let assets_to_withdraw = (shares * vault.total_assets) / vault.total_shares; vault.total_shares -= shares; vault.total_assets -= assets_to_withdraw; user_shares.amount -= shares; } }",
        "vulnerabilities": [
            "Lack of access control for vault management",
            "No mechanism to pause deposits or withdrawals",
            "Potential for front-running on deposits and withdrawals",
            "Absence of fee mechanism for vault operator",
            "No support for multiple asset types"
        ]
    },
    {
        "code": "module PredictionMarket { struct Market has key { id: u64, outcome_a_stake: u64, outcome_b_stake: u64, resolution_time: u64, resolved: bool, winning_outcome: bool, } public fun create_market(creator: &signer, id: u64, resolution_time: u64) { let market = Market { id, outcome_a_stake: 0, outcome_b_stake: 0, resolution_time, resolved: false, winning_outcome: false }; move_to(creator, market); } public fun place_bet(account: &signer, market_id: u64, outcome: bool, amount: u64) acquires Market { let market = borrow_global_mut<Market>(@market_address); assert!(!market.resolved && timestamp::now_seconds() < market.resolution_time, 1); if (outcome) { market.outcome_a_stake += amount; } else { market.outcome_b_stake += amount; } } public fun resolve_market(resolver: &signer, market_id: u64, winning_outcome: bool) acquires Market { let market = borrow_global_mut<Market>(@market_address); assert!(!market.resolved && timestamp::now_seconds() >= market.resolution_time, 2); market.resolved = true; market.winning_outcome = winning_outcome; } }",
        "vulnerabilities": [
            "Lack of oracle integration for trusted resolutions",
            "No mechanism for market cancellation",
            "Absence of fee structure for market creators",
            "Potential for manipulation with large bets",
            "No support for multiple outcomes or scalar markets"
        ]
    },
    {
        "code": "module CrossChainBridge { struct BridgeConfig has key { relayer: address, threshold: u64, } struct PendingTransfer has key { recipient: address, amount: u64, source_chain: vector<u8>, nonce: u64, } public fun initiate_transfer(sender: &signer, recipient: address, amount: u64, destination_chain: vector<u8>) { // Logic to lock tokens and emit transfer event } public fun complete_transfer(relayer: &signer, recipient: address, amount: u64, source_chain: vector<u8>, nonce: u64, signatures: vector<vector<u8>>) acquires BridgeConfig, PendingTransfer { let config = borrow_global<BridgeConfig>(@bridge_address); assert!(signer::address_of(relayer) == config.relayer, 1); assert!(vector::length(&signatures) >= config.threshold, 2); // Verify signatures logic here let transfer = PendingTransfer { recipient, amount, source_chain, nonce }; move_to(relayer, transfer); } }",
        "vulnerabilities": [
            "Single point of failure with one relayer",
            "Lack of proper signature verification",
            "No mechanism to update bridge configuration",
            "Absence of transfer limits or rate limiting",
            "Potential for replay attacks without proper nonce management"
        ]
    },
    {
        "code": "module TimelockController { struct TimelockOperation has key { target: address, data: vector<u8>, execution_time: u64, } public fun queue_operation(proposer: &signer, target: address, data: vector<u8>, delay: u64) { let execution_time = timestamp::now_seconds() + delay; let operation = TimelockOperation { target, data, execution_time }; move_to(proposer, operation); } public fun execute_operation(executor: &signer, operation_address: address) acquires TimelockOperation { let operation = move_from<TimelockOperation>(operation_address); assert!(timestamp::now_seconds() >= operation.execution_time, 1); // Execute operation logic here } }",
        "vulnerabilities": [
            "Lack of access control for proposers and executors",
            "No mechanism to cancel queued operations",
            "Absence of minimum and maximum delay settings",
            "Potential for griefing by queueing many operations"
        ]
    },
    {
        "code": "module MultiSigWallet { struct Wallet has key { owners: vector<address>, required_confirmations: u64, } struct Transaction has key { to: address, value: u64, data: vector<u8>, executed: bool, confirmations: u64, } public fun create_wallet(creator: &signer, owners: vector<address>, required_confirmations: u64) { let wallet = Wallet { owners, required_confirmations }; move_to(creator, wallet); } public fun submit_transaction(submitter: &signer, to: address, value: u64, data: vector<u8>) acquires Wallet { let wallet = borrow_global<Wallet>(@wallet_address); assert!(vector::contains(&wallet.owners, &signer::address_of(submitter)), 1); let transaction = Transaction { to, value, data, executed: false, confirmations: 1 }; move_to(submitter, transaction); } public fun confirm_transaction(confirmer: &signer, transaction_address: address) acquires Wallet, Transaction { let wallet = borrow_global<Wallet>(@wallet_address); let transaction = borrow_global_mut<Transaction>(transaction_address); assert!(vector::contains(&wallet.owners, &signer::address_of(confirmer)), 2); assert!(!transaction.executed, 3); transaction.confirmations += 1; if (transaction.confirmations >= wallet.required_confirmations) { transaction.executed = true; // Execute transaction logic here } } }",
        "vulnerabilities": [
            "No mechanism to change owners or required confirmations",
            "Lack of support for revoking confirmations",
            "Potential for transaction hash collisions",
            "Absence of time locks for added security"
        ]
    },
    {
        "code": "module StableCoin { use aptos_framework::managed_coin; struct StableCoinCap has key {} public fun mint(treasury: &signer, amount: u64, recipient: address) acquires StableCoinCap { assert!(exists<StableCoinCap>(signer::address_of(treasury)), 103); managed_coin::mint<StableCoin>(treasury, recipient, amount); } public fun burn(account: &signer, amount: u64) { managed_coin::burn<StableCoin>(account, amount); } public fun update_price_oracle(oracle: &signer, new_price: u64) { // Update price oracle logic } }",
        "vulnerabilities": [
            "Centralized control over minting and burning",
            "Lack of collateralization mechanism",
            "No automatic rebalancing based on price fluctuations"
        ]
    },
    {
        "code": "module LendingProtocol { use aptos_framework::coin; struct LendingPool<phantom CoinType> has key { total_deposits: u64, total_borrows: u64, interest_rate: u64, } public fun deposit<CoinType>(account: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_address); let deposit = coin::withdraw<CoinType>(account, amount); coin::merge(&mut pool.total_deposits, deposit); // Mint interest-bearing tokens logic } public fun borrow<CoinType>(account: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_address); assert!(pool.total_deposits - pool.total_borrows >= amount, 104); coin::deposit(signer::address_of(account), coin::extract(&mut pool.total_deposits, amount)); pool.total_borrows += amount; // Record loan and collateral logic } }",
        "vulnerabilities": [
            "No collateralization ratio enforcement",
            "Lack of liquidation mechanism for undercollateralized loans",
            "Potential for interest rate manipulation"
        ]
    },
    {
        "code": "module MultisigWallet { use std::vector; struct MultisigAccount has key { owners: vector<address>, required_confirmations: u64, } struct Transaction has store { to: address, amount: u64, confirmations: u64, executed: bool, } public fun create_multisig(creator: &signer, owners: vector<address>, required_confirmations: u64) { let multisig = MultisigAccount { owners, required_confirmations }; move_to(creator, multisig); } public fun submit_transaction(account: &signer, to: address, amount: u64) acquires MultisigAccount { let multisig = borrow_global_mut<MultisigAccount>(@multisig_address); assert!(vector::contains(&multisig.owners, &signer::address_of(account)), 105); let transaction = Transaction { to, amount, confirmations: 1, executed: false }; // Add transaction to pending transactions } }",
        "vulnerabilities": [
            "No mechanism to change owners or required confirmations",
            "Lack of transaction expiration mechanism",
            "Potential for owner key compromise affecting all funds"
        ]
    },
    {
        "code": "module DecentralizedExchange { use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: coin::Coin<X>, reserve_y: coin::Coin<Y>, lp_tokens: u64, } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex_address); let coins_x = coin::withdraw<X>(account, amount_x); let coins_y = coin::withdraw<Y>(account, amount_y); coin::merge(&mut pool.reserve_x, coins_x); coin::merge(&mut pool.reserve_y, coins_y); // Mint LP tokens logic } public fun remove_liquidity<X, Y>(account: &signer, lp_amount: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex_address); // Calculate proportional amounts of X and Y to return // Burn LP tokens and transfer X and Y back to account } }",
        "vulnerabilities": [
            "Impermanent loss risk for liquidity providers",
            "No fee mechanism for liquidity providers",
            "Potential for price manipulation in low liquidity pools"
        ]
    },
    {
        "code": "module CrossChainBridge { use aptos_framework::event; struct BridgeEvent has drop, store { from_chain: u8, to_chain: u8, token_address: address, amount: u64, recipient: address, } public fun initiate_transfer(sender: &signer, to_chain: u8, token_address: address, amount: u64, recipient: address) { // Lock tokens on Aptos chain let event = BridgeEvent { from_chain: 1, to_chain, token_address, amount, recipient }; event::emit(event); } public fun process_incoming_transfer(validator: &signer, from_chain: u8, token_address: address, amount: u64, recipient: address) { // Verify cross-chain message and mint/transfer tokens on Aptos } }",
        "vulnerabilities": [
            "Centralized validator control for cross-chain transfers",
            "Lack of decentralized consensus mechanism for message verification",
            "Potential for double-spending if bridge contract is compromised"
        ]
    },
    {
        "code": "module FlashLoan { use aptos_framework::coin; struct FlashLoanPool<phantom CoinType> has key { reserve: coin::Coin<CoinType>, } public fun execute_flash_loan<CoinType>(borrower: &signer, amount: u64) acquires FlashLoanPool { let pool = borrow_global_mut<FlashLoanPool<CoinType>>(@flash_loan_address); let loan = coin::extract(&mut pool.reserve, amount); // Execute borrower's code here assert!(coin::value(&loan) >= amount, 106); // Ensure loan is repaid with fee coin::merge(&mut pool.reserve, loan); } }",
        "vulnerabilities": [
            "No access control on flash loan execution",
            "Lack of fee mechanism for flash loans",
            "Potential for reentrancy attacks in borrower's code execution"
        ]
    },
    {
        "code": "module PredictionMarket { use aptos_framework::coin; struct Market has key { outcome_a: coin::Coin<AptosCoin>, outcome_b: coin::Coin<AptosCoin>, resolution_time: u64, resolved: bool, } public fun create_market(creator: &signer, resolution_time: u64) { let market = Market { outcome_a: coin::zero<AptosCoin>(), outcome_b: coin::zero<AptosCoin>(), resolution_time, resolved: false }; move_to(creator, market); } public fun bet_on_outcome(bettor: &signer, amount: u64, outcome: bool) acquires Market { let market = borrow_global_mut<Market>(@market_address); let bet = coin::withdraw<AptosCoin>(bettor, amount); if (outcome) { coin::merge(&mut market.outcome_a, bet); } else { coin::merge(&mut market.outcome_b, bet); } } public fun resolve_market(resolver: &signer, winning_outcome: bool) acquires Market { let market = borrow_global_mut<Market>(@market_address); assert!(aptos_framework::timestamp::now_seconds() >= market.resolution_time, 107); market.resolved = true; // Distribute winnings logic } }",
        "vulnerabilities": [
            "Centralized market resolution mechanism",
            "No provisions for handling disputed outcomes",
            "Potential for front-running bets before market resolution"
        ]
    },
    {
        "code": "module DecentralizedExchange { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: u64, reserve_y: u64, } struct LPToken<phantom X, phantom Y> {} public fun create_pool<X, Y>(account: &signer) { let sender = signer::address_of(account); assert!(!exists<LiquidityPool<X, Y>>(sender), 1); move_to(account, LiquidityPool<X, Y> { reserve_x: 0, reserve_y: 0 }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex); let lp_amount = if (pool.reserve_x == 0 && pool.reserve_y == 0) { (amount_x * amount_y) as u64 } else { std::math64::min((amount_x * pool.reserve_y) / pool.reserve_x, (amount_y * pool.reserve_x) / pool.reserve_y) }; pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; coin::transfer<X>(account, @dex, amount_x); coin::transfer<Y>(account, @dex, amount_y); coin::mint<LPToken<X, Y>>(lp_amount, account); } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex); let amount_out = (amount_in * pool.reserve_y) / (pool.reserve_x + amount_in); assert!(amount_out >= min_amount_out, 2); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; coin::transfer<X>(account, @dex, amount_in); coin::transfer<Y>(@dex, signer::address_of(account), amount_out); } }",
        "vulnerabilities": [
            "No slippage protection in add_liquidity",
            "Lack of fee mechanism for swaps",
            "Potential for price manipulation through large swaps",
            "No mechanism to remove liquidity",
            "Absence of events for important operations",
            "No access control for pool creation",
            "Potential integer overflow in swap calculations",
            "Lack of price oracles for accurate pricing",
            "No support for flash loans",
            "Absence of emergency pause mechanism"
        ]
    },
    {
        "code": "module DAO { use std::signer; use aptos_framework::coin; struct Proposal has key { id: u64, description: vector<u8>, vote_yes: u64, vote_no: u64, end_time: u64, executed: bool, } struct MembershipToken {} public fun create_proposal(account: &signer, description: vector<u8>, voting_period: u64) { let sender = signer::address_of(account); let proposal_id = get_next_proposal_id(); move_to(account, Proposal { id: proposal_id, description, vote_yes: 0, vote_no: 0, end_time: aptos_framework::timestamp::now_seconds() + voting_period, executed: false, }); } public fun vote(account: &signer, proposal_id: u64, vote_yes: bool) acquires Proposal { let sender = signer::address_of(account); let proposal = borrow_global_mut<Proposal>(@dao); assert!(aptos_framework::timestamp::now_seconds() <= proposal.end_time, 1); let voting_power = coin::balance<MembershipToken>(sender); if (vote_yes) { proposal.vote_yes = proposal.vote_yes + voting_power; } else { proposal.vote_no = proposal.vote_no + voting_power; } } public fun execute_proposal(proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@dao); assert!(!proposal.executed, 2); assert!(aptos_framework::timestamp::now_seconds() > proposal.end_time, 3); assert!(proposal.vote_yes > proposal.vote_no, 4); proposal.executed = true; // Execute proposal logic here } fun get_next_proposal_id(): u64 { // Implementation omitted 0 } }",
        "vulnerabilities": [
            "Lack of quorum requirement for proposal execution",
            "No mechanism to cancel or update proposals",
            "Potential for governance attacks through token concentration",
            "Absence of time lock for executed proposals",
            "No delegation mechanism for voting power",
            "Lack of proposal threshold to prevent spam",
            "No support for quadratic voting or other advanced voting systems",
            "Potential for flash loan attacks to influence votes",
            "Absence of vote privacy (all votes are public)",
            "No mechanism to slash tokens for malicious proposals"
        ]
    },
    {
        "code": "module DecentralizedInsurance { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct InsurancePool<phantom CoinType> has key { funds: coin::Coin<CoinType>, total_coverage: u64, } struct Policy<phantom CoinType> has key { coverage_amount: u64, premium_paid: u64, expiry: u64, } public fun create_pool<CoinType>(creator: &signer, initial_funds: coin::Coin<CoinType>) { move_to(creator, InsurancePool<CoinType> { funds: initial_funds, total_coverage: 0 }); } public fun buy_policy<CoinType>(buyer: &signer, coverage_amount: u64, duration: u64) acquires InsurancePool { let pool = borrow_global_mut<InsurancePool<CoinType>>(@insurance_address); let premium = calculate_premium(coverage_amount, duration); let premium_payment = coin::withdraw<CoinType>(buyer, premium); coin::merge(&mut pool.funds, premium_payment); pool.total_coverage = pool.total_coverage + coverage_amount; let expiry = timestamp::now_seconds() + duration; move_to(buyer, Policy<CoinType> { coverage_amount, premium_paid: premium, expiry }); } public fun claim<CoinType>(claimer: &signer, claim_amount: u64) acquires InsurancePool, Policy { let policy = borrow_global<Policy<CoinType>>(signer::address_of(claimer)); assert!(timestamp::now_seconds() <= policy.expiry && claim_amount <= policy.coverage_amount, 1); let pool = borrow_global_mut<InsurancePool<CoinType>>(@insurance_address); let payout = coin::extract(&mut pool.funds, claim_amount); coin::deposit(signer::address_of(claimer), payout); pool.total_coverage = pool.total_coverage - claim_amount; } public fun calculate_premium(coverage_amount: u64, duration: u64): u64 { // Simplified premium calculation coverage_amount * duration / (365 * 100) } }",
        "vulnerabilities": [
            "Lack of claim verification mechanism",
            "No reinsurance or risk distribution",
            "Potential for insolvency if many claims occur simultaneously"
        ]
    },
    {
        "code": "module DecentralizedIdentity { use std::signer; use std::vector; struct Identity has key { did: vector<u8>, public_key: vector<u8>, attributes: vector<Attribute>, } struct Attribute has store { name: vector<u8>, value: vector<u8>, issuer: address, } public fun create_identity(account: &signer, did: vector<u8>, public_key: vector<u8>) { let sender = signer::address_of(account); assert!(!exists<Identity>(sender), 1); move_to(account, Identity { did, public_key, attributes: vector::empty() }); } public fun add_attribute(account: &signer, name: vector<u8>, value: vector<u8>) acquires Identity { let sender = signer::address_of(account); let identity = borrow_global_mut<Identity>(sender); vector::push_back(&mut identity.attributes, Attribute { name, value, issuer: sender }); } public fun verify_attribute(identity_address: address, name: vector<u8>, value: vector<u8>): bool acquires Identity { let identity = borrow_global<Identity>(identity_address); let attributes = &identity.attributes; let i = 0; while (i < vector::length(attributes)) { let attr = vector::borrow(attributes, i); if (attr.name == name && attr.value == value) { return true } i = i + 1; } false } public fun update_public_key(account: &signer, new_public_key: vector<u8>) acquires Identity { let sender = signer::address_of(account); let identity = borrow_global_mut<Identity>(sender); identity.public_key = new_public_key; } }",
        "vulnerabilities": [
            "No mechanism for revoking attributes",
            "Lack of privacy for sensitive attributes",
            "No support for hierarchical or delegated identities"
        ]
    },
    {
        "code": "module SimpleDAO { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct DAO<phantom CoinType> has key { treasury: coin::Coin<CoinType>, proposal_count: u64, } struct Proposal has key { id: u64, description: vector<u8>, amount: u64, recipient: address, yes_votes: u64, no_votes: u64, end_time: u64, executed: bool, } struct Member has key { voting_power: u64, } public fun initialize_dao<CoinType>(creator: &signer) { move_to(creator, DAO<CoinType> { treasury: coin::zero<CoinType>(), proposal_count: 0 }); } public fun join_dao<CoinType>(account: &signer, amount: u64) acquires DAO { let sender = signer::address_of(account); let deposit = coin::withdraw<CoinType>(account, amount); let dao = borrow_global_mut<DAO<CoinType>>(@dao_address); coin::merge(&mut dao.treasury, deposit); move_to(account, Member { voting_power: amount }); } public fun create_proposal<CoinType>(creator: &signer, description: vector<u8>, amount: u64, recipient: address, duration: u64) acquires DAO { let dao = borrow_global_mut<DAO<CoinType>>(@dao_address); let proposal_id = dao.proposal_count + 1; dao.proposal_count = proposal_id; let end_time = timestamp::now_seconds() + duration; move_to(creator, Proposal { id: proposal_id, description, amount, recipient, yes_votes: 0, no_votes: 0, end_time, executed: false }); } public fun vote<CoinType>(voter: &signer, proposal_id: u64, approve: bool) acquires Proposal, Member { let member = borrow_global<Member>(signer::address_of(voter)); let proposal = borrow_global_mut<Proposal>(@dao_address); assert!(timestamp::now_seconds() < proposal.end_time, 1); if (approve) { proposal.yes_votes = proposal.yes_votes + member.voting_power; } else { proposal.no_votes = proposal.no_votes + member.voting_power; } } public fun execute_proposal<CoinType>(executor: &signer, proposal_id: u64) acquires DAO, Proposal { let proposal = borrow_global_mut<Proposal>(@dao_address); assert!(timestamp::now_seconds() >= proposal.end_time && !proposal.executed && proposal.yes_votes > proposal.no_votes, 2); let dao = borrow_global_mut<DAO<CoinType>>(@dao_address); let payment = coin::extract(&mut dao.treasury, proposal.amount); coin::deposit(proposal.recipient, payment); proposal.executed = true; } }",
        "vulnerabilities": [
            "No quorum requirement for proposal execution",
            "Lack of time lock for executed proposals",
            "Potential for majority attacks with concentrated voting power"
        ]
    },
    {
        "code": "module DecentralizedStorage { use std::signer; use std::vector; struct File has key { owner: address, name: vector<u8>, chunks: vector<Chunk>, } struct Chunk has store { content_hash: vector<u8>, storage_provider: address, } struct StorageProvider has key { available_space: u64, price_per_byte: u64, } public fun register_provider(provider: &signer, space: u64, price: u64) { let sender = signer::address_of(provider); move_to(provider, StorageProvider { available_space: space, price_per_byte: price }); } public fun store_file(owner: &signer, name: vector<u8>, content_hashes: vector<vector<u8>>, providers: vector<address>) acquires StorageProvider { let sender = signer::address_of(owner); let chunks = vector::empty<Chunk>(); let i = 0; while (i < vector::length(&content_hashes)) { let provider_address = *vector::borrow(&providers, i); let provider = borrow_global_mut<StorageProvider>(provider_address); let chunk_size = vector::length(vector::borrow(&content_hashes, i)); assert!(provider.available_space >= chunk_size, 1); provider.available_space = provider.available_space - chunk_size; vector::push_back(&mut chunks, Chunk { content_hash: *vector::borrow(&content_hashes, i), storage_provider: provider_address }); i = i + 1; } move_to(owner, File { owner: sender, name, chunks }); } public fun retrieve_file(file_owner: address, name: vector<u8>): vector<vector<u8>> acquires File { let file = borrow_global<File>(file_owner); assert!(file.name == name, 2); let content_hashes = vector::empty<vector<u8>>(); let i = 0; while (i < vector::length(&file.chunks)) { let chunk = vector::borrow(&file.chunks, i); vector::push_back(&mut content_hashes, chunk.content_hash); i = i + 1; } content_hashes } public fun delete_file(owner: &signer, name: vector<u8>) acquires File, StorageProvider { let sender = signer::address_of(owner); let File { owner: _, name: _, chunks } = move_from<File>(sender); let i = 0; while (i < vector::length(&chunks)) { let chunk = vector::pop_back(&mut chunks); let provider = borrow_global_mut<StorageProvider>(chunk.storage_provider); provider.available_space = provider.available_space + vector::length(&chunk.content_hash); i = i + 1; } } }",
        "vulnerabilities": [
            "No encryption for stored files",
            "Lack of incentive mechanism for long-term storage",
            "No redundancy or error correction for stored chunks"
        ]
    },
    {
        "code": "module MultisigWallet { use std::signer; use std::vector; use aptos_framework::coin; struct Wallet has key { owners: vector<address>, required_confirmations: u64, transaction_count: u64, } struct Transaction has key { to: address, value: u64, data: vector<u8>, executed: bool, confirmations: u64, } const E_NOT_OWNER: u64 = 1; const E_INVALID_REQUIRED_CONFIRMATIONS: u64 = 2; const E_ALREADY_CONFIRMED: u64 = 3; const E_NOT_CONFIRMED: u64 = 4; const E_ALREADY_EXECUTED: u64 = 5; public fun initialize(account: &signer, owners: vector<address>, required_confirmations: u64) { let sender = signer::address_of(account); assert!(required_confirmations <= vector::length(&owners), E_INVALID_REQUIRED_CONFIRMATIONS); move_to(account, Wallet { owners, required_confirmations, transaction_count: 0, }); } public fun submit_transaction<CoinType>(account: &signer, to: address, value: u64, data: vector<u8>) acquires Wallet { let sender = signer::address_of(account); let wallet = borrow_global_mut<Wallet>(sender); assert!(vector::contains(&wallet.owners, &sender), E_NOT_OWNER); let tx_id = wallet.transaction_count; wallet.transaction_count = wallet.transaction_count + 1; move_to(account, Transaction { to, value, data, executed: false, confirmations: 0, }); } public fun confirm_transaction(account: &signer, tx_id: u64) acquires Wallet, Transaction { let sender = signer::address_of(account); let wallet = borrow_global<Wallet>(@wallet_address); assert!(vector::contains(&wallet.owners, &sender), E_NOT_OWNER); let transaction = borrow_global_mut<Transaction>(@wallet_address); assert!(!transaction.executed, E_ALREADY_EXECUTED); transaction.confirmations = transaction.confirmations + 1; } public fun revoke_confirmation(account: &signer, tx_id: u64) acquires Wallet, Transaction { let sender = signer::address_of(account); let wallet = borrow_global<Wallet>(@wallet_address); assert!(vector::contains(&wallet.owners, &sender), E_NOT_OWNER); let transaction = borrow_global_mut<Transaction>(@wallet_address); assert!(!transaction.executed, E_ALREADY_EXECUTED); assert!(transaction.confirmations > 0, E_NOT_CONFIRMED); transaction.confirmations = transaction.confirmations - 1; } public fun execute_transaction<CoinType>(account: &signer, tx_id: u64) acquires Wallet, Transaction { let sender = signer::address_of(account); let wallet = borrow_global<Wallet>(@wallet_address); assert!(vector::contains(&wallet.owners, &sender), E_NOT_OWNER); let transaction = borrow_global_mut<Transaction>(@wallet_address); assert!(!transaction.executed, E_ALREADY_EXECUTED); assert!(transaction.confirmations >= wallet.required_confirmations, E_NOT_CONFIRMED); transaction.executed = true; coin::transfer<CoinType>(@wallet_address, transaction.to, transaction.value); } }",
        "vulnerabilities": [
            "Lack of access control for initialize function",
            "No mechanism to change owners or required confirmations",
            "Missing event emissions for transaction submissions and executions",
            "Potential reentrancy in execute_transaction function",
            "No time lock for transaction execution",
            "Centralized storage of transaction data",
            "Lack of protection against signature replay attacks",
            "No checks for contract balance before transfers",
            "Potential integer overflow in transaction count",
            "Missing checks for zero address in transfers"
        ]
    },
    {
        "code": "module DecentralizedVoting { use std::signer; use std::vector; struct Proposal has key { id: u64, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64, } struct VoterInfo has key { voted_proposals: vector<u64>, } public fun create_proposal(creator: &signer, description: vector<u8>, duration: u64) acquires Proposal { let sender = signer::address_of(creator); let proposal_id = borrow_global<Proposal>(@0x1).id + 1; move_to(creator, Proposal { id: proposal_id, description, yes_votes: 0, no_votes: 0, end_time: timestamp::now_seconds() + duration, }); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal, VoterInfo { let sender = signer::address_of(voter); let proposal = borrow_global_mut<Proposal>(@0x1); assert!(timestamp::now_seconds() < proposal.end_time, 1); if (!exists<VoterInfo>(sender)) { move_to(voter, VoterInfo { voted_proposals: vector::empty() }); } let voter_info = borrow_global_mut<VoterInfo>(sender); assert!(!vector::contains(&voter_info.voted_proposals, &proposal_id), 2); vector::push_back(&mut voter_info.voted_proposals, proposal_id); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } } public fun get_results(proposal_id: u64): (u64, u64) acquires Proposal { let proposal = borrow_global<Proposal>(@0x1); (proposal.yes_votes, proposal.no_votes) } }",
        "vulnerabilities": [
            "No mechanism to prevent Sybil attacks",
            "Lack of proposal execution logic",
            "No way to update or cancel proposals"
        ]
    },
    {
        "code": "module TokenSwap { use std::signer; struct TokenA has key { balance: u64 } struct TokenB has key { balance: u64 } struct LiquidityPool has key { token_a_reserve: u64, token_b_reserve: u64, } public fun initialize_pool(creator: &signer, initial_a: u64, initial_b: u64) { let sender = signer::address_of(creator); assert!(!exists<LiquidityPool>(sender), 1); move_to(creator, LiquidityPool { token_a_reserve: initial_a, token_b_reserve: initial_b }); } public fun swap_a_to_b(account: &signer, amount_in: u64) acquires TokenA, TokenB, LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool>(@0x1); let token_a = borrow_global_mut<TokenA>(sender); assert!(token_a.balance >= amount_in, 2); let token_b = borrow_global_mut<TokenB>(sender); let amount_out = (amount_in * pool.token_b_reserve) / (pool.token_a_reserve + amount_in); token_a.balance = token_a.balance - amount_in; token_b.balance = token_b.balance + amount_out; pool.token_a_reserve = pool.token_a_reserve + amount_in; pool.token_b_reserve = pool.token_b_reserve - amount_out; } public fun swap_b_to_a(account: &signer, amount_in: u64) acquires TokenA, TokenB, LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool>(@0x1); let token_b = borrow_global_mut<TokenB>(sender); assert!(token_b.balance >= amount_in, 2); let token_a = borrow_global_mut<TokenA>(sender); let amount_out = (amount_in * pool.token_a_reserve) / (pool.token_b_reserve + amount_in); token_b.balance = token_b.balance - amount_in; token_a.balance = token_a.balance + amount_out; pool.token_b_reserve = pool.token_b_reserve + amount_in; pool.token_a_reserve = pool.token_a_reserve - amount_out; } }",
        "vulnerabilities": [
            "No slippage protection",
            "Vulnerable to flash loan attacks",
            "Lack of liquidity provider incentives"
        ]
    },
    {
        "code": "module DAO { use std::signer; use std::vector; use aptos_framework::coin; use aptos_framework::timestamp; struct Proposal has key { id: u64, proposer: address, description: vector<u8>, amount: u64, recipient: address, yes_votes: u64, no_votes: u64, start_time: u64, end_time: u64, executed: bool, } struct DAO<phantom GovernanceToken> has key { proposals: vector<Proposal>, next_proposal_id: u64, voting_period: u64, execution_delay: u64, proposal_threshold: u64, } struct MemberVote has key { votes: vector<u64>, } public fun initialize<GovernanceToken>(account: &signer, voting_period: u64, execution_delay: u64, proposal_threshold: u64) { assert!(!exists<DAO<GovernanceToken>>(signer::address_of(account)), 1); move_to(account, DAO<GovernanceToken> { proposals: vector::empty(), next_proposal_id: 0, voting_period, execution_delay, proposal_threshold, }); } public fun create_proposal<GovernanceToken>(proposer: &signer, description: vector<u8>, amount: u64, recipient: address) acquires DAO { let sender = signer::address_of(proposer); let dao = borrow_global_mut<DAO<GovernanceToken>>(@dao_address); assert!(coin::balance<GovernanceToken>(sender) >= dao.proposal_threshold, 2); let proposal = Proposal { id: dao.next_proposal_id, proposer: sender, description, amount, recipient, yes_votes: 0, no_votes: 0, start_time: timestamp::now_seconds(), end_time: timestamp::now_seconds() + dao.voting_period, executed: false, }; vector::push_back(&mut dao.proposals, proposal); dao.next_proposal_id = dao.next_proposal_id + 1; } public fun vote<GovernanceToken>(voter: &signer, proposal_id: u64, support: bool) acquires DAO, MemberVote { let sender = signer::address_of(voter); let dao = borrow_global_mut<DAO<GovernanceToken>>(@dao_address); let proposal = vector::borrow_mut(&mut dao.proposals, proposal_id); assert!(timestamp::now_seconds() >= proposal.start_time && timestamp::now_seconds() <= proposal.end_time, 3); let vote_weight = coin::balance<GovernanceToken>(sender); if (support) { proposal.yes_votes = proposal.yes_votes + vote_weight; } else { proposal.no_votes = proposal.no_votes + vote_weight; } if (!exists<MemberVote>(sender)) { move_to(voter, MemberVote { votes: vector::empty() }); } let member_vote = borrow_global_mut<MemberVote>(sender); vector::push_back(&mut member_vote.votes, proposal_id); } public fun execute_proposal<GovernanceToken>(executor: &signer, proposal_id: u64) acquires DAO { let dao = borrow_global_mut<DAO<GovernanceToken>>(@dao_address); let proposal = vector::borrow_mut(&mut dao.proposals, proposal_id); assert!(!proposal.executed, 4); assert!(timestamp::now_seconds() > proposal.end_time + dao.execution_delay, 5); assert!(proposal.yes_votes > proposal.no_votes, 6); coin::transfer<GovernanceToken>(@dao_address, proposal.recipient, proposal.amount); proposal.executed = true; } }",
        "vulnerabilities": [
            "Lack of proposal cancellation mechanism",
            "No support for multiple token types in voting"
        ]
    },
    {
        "code": "module Staking { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakeInfo has key { amount: u64, start_time: u64, } public fun stake(account: &signer, amount: u64) acquires StakeInfo { let addr = signer::address_of(account); if (!exists<StakeInfo>(addr)) { move_to(account, StakeInfo { amount: 0, start_time: 0, }); } let stake_info = borrow_global_mut<StakeInfo>(addr); stake_info.amount = stake_info.amount + amount; stake_info.start_time = timestamp::now_seconds(); coin::transfer<AptosCoin>(account, @staking_pool, amount); } public fun unstake(account: &signer) acquires StakeInfo { let addr = signer::address_of(account); let stake_info = borrow_global_mut<StakeInfo>(addr); let amount = stake_info.amount; let duration = timestamp::now_seconds() - stake_info.start_time; let reward = (amount * duration) / 100000000; // Simple reward calculation stake_info.amount = 0; stake_info.start_time = 0; coin::transfer<AptosCoin>(@staking_pool, addr, amount + reward); } }",
        "vulnerabilities": [
            "No access control for unstaking",
            "Lack of minimum staking period",
            "Potential for reward manipulation by frequent staking/unstaking",
            "No checks for sufficient balance in staking pool",
            "Missing event emissions for stake and unstake actions",
            "Centralized control of the staking pool",
            "No maximum cap on total staked amount",
            "Potential integer overflow in reward calculation",
            "Lack of slashing mechanism for bad actors",
            "No time-lock or vesting period for rewards"
        ]
    },
    {
        "code": "module DEX { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: u64, reserve_y: u64, lp_token_supply: u64, } public fun create_pool<X, Y>(account: &signer) { assert!(!exists<LiquidityPool<X, Y>>(signer::address_of(account)), 1); move_to(account, LiquidityPool<X, Y> { reserve_x: 0, reserve_y: 0, lp_token_supply: 0 }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex_address); let lp_tokens = if (pool.lp_token_supply == 0) { (amount_x * amount_y) } else { std::math::min((amount_x * pool.lp_token_supply) / pool.reserve_x, (amount_y * pool.lp_token_supply) / pool.reserve_y) }; coin::transfer<X>(@dex_address, sender, amount_x); coin::transfer<Y>(@dex_address, sender, amount_y); pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; pool.lp_token_supply = pool.lp_token_supply + lp_tokens; } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex_address); let amount_out = (amount_in * pool.reserve_y) / (pool.reserve_x + amount_in); assert!(amount_out >= min_amount_out, 2); coin::transfer<X>(@dex_address, sender, amount_in); coin::transfer<Y>(sender, @dex_address, amount_out); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; } }",
        "vulnerabilities": [
            "No slippage protection for liquidity providers",
            "Lack of access control for pool creation"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::object; struct Listing has key { creator: address, token_id: u64, price: u64, } public fun list_nft(seller: &signer, token_id: u64, price: u64) { let seller_addr = signer::address_of(seller); assert!(object::owns(seller_addr, token_id), 1); move_to(seller, Listing { creator: seller_addr, token_id, price }); } public fun buy_nft(buyer: &signer, token_id: u64) acquires Listing { let listing = move_from<Listing>(object::owner(token_id)); coin::transfer<AptosCoin>(signer::address_of(buyer), listing.creator, listing.price); object::transfer(listing.creator, token_id, signer::address_of(buyer)); } public fun cancel_listing(seller: &signer, token_id: u64) acquires Listing { let seller_addr = signer::address_of(seller); let Listing { creator, token_id: _, price: _ } = move_from<Listing>(seller_addr); assert!(creator == seller_addr, 2); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow system for secure transactions"
        ]
    },
    {
        "code": "module Staking { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakePool<phantom StakeToken, phantom RewardToken> has key { total_staked: u64, reward_per_token: u64, last_update_time: u64, } struct UserStake<phantom StakeToken, phantom RewardToken> has key { amount: u64, reward_debt: u64, } public fun initialize<StakeToken, RewardToken>(admin: &signer) { assert!(!exists<StakePool<StakeToken, RewardToken>>(signer::address_of(admin)), 1); move_to(admin, StakePool<StakeToken, RewardToken> { total_staked: 0, reward_per_token: 0, last_update_time: timestamp::now_seconds(), }); } public fun stake<StakeToken, RewardToken>(account: &signer, amount: u64) acquires StakePool, UserStake { let sender = signer::address_of(account); let pool = borrow_global_mut<StakePool<StakeToken, RewardToken>>(@staking_address); update_rewards<StakeToken, RewardToken>(); coin::transfer<StakeToken>(sender, @staking_address, amount); if (!exists<UserStake<StakeToken, RewardToken>>(sender)) { move_to(account, UserStake<StakeToken, RewardToken> { amount: 0, reward_debt: 0 }); } let user_stake = borrow_global_mut<UserStake<StakeToken, RewardToken>>(sender); user_stake.amount = user_stake.amount + amount; user_stake.reward_debt = user_stake.reward_debt + (amount * pool.reward_per_token); pool.total_staked = pool.total_staked + amount; } public fun unstake<StakeToken, RewardToken>(account: &signer, amount: u64) acquires StakePool, UserStake { let sender = signer::address_of(account); let pool = borrow_global_mut<StakePool<StakeToken, RewardToken>>(@staking_address); update_rewards<StakeToken, RewardToken>(); let user_stake = borrow_global_mut<UserStake<StakeToken, RewardToken>>(sender); assert!(user_stake.amount >= amount, 2); user_stake.amount = user_stake.amount - amount; user_stake.reward_debt = user_stake.reward_debt - (amount * pool.reward_per_token); pool.total_staked = pool.total_staked - amount; coin::transfer<StakeToken>(@staking_address, sender, amount); } public fun claim_rewards<StakeToken, RewardToken>(account: &signer) acquires StakePool, UserStake { let sender = signer::address_of(account); update_rewards<StakeToken, RewardToken>(); let user_stake = borrow_global_mut<UserStake<StakeToken, RewardToken>>(sender); let pool = borrow_global<StakePool<StakeToken, RewardToken>>(@staking_address); let pending_reward = (user_stake.amount * pool.reward_per_token) - user_stake.reward_debt; if (pending_reward > 0) { coin::transfer<RewardToken>(@staking_address, sender, pending_reward); user_stake.reward_debt = user_stake.amount * pool.reward_per_token; } } fun update_rewards<StakeToken, RewardToken>() acquires StakePool { let pool = borrow_global_mut<StakePool<StakeToken, RewardToken>>(@staking_address); let current_time = timestamp::now_seconds(); if (current_time > pool.last_update_time && pool.total_staked > 0) { let time_elapsed = current_time - pool.last_update_time; let reward_amount = time_elapsed * 100; // Simplified reward calculation pool.reward_per_token = pool.reward_per_token + (reward_amount / pool.total_staked); pool.last_update_time = current_time; } } }",
        "vulnerabilities": [
            "Simplified reward calculation may lead to inaccuracies",
            "No mechanism to adjust staking rewards over time"
        ]
    },
    {
        "code": "module Voting { use std::signer; struct Proposal has key { description: vector<u8>, votes_for: u64, votes_against: u64, } public fun create_proposal(account: &signer, description: vector<u8>) { let sender = signer::address_of(account); move_to(account, Proposal { description: description, votes_for: 0, votes_against: 0 }); } public fun vote(account: &signer, proposal_address: address, support: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); if (support) { proposal.votes_for = proposal.votes_for + 1; } else { proposal.votes_against = proposal.votes_against + 1; } } }",
        "vulnerabilities": [
            "No time limit for voting",
            "Potential for double voting"
        ]
    },
    {
        "code": "module Auction { use std::signer; use aptos_framework::coin; struct AuctionItem has key { highest_bid: u64, highest_bidder: address, end_time: u64, } public fun create_auction(account: &signer, start_time: u64, end_time: u64) { assert!(end_time > start_time, 1); move_to(account, AuctionItem { highest_bid: 0, highest_bidder: signer::address_of(account), end_time: end_time }); } public fun bid(account: &signer, auction_address: address, amount: u64) acquires AuctionItem { let sender = signer::address_of(account); let auction = borrow_global_mut<AuctionItem>(auction_address); assert!(move_std::time::now() < auction.end_time, 2); assert!(amount > auction.highest_bid, 3); auction.highest_bid = amount; auction.highest_bidder = sender; } }",
        "vulnerabilities": [
            "No refund mechanism for previous highest bid",
            "No mechanism to end auction"
        ]
    },
    {
        "code": "module Escrow { use std::signer; use aptos_framework::coin; struct EscrowAccount<X> has key { buyer: address, seller: address, amount: coin::Coin<X>, } public fun create_escrow<X>(buyer: &signer, seller: address, amount: coin::Coin<X>) { let buyer_address = signer::address_of(buyer); move_to(buyer, EscrowAccount { buyer: buyer_address, seller: seller, amount: amount }); } public fun release<X>(account: &signer, escrow_address: address) acquires EscrowAccount { let escrow = borrow_global_mut<EscrowAccount<X>>(escrow_address); let sender = signer::address_of(account); assert!(sender == escrow.buyer, 1); coin::deposit(escrow.seller, coin::extract(&mut escrow.amount, coin::value(&escrow.amount))); } }",
        "vulnerabilities": [
            "No dispute resolution mechanism",
            "Funds locked indefinitely if buyer doesn't release"
        ]
    },
    {
        "code": "module TokenLock { use std::signer; use aptos_framework::coin; struct LockedTokens<X> has key { owner: address, amount: coin::Coin<X>, release_time: u64, } public fun lock_tokens<X>(account: &signer, amount: coin::Coin<X>, release_time: u64) { assert!(release_time > move_std::time::now(), 1); let owner = signer::address_of(account); move_to(account, LockedTokens { owner: owner, amount: amount, release_time: release_time }); } public fun unlock_tokens<X>(account: &signer, lock_address: address) acquires LockedTokens { let lock = borrow_global_mut<LockedTokens<X>>(lock_address); let sender = signer::address_of(account); assert!(move_std::time::now() >= lock.release_time, 2); assert!(sender == lock.owner, 3); coin::deposit(sender, coin::extract(&mut lock.amount, coin::value(&lock.amount))); } }",
        "vulnerabilities": [
            "No mechanism to extend lock period",
            "Locked tokens can't be transferred"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; struct Listing has key { seller: address, price: u64, } public fun create_listing(account: &signer, price: u64) { let seller = signer::address_of(account); move_to(account, Listing { seller: seller, price: price }); } public fun buy(account: &signer, listing_address: address) acquires Listing { let listing = borrow_global_mut<Listing>(listing_address); let buyer = signer::address_of(account); assert!(coin::balance<bcs::native<aptos_framework::coin::Coin>>(buyer) >= listing.price, 1); coin::transfer(account, listing.seller, listing.price); } }",
        "vulnerabilities": [
            "No listing expiration mechanism",
            "No handling for insufficient funds"
        ]
    },
    {
        "code": "module Lottery { use std::signer; use aptos_framework::coin; struct Lottery has key { tickets: vector<address>, prize_pool: coin::Coin<aptos_framework::coin::Coin>, end_time: u64, } public fun create_lottery(account: &signer, end_time: u64) { assert!(end_time > move_std::time::now(), 1); move_to(account, Lottery { tickets: vector::empty(), prize_pool: coin::zero(), end_time: end_time }); } public fun buy_ticket(account: &signer, lottery_address: address) acquires Lottery { let lottery = borrow_global_mut<Lottery>(lottery_address); let buyer = signer::address_of(account); lottery.tickets.push(buyer); coin::merge(&mut lottery.prize_pool, coin::extract(&mut account.balance)); } public fun draw_winner(account: &signer, lottery_address: address) acquires Lottery { let lottery = borrow_global_mut<Lottery>(lottery_address); assert!(move_std::time::now() >= lottery.end_time, 2); let winner_index = (move_std::rand::random() % vector::length(&lottery.tickets)) as u64; let winner = vector::borrow(&lottery.tickets, winner_index); coin::deposit(*winner, coin::extract(&mut lottery.prize_pool, coin::value(&lottery.prize_pool))); } }",
        "vulnerabilities": [
            "No ticket price set",
            "Potential for random number manipulation"
        ]
    },
    {
        "code": "module TimeLock { use std::signer; struct TimeLock has key { owner: address, end_time: u64, } public fun create_timelock(account: &signer, end_time: u64) { assert!(end_time > move_std::time::now(), 1); let owner = signer::address_of(account); move_to(account, TimeLock { owner: owner, end_time: end_time }); } public fun execute_timelock(account: &signer, timelock_address: address) acquires TimeLock { let timelock = borrow_global_mut<TimeLock>(timelock_address); let sender = signer::address_of(account); assert!(move_std::time::now() >= timelock.end_time, 2); assert!(sender == timelock.owner, 3); destroy_object(timelock); } }",
        "vulnerabilities": [
            "No value locked in timelock",
            "Single point of failure"
        ]
    },
    {
        "code": "module DAO { use std::signer; struct Proposal has key { description: vector<u8>, votes: u64, end_time: u64, } struct DAOConfig has key { proposals: vector<Proposal>, } public fun create_dao(account: &signer) { move_to(account, DAOConfig { proposals: vector::empty() }); } public fun submit_proposal(account: &signer, description: vector<u8>, end_time: u64) acquires DAOConfig { let dao = borrow_global_mut<DAOConfig>(signer::address_of(account)); assert!(end_time > move_std::time::now(), 1); dao.proposals.push(Proposal { description: description, votes: 0, end_time: end_time }); } public fun vote(account: &signer, dao_address: address, proposal_index: u64) acquires DAOConfig { let dao = borrow_global_mut<DAOConfig>(dao_address); let proposal = vector::borrow_mut(&mut dao.proposals, proposal_index); assert!(move_std::time::now() < proposal.end_time, 2); proposal.votes = proposal.votes + 1; } }",
        "vulnerabilities": [
            "No mechanism to prevent vote spamming",
            "No weight to votes"
        ]
    },
    {
        "code": "module Subscription { use std::signer; use aptos_framework::coin; struct Subscription<X> has key { subscriber: address, amount: coin::Coin<X>, duration: u64, start_time: u64, } public fun subscribe<X>(account: &signer, amount: coin::Coin<X>, duration: u64) { let subscriber = signer::address_of(account); let start_time = move_std::time::now(); move_to(account, Subscription { subscriber: subscriber, amount: amount, duration: duration, start_time: start_time }); } public fun check_subscription<X>(account: &signer, subscription_address: address) acquires Subscription { let subscription = borrow_global_mut<Subscription<X>>(subscription_address); let sender = signer::address_of(account); assert!(sender == subscription.subscriber, 1); assert!(move_std::time::now() < subscription.start_time + subscription.duration, 2); } }",
        "vulnerabilities": [
            "No renewal mechanism",
            "Fixed subscription duration"
        ]
    },
    {
        "code": "module AssetManagement { use std::signer; use aptos_framework::coin; struct Asset<X> has key { owner: address, amount: coin::Coin<X>, } public fun deposit_asset<X>(account: &signer, amount: coin::Coin<X>) { let owner = signer::address_of(account); move_to(account, Asset { owner: owner, amount: amount }); } public fun withdraw_asset<X>(account: &signer, asset_address: address) acquires Asset { let asset = borrow_global_mut<Asset<X>>(asset_address); let sender = signer::address_of(account); assert!(sender == asset.owner, 1); coin::deposit(sender, coin::extract(&mut asset.amount, coin::value(&asset.amount))); } }",
        "vulnerabilities": [
            "No fee mechanism",
            "No multi-signature support"
        ]
    },    
    {
        "code": "module LendingProtocol { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct LendingPool<phantom AssetType> has key { total_deposits: u64, total_borrows: u64, interest_rate: u64, last_update_time: u64, } struct UserAccount<phantom AssetType> has key { deposits: u64, borrows: u64, } public fun initialize<AssetType>(admin: &signer) { assert!(!exists<LendingPool<AssetType>>(signer::address_of(admin)), 1); move_to(admin, LendingPool<AssetType> { total_deposits: 0, total_borrows: 0, interest_rate: 500, // 5% annual interest rate last_update_time: timestamp::now_seconds(), }); } public fun deposit<AssetType>(account: &signer, amount: u64) acquires LendingPool, UserAccount { let sender = signer::address_of(account); update_interest<AssetType>(); coin::transfer<AssetType>(sender, @lending_address, amount); let pool = borrow_global_mut<LendingPool<AssetType>>(@lending_address); pool.total_deposits = pool.total_deposits + amount; if (!exists<UserAccount<AssetType>>(sender)) { move_to(account, UserAccount<AssetType> { deposits: 0, borrows: 0 }); } let user_account = borrow_global_mut<UserAccount<AssetType>>(sender); user_account.deposits = user_account.deposits + amount; } public fun borrow<AssetType>(account: &signer, amount: u64) acquires LendingPool, UserAccount { let sender = signer::address_of(account); update_interest<AssetType>(); let pool = borrow_global_mut<LendingPool<AssetType>>(@lending_address); assert!(pool.total_deposits - pool.total_borrows >= amount, 2); pool.total_borrows = pool.total_borrows + amount; let user_account = borrow_global_mut<UserAccount<AssetType>>(sender); user_account.borrows = user_account.borrows + amount; coin::transfer<AssetType>(@lending_address, sender, amount); } public fun repay<AssetType>(account: &signer, amount: u64) acquires LendingPool, UserAccount { let sender = signer::address_of(account); update_interest<AssetType>(); coin::transfer<AssetType>(sender, @lending_address, amount); let pool = borrow_global_mut<LendingPool<AssetType>>(@lending_address); pool.total_borrows = pool.total_borrows - amount; let user_account = borrow_global_mut<UserAccount<AssetType>>(sender); assert!(user_account.borrows >= amount, 3); user_account.borrows = user_account.borrows - amount; } fun update_interest<AssetType>() acquires LendingPool { let pool = borrow_global_mut<LendingPool<AssetType>>(@lending_address); let current_time = timestamp::now_seconds(); let time_elapsed = current_time - pool.last_update_time; let interest_accrued = (pool.total_borrows * pool.interest_rate * time_elapsed) / (100 * 365 * 86400); pool.total_borrows = pool.total_borrows + interest_accrued; pool.last_update_time = current_time; } }",
        "vulnerabilities": [
            "No collateralization mechanism for loans",
            "Fixed interest rate may not adapt to market conditions"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use std::vector; use aptos_framework::coin; struct MultiSigWallet has key { owners: vector<address>, required_confirmations: u64, transaction_count: u64, } struct Transaction has store { to: address, value: u64, data: vector<u8>, executed: bool, confirmations: u64, } struct Transactions has key { transactions: vector<Transaction>, } public fun initialize(account: &signer, owners: vector<address>, required: u64) { assert!(vector::length(&owners) >= required && required > 0, 1); move_to(account, MultiSigWallet { owners, required_confirmations: required, transaction_count: 0 }); move_to(account, Transactions { transactions: vector::empty() }); } public fun submit_transaction(account: &signer, to: address, value: u64, data: vector<u8>) acquires MultiSigWallet, Transactions { let sender = signer::address_of(account); let wallet = borrow_global_mut<MultiSigWallet>(@wallet_address); assert!(vector::contains(&wallet.owners, &sender), 2); let transaction = Transaction { to, value, data, executed: false, confirmations: 0 }; let transactions = borrow_global_mut<Transactions>(@wallet_address); vector::push_back(&mut transactions.transactions, transaction); wallet.transaction_count = wallet.transaction_count + 1; } public fun confirm_transaction(account: &signer, tx_id: u64) acquires MultiSigWallet, Transactions { let sender = signer::address_of(account); let wallet = borrow_global<MultiSigWallet>(@wallet_address); assert!(vector::contains(&wallet.owners, &sender), 3); let transactions = borrow_global_mut<Transactions>(@wallet_address); let transaction = vector::borrow_mut(&mut transactions.transactions, tx_id); assert!(!transaction.executed, 4); transaction.confirmations = transaction.confirmations + 1; if (transaction.confirmations >= wallet.required_confirmations) { execute_transaction(tx_id); } } fun execute_transaction(tx_id: u64) acquires Transactions { let transactions = borrow_global_mut<Transactions>(@wallet_address); let transaction = vector::borrow_mut(&mut transactions.transactions, tx_id); assert!(!transaction.executed, 5); coin::transfer<AptosCoin>(@wallet_address, transaction.to, transaction.value); transaction.executed = true; } }",
        "vulnerabilities": [
            "No mechanism to remove or change owners",
            "Lack of transaction cancellation feature"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::nft; struct Listing has store { price: u64, seller: address, } struct Marketplace has key { listings: vector<Listing>, } public fun list_nft(account: &signer, token_id: u64, price: u64) acquires Marketplace { let seller = signer::address_of(account); if (!exists<Marketplace>(@marketplace)) { move_to(account, Marketplace { listings: vector::empty() }); } let marketplace = borrow_global_mut<Marketplace>(@marketplace); vector::push_back(&mut marketplace.listings, Listing { price, seller }); nft::transfer(account, @marketplace, token_id); } public fun buy_nft(account: &signer, token_id: u64) acquires Marketplace { let marketplace = borrow_global_mut<Marketplace>(@marketplace); let listing = vector::pop_back(&mut marketplace.listings); coin::transfer<AptosCoin>(account, listing.seller, listing.price); nft::transfer(@marketplace, signer::address_of(account), token_id); } }",
        "vulnerabilities": [
            "No verification of NFT ownership before listing",
            "Lack of access control for marketplace initialization",
            "Missing checks for duplicate listings",
            "No mechanism to cancel or update listings",
            "Potential front-running in buy_nft function",
            "Missing event emissions for list and buy actions",
            "No fees for the marketplace",
            "Lack of price validation (e.g., minimum price)",
            "No checks for sufficient balance before buying",
            "Centralized control of the marketplace contract"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::nft; struct Listing has key { creator: address, token_id: nft::TokenId, price: u64, } public fun list_nft(seller: &signer, creator: address, collection: vector<u8>, name: vector<u8>, price: u64) { let token_id = nft::create_token_id(creator, collection, name); move_to(seller, Listing { creator, token_id, price }); } public fun buy_nft<CoinType>(buyer: &signer, seller: address) acquires Listing { let listing = move_from<Listing>(seller); let payment = coin::withdraw<CoinType>(buyer, listing.price); coin::deposit(seller, payment); nft::transfer(seller, buyer, listing.creator, listing.token_id); } }",
        "vulnerabilities": [
            "No mechanism to update or cancel listings",
            "Lack of royalty distribution to original creators"
        ]
    },
    {
        "code": "module Voting { use std::signer; struct Proposal has key { description: vector<u8>, yes_votes: u64, no_votes: u64, } public fun create_proposal(creator: &signer, description: vector<u8>) { let sender = signer::address_of(creator); move_to(creator, Proposal { description: description, yes_votes: 0, no_votes: 0 }); } public fun vote(proposal: &mut Proposal, vote: bool) { if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } } }",
        "vulnerabilities": [            "No access control for create_proposal function",            "No mechanism to prevent double voting"        ]
    },
    {
        "code": "module SimpleToken { use aptos_framework::coin; struct Token has store { supply: u64, } public fun mint(account: &signer, amount: u64) acquires Token { let token = borrow_global_mut<Token>(@token_address); token.supply = token.supply + amount; coin::deposit(account, coin::create(amount)); } public fun burn(account: &signer, amount: u64) acquires Token { let token = borrow_global_mut<Token>(@token_address); token.supply = token.supply - amount; coin::withdraw(account, amount); } }",
        "vulnerabilities": [            "No access control for mint function",            "Potential integer overflow in mint and burn functions"        ]
    },
    {
        "code": "module NFT { use aptos_framework::coin; struct Token has key { id: u64, owner: address, } public fun create(account: &signer, id: u64) { let sender = signer::address_of(account); move_to(account, Token { id: id, owner: sender }); } public fun transfer(from: &signer, to: address, id: u64) acquires Token { let sender = signer::address_of(from); let token = borrow_global_mut<Token>(@token_address); assert!(token.owner == sender, 1); token.owner = to; } }",
        "vulnerabilities": [            "No check for existing token ID in create function",            "No access control for transfer function"        ]
    },
    {
        "code": "module Escrow { use std::signer; use aptos_framework::coin; struct Escrow has key { buyer: address, seller: address, amount: u64, } public fun create(account: &signer, seller: address, amount: u64) { let buyer = signer::address_of(account); move_to(account, Escrow { buyer: buyer, seller: seller, amount: amount }); coin::transfer(account, @escrow_address, amount); } public fun release(account: &signer) acquires Escrow { let escrow = borrow_global_mut<Escrow>(@escrow_address); assert!(escrow.buyer == signer::address_of(account), 1); coin::transfer(&escrow.seller, escrow.amount); move_from<Escrow>(@escrow_address); } }",
        "vulnerabilities": [            "No timeout mechanism for escrow",            "No partial release mechanism"        ]
    },
    {
        "code": "module Staking { use aptos_framework::coin; struct Stake has key { amount: u64, reward: u64, } public fun stake(account: &signer, amount: u64) { let sender = signer::address_of(account); move_to(account, Stake { amount: amount, reward: 0 }); coin::transfer(account, @staking_address, amount); } public fun withdraw(account: &signer) acquires Stake { let stake = borrow_global_mut<Stake>(@staking_address); coin::transfer(account, stake.amount + stake.reward); move_from<Stake>(@staking_address); } public fun distribute_rewards(amount: u64) acquires Stake { let stake = borrow_global_mut<Stake>(@staking_address); stake.reward = stake.reward + amount; } }",
        "vulnerabilities": [            
            "No slashing mechanism for misbehaving stakers",            
            "Rewards distribution may be unfair"        
        ]
    },
    {
        "code": "module Auction { use std::signer; use aptos_framework::coin; struct Auction has key { highest_bid: u64, highest_bidder: address, } public fun create(account: &signer, starting_bid: u64) { let sender = signer::address_of(account); move_to(account, Auction { highest_bid: starting_bid, highest_bidder: sender }); } public fun bid(account: &signer, bid_amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@auction_address); assert!(bid_amount > auction.highest_bid, 1); auction.highest_bid = bid_amount; auction.highest_bidder = signer::address_of(account); coin::transfer(account, @auction_address, bid_amount); } public fun end(account: &signer) acquires Auction { let auction = borrow_global<Auction>(@auction_address); assert!(auction.highest_bidder == signer::address_of(account), 1); coin::transfer(account, auction.highest_bid); move_from<Auction>(@auction_address); } }",
        "vulnerabilities": [            
            "No auction timeout mechanism",            
            "No refund mechanism for previous bidders"        
        ]
    },
    {
        "code": "module Lending { use aptos_framework::coin; struct Loan has key { amount: u64, borrower: address, interest: u64, } public fun request_loan(account: &signer, amount: u64, interest: u64) { let borrower = signer::address_of(account); move_to(account, Loan { amount: amount, borrower: borrower, interest: interest }); coin::transfer(account, @loan_address, amount); } public fun repay_loan(account: &signer) acquires Loan { let loan = borrow_global_mut<Loan>(@loan_address); let repayment_amount = loan.amount + loan.interest; coin::transfer(account, repayment_amount); move_from<Loan>(@loan_address); } }",
        "vulnerabilities": [            
            "No collateral mechanism",            
            "Interest rate not validated"        
        ]
    },
    {
        "code": "module Insurance { use aptos_framework::coin; struct Policy has key { premium: u64, payout: u64, policy_holder: address, } public fun create_policy(account: &signer, premium: u64, payout: u64) { let policy_holder = signer::address_of(account); move_to(account, Policy { premium: premium, payout: payout, policy_holder: policy_holder }); coin::transfer(account, @insurance_address, premium); } public fun claim(account: &signer) acquires Policy { let policy = borrow_global_mut<Policy>(@insurance_address); assert!(policy.policy_holder == signer::address_of(account), 1); coin::transfer(account, policy.payout); move_from<Policy>(@insurance_address); } }",
        "vulnerabilities": [            
            "No claim validation mechanism",            
            "Premium amount not validated"        
        ]
    },
    {
        "code": "module Subscription { use aptos_framework::coin; struct Subscription has key { fee: u64, subscriber: address, } public fun subscribe(account: &signer, fee: u64) { let subscriber = signer::address_of(account); move_to(account, Subscription { fee: fee, subscriber: subscriber }); coin::transfer(account, @subscription_address, fee); } public fun cancel(account: &signer) acquires Subscription { let subscription = borrow_global_mut<Subscription>(@subscription_address); assert!(subscription.subscriber == signer::address_of(account), 1); move_from<Subscription>(@subscription_address); } }",
        "vulnerabilities": [            
            "No recurring payment mechanism",            
            "Subscription fee not validated"        
        ]
    },
    {
        "code": "module Payroll { use aptos_framework::coin; struct Payment has key { amount: u64, recipient: address, } public fun create_payment(account: &signer, recipient: address, amount: u64) { move_to(account, Payment { amount: amount, recipient: recipient }); coin::transfer(account, @payroll_address, amount); } public fun release_payment(account: &signer) acquires Payment { let payment = borrow_global_mut<Payment>(@payroll_address); coin::transfer(&payment.recipient, payment.amount); move_from<Payment>(@payroll_address); } }",
        "vulnerabilities": [            
            "No payroll schedule mechanism",            
            "No access control for create_payment function"        
        ]
    },
    {
        "code": "module StakingPool { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Pool<phantom CoinType> has key { total_staked: u64, rewards_per_token: u64, last_update_time: u64, } struct UserStake<phantom CoinType> has key { amount: u64, rewards_paid: u64, } public fun initialize<CoinType>(admin: &signer) { move_to(admin, Pool<CoinType> { total_staked: 0, rewards_per_token: 0, last_update_time: timestamp::now_seconds(), }); } public fun stake<CoinType>(account: &signer, amount: u64) acquires Pool, UserStake { let pool = borrow_global_mut<Pool<CoinType>>(@pool_address); update_rewards<CoinType>(); let coins = coin::withdraw<CoinType>(account, amount); coin::deposit(@pool_address, coins); pool.total_staked = pool.total_staked + amount; if (!exists<UserStake<CoinType>>(signer::address_of(account))) { move_to(account, UserStake<CoinType> { amount: 0, rewards_paid: 0 }); } let user_stake = borrow_global_mut<UserStake<CoinType>>(signer::address_of(account)); user_stake.amount = user_stake.amount + amount; } public fun claim_rewards<CoinType>(account: &signer) acquires Pool, UserStake { update_rewards<CoinType>(); let user_stake = borrow_global_mut<UserStake<CoinType>>(signer::address_of(account)); let pool = borrow_global<Pool<CoinType>>(@pool_address); let rewards = (user_stake.amount * pool.rewards_per_token - user_stake.rewards_paid) / 1e18; coin::transfer<CoinType>(@pool_address, signer::address_of(account), rewards); user_stake.rewards_paid = user_stake.amount * pool.rewards_per_token; } fun update_rewards<CoinType>() acquires Pool { let pool = borrow_global_mut<Pool<CoinType>>(@pool_address); let time_elapsed = timestamp::now_seconds() - pool.last_update_time; if (pool.total_staked > 0) { pool.rewards_per_token = pool.rewards_per_token + (time_elapsed * 1e18) / pool.total_staked; } pool.last_update_time = timestamp::now_seconds(); } }",
        "vulnerabilities": [
            "Potential for precision loss in reward calculations",
            "No slashing mechanism for misbehaving stakers"
        ]
    },
    {
        "code": "module DEX { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: u64, reserve_y: u64, total_shares: u64, } struct LiquidityProviderToken<phantom X, phantom Y> has key { shares: u64, } public fun create_pool<X, Y>(account: &signer, amount_x: u64, amount_y: u64) { assert!(amount_x > 0 && amount_y > 0, 1); let coins_x = coin::withdraw<X>(account, amount_x); let coins_y = coin::withdraw<Y>(account, amount_y); move_to(account, LiquidityPool<X, Y> { reserve_x: amount_x, reserve_y: amount_y, total_shares: (amount_x * amount_y) as u64, }); coin::deposit(@pool_address, coins_x); coin::deposit(@pool_address, coins_y); move_to(account, LiquidityProviderToken<X, Y> { shares: (amount_x * amount_y) as u64, }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool, LiquidityProviderToken { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let shares = std::math::min((amount_x * pool.total_shares) / pool.reserve_x, (amount_y * pool.total_shares) / pool.reserve_y); let coins_x = coin::withdraw<X>(account, amount_x); let coins_y = coin::withdraw<Y>(account, amount_y); coin::deposit(@pool_address, coins_x); coin::deposit(@pool_address, coins_y); pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; pool.total_shares = pool.total_shares + shares; let provider_token = borrow_global_mut<LiquidityProviderToken<X, Y>>(signer::address_of(account)); provider_token.shares = provider_token.shares + shares; } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let amount_out = (amount_in * 997 * pool.reserve_y) / (pool.reserve_x * 1000 + amount_in * 997); assert!(amount_out >= min_amount_out, 2); let coins_in = coin::withdraw<X>(account, amount_in); coin::deposit(@pool_address, coins_in); coin::transfer<Y>(@pool_address, signer::address_of(account), amount_out); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; } }",
        "vulnerabilities": [
            "Lack of price oracle integration for accurate pricing",
            "No mechanism to prevent front-running attacks"
        ]
    },
    {
        "code": "module TimelockGovernance { use std::signer; use aptos_framework::timestamp; struct Proposal has key { id: u64, proposer: address, description: vector<u8>, execution_time: u64, executed: bool, } struct Governance has key { proposals: vector<Proposal>, next_proposal_id: u64, timelock_period: u64, } public fun initialize(admin: &signer, timelock_period: u64) { move_to(admin, Governance { proposals: vector::empty(), next_proposal_id: 0, timelock_period, }); } public fun propose(proposer: &signer, description: vector<u8>) acquires Governance { let governance = borrow_global_mut<Governance>(@governance_address); let proposal = Proposal { id: governance.next_proposal_id, proposer: signer::address_of(proposer), description, execution_time: timestamp::now_seconds() + governance.timelock_period, executed: false, }; vector::push_back(&mut governance.proposals, proposal); governance.next_proposal_id = governance.next_proposal_id + 1; } public fun execute_proposal(executor: &signer, proposal_id: u64) acquires Governance { let governance = borrow_global_mut<Governance>(@governance_address); let proposal = vector::borrow_mut(&mut governance.proposals, proposal_id); assert!(!proposal.executed, 1); assert!(timestamp::now_seconds() >= proposal.execution_time, 2); // Execute proposal logic here proposal.executed = true; } }",
        "vulnerabilities": [
            "No voting mechanism for proposal approval",
            "Lack of cancellation or modification options for proposals"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; use aptos_framework::coin; use aptos_framework::event; struct BridgeEvent has drop, store { amount: u64, from_chain: u8, to_chain: u8, recipient: address, } struct Bridge<phantom CoinType> has key { locked_funds: u64, event_handle: event::EventHandle<BridgeEvent>, } public fun initialize<CoinType>(admin: &signer) { move_to(admin, Bridge<CoinType> { locked_funds: 0, event_handle: event::new_event_handle<BridgeEvent>(admin), }); } public fun lock<CoinType>(account: &signer, amount: u64, to_chain: u8) acquires Bridge { let bridge = borrow_global_mut<Bridge<CoinType>>(@bridge_address); let coins = coin::withdraw<CoinType>(account, amount); coin::deposit(@bridge_address, coins); bridge.locked_funds = bridge.locked_funds + amount; event::emit_event(&mut bridge.event_handle, BridgeEvent { amount, from_chain: 1, to_chain, recipient: signer::address_of(account), }); } public fun unlock<CoinType>(admin: &signer, amount: u64, recipient: address, from_chain: u8) acquires Bridge { let bridge = borrow_global_mut<Bridge<CoinType>>(@bridge_address); assert!(bridge.locked_funds >= amount, 1); bridge.locked_funds = bridge.locked_funds - amount; coin::transfer<CoinType>(@bridge_address, recipient, amount); event::emit_event(&mut bridge.event_handle, BridgeEvent { amount, from_chain, to_chain: 1, recipient, }); } }",
        "vulnerabilities": [
            "Centralized control of bridge operations",
            "No mechanism to verify cross-chain transactions"
        ]
    },
    {
        "code": "module FlashLoan { use std::signer; use aptos_framework::coin; struct FlashLoanProvider<phantom CoinType> has key { available_funds: u64, fee_percentage: u64, } public fun initialize<CoinType>(admin: &signer, initial_funds: u64, fee_percentage: u64) { let coins = coin::withdraw<CoinType>(admin, initial_funds); coin::deposit(@flash_loan_address, coins); move_to(admin, FlashLoanProvider<CoinType> { available_funds: initial_funds, fee_percentage, }); } public fun request_loan<CoinType>(borrower: &signer, amount: u64): u64 acquires FlashLoanProvider { let provider = borrow_global_mut<FlashLoanProvider<CoinType>>(@flash_loan_address); assert!(provider.available_funds >= amount, 1); provider.available_funds = provider.available_funds - amount; coin::transfer<CoinType>(@flash_loan_address, signer::address_of(borrower), amount); amount + (amount * provider.fee_percentage / 10000) } public fun repay_loan<CoinType>(borrower: &signer, amount: u64) acquires FlashLoanProvider { let provider = borrow_global_mut<FlashLoanProvider<CoinType>>(@flash_loan_address); let repayment = coin::withdraw<CoinType>(borrower, amount); coin::deposit(@flash_loan_address, repayment); provider.available_funds = provider.available_funds + amount; } }",
        "vulnerabilities": [
            "No mechanism to enforce loan repayment within the same transaction",
            "Potential for reentrancy attacks"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Market<phantom CoinType> has key { yes_pool: u64, no_pool: u64, resolution_time: u64, resolved: bool, outcome: bool, } struct UserPosition<phantom CoinType> has key { yes_tokens: u64, no_tokens: u64, } public fun create_market<CoinType>(creator: &signer, resolution_time: u64) { move_to(creator, Market<CoinType> { yes_pool: 0, no_pool: 0, resolution_time, resolved: false, outcome: false, }); } public fun bet_yes<CoinType>(bettor: &signer, amount: u64) acquires Market, UserPosition { let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(!market.resolved && timestamp::now_seconds() < market.resolution_time, 1); let coins = coin::withdraw<CoinType>(bettor, amount); coin::deposit(@market_address, coins); market.yes_pool = market.yes_pool + amount; if (!exists<UserPosition<CoinType>>(signer::address_of(bettor))) { move_to(bettor, UserPosition<CoinType> { yes_tokens: 0, no_tokens: 0 }); } let position = borrow_global_mut<UserPosition<CoinType>>(signer::address_of(bettor)); position.yes_tokens = position.yes_tokens + amount; } public fun bet_no<CoinType>(bettor: &signer, amount: u64) acquires Market, UserPosition { let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(!market.resolved && timestamp::now_seconds() < market.resolution_time, 1); let coins = coin::withdraw<CoinType>(bettor, amount); coin::deposit(@market_address, coins); market.no_pool = market.no_pool + amount; if (!exists<UserPosition<CoinType>>(signer::address_of(bettor))) { move_to(bettor, UserPosition<CoinType> { yes_tokens: 0, no_tokens: 0 }); } let position = borrow_global_mut<UserPosition<CoinType>>(signer::address_of(bettor)); position.no_tokens = position.no_tokens + amount; } public fun resolve_market<CoinType>(resolver: &signer, outcome: bool) acquires Market { let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(signer::address_of(resolver) == @market_address, 2); assert!(!market.resolved && timestamp::now_seconds() >= market.resolution_time, 3); market.resolved = true; market.outcome = outcome; } public fun claim_winnings<CoinType>(claimer: &signer) acquires Market, UserPosition { let market = borrow_global<Market<CoinType>>(@market_address); assert!(market.resolved, 4); let position = borrow_global_mut<UserPosition<CoinType>>(signer::address_of(claimer)); let winnings = if (market.outcome) { (position.yes_tokens * (market.yes_pool + market.no_pool)) / market.yes_pool } else { (position.no_tokens * (market.yes_pool + market.no_pool)) / market.no_pool }; coin::transfer<CoinType>(@market_address, signer::address_of(claimer), winnings); position.yes_tokens = 0; position.no_tokens = 0; } }",
        "vulnerabilities": [
            "Centralized market resolution",
            "No mechanism to handle market cancellation or ties"
        ]
    },
    {
        "code": "module TokenSwap { struct LiquidityPool has key { token_a_reserve: u64, token_b_reserve: u64, } public fun initialize_pool(creator: &signer) { move_to(creator, LiquidityPool { token_a_reserve: 0, token_b_reserve: 0 }); } public fun swap_tokens(account: &signer, amount_in: u64, token_type: bool) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); if (token_type) { pool.token_a_reserve += amount_in; // Calculate and transfer token B } else { pool.token_b_reserve += amount_in; // Calculate and transfer token A } } }",
        "vulnerabilities": [
            "No slippage protection",
            "Potential for front-running attacks",
            "Lack of access control for pool initialization"
        ]
    },
    {
        "code": "module NFTMarketplace { struct Listing has key { creator: address, price: u64, is_active: bool, } public fun create_listing(creator: &signer, token_id: u64, price: u64) { move_to(creator, Listing { creator: signer::address_of(creator), price, is_active: true }); } public fun buy_nft(buyer: &signer, token_id: u64) acquires Listing { let listing = borrow_global_mut<Listing>(@listing_address); assert!(listing.is_active, 101); // Transfer NFT and payment logic here listing.is_active = false; } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow system for secure transactions",
            "No mechanism to update listing price"
        ]
    },
    {
        "code": "module StakingRewards { struct StakeInfo has key { amount: u64, reward_debt: u64, } public fun stake(account: &signer, amount: u64) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); stake_info.amount += amount; update_reward_debt(stake_info); } public fun claim_rewards(account: &signer) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); let pending_reward = calculate_pending_reward(stake_info); // Transfer reward logic here update_reward_debt(stake_info); } }",
        "vulnerabilities": [
            "Potential for reward calculation errors",
            "Lack of time-lock for staked tokens",
            "No mechanism to adjust reward rates"
        ]
    },
    {
        "code": "module Governance { struct Proposal has key { proposer: address, for_votes: u64, against_votes: u64, execution_time: u64, } public fun create_proposal(proposer: &signer, description: vector<u8>) { move_to(proposer, Proposal { proposer: signer::address_of(proposer), for_votes: 0, against_votes: 0, execution_time: 0 }); } public fun vote(voter: &signer, proposal_id: u64, support: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@proposal_address); if (support) { proposal.for_votes += get_voting_power(voter); } else { proposal.against_votes += get_voting_power(voter); } } }",
        "vulnerabilities": [
            "No quorum requirements for proposal passing",
            "Lack of time-lock for proposal execution",
            "Potential for governance attacks with token concentration"
        ]
    },
    {
        "code": "module FlashLoan { struct LendingPool has key { total_liquidity: u64, } public fun flash_loan(borrower: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool>(@pool_address); assert!(pool.total_liquidity >= amount, 102); pool.total_liquidity -= amount; // Transfer tokens to borrower // Execute borrower's code here assert!(pool.total_liquidity + amount + fee <= balance(@pool_address), 103); pool.total_liquidity += amount + fee; } }",
        "vulnerabilities": [
            "Reentrancy risk in borrower's code execution",
            "Lack of access control for flash loan initiation",
            "Potential for liquidity drainage attacks"
        ]
    },
    {
        "code": "module Timelock { struct TimelockTreasury has key { release_time: u64, beneficiary: address, amount: u64, } public fun create_timelock(creator: &signer, beneficiary: address, amount: u64, lock_duration: u64) { let release_time = timestamp::now_seconds() + lock_duration; move_to(creator, TimelockTreasury { release_time, beneficiary, amount }); } public fun release_funds(account: &signer) acquires TimelockTreasury { let timelock = borrow_global_mut<TimelockTreasury>(@timelock_address); assert!(signer::address_of(account) == timelock.beneficiary, 104); assert!(timestamp::now_seconds() >= timelock.release_time, 105); // Transfer funds to beneficiary } }",
        "vulnerabilities": [
            "No mechanism to change beneficiary",
            "Lack of partial fund release option",
            "Potential for funds to be locked indefinitely if beneficiary key is lost"
        ]
    },
    {
        "code": "module CrossChainBridge { struct BridgePool has key { locked_funds: u64, } public fun lock_funds(account: &signer, amount: u64) acquires BridgePool { let pool = borrow_global_mut<BridgePool>(@bridge_address); pool.locked_funds += amount; // Emit event for cross-chain monitoring } public fun release_funds(validator: &signer, recipient: address, amount: u64) acquires BridgePool { assert!(is_validator(validator), 106); let pool = borrow_global_mut<BridgePool>(@bridge_address); assert!(pool.locked_funds >= amount, 107); pool.locked_funds -= amount; // Transfer funds to recipient } }",
        "vulnerabilities": [
            "Centralization risk with validator control",
            "Lack of multi-sig or threshold signature scheme",
            "Potential for bridge contract bugs leading to fund loss"
        ]
    },
    {
        "code": "module PredictionMarket { struct Market has key { outcome_a_stake: u64, outcome_b_stake: u64, resolution_time: u64, } public fun create_market(creator: &signer, resolution_time: u64) { move_to(creator, Market { outcome_a_stake: 0, outcome_b_stake: 0, resolution_time }); } public fun place_bet(account: &signer, amount: u64, outcome: bool) acquires Market { let market = borrow_global_mut<Market>(@market_address); if (outcome) { market.outcome_a_stake += amount; } else { market.outcome_b_stake += amount; } } }",
        "vulnerabilities": [
            "Lack of oracle for result verification",
            "No mechanism for market fee or creator incentive",
            "Potential for market manipulation with large stakes"
        ]
    },
    {
        "code": "module DAO { struct DAOConfig has key { proposal_threshold: u64, voting_period: u64, } struct Proposal has key { proposer: address, for_votes: u64, against_votes: u64, executed: bool, } public fun create_proposal(proposer: &signer, description: vector<u8>) acquires DAOConfig { let config = borrow_global<DAOConfig>(@dao_address); assert!(get_voting_power(proposer) >= config.proposal_threshold, 108); move_to(proposer, Proposal { proposer: signer::address_of(proposer), for_votes: 0, against_votes: 0, executed: false }); } }",
        "vulnerabilities": [
            "Lack of vote delegation mechanism",
            "No protection against flash loan governance attacks",
            "Potential for proposal spam with low threshold"
        ]
    },
    {
        "code": "module YieldFarming { struct Farm has key { total_staked: u64, reward_per_token: u64, last_update_time: u64, } struct UserInfo has key { amount: u64, reward_debt: u64, } public fun stake(account: &signer, amount: u64) acquires Farm, UserInfo { let farm = borrow_global_mut<Farm>(@farm_address); let user_info = borrow_global_mut<UserInfo>(signer::address_of(account)); update_pool(farm); harvest(farm, user_info); user_info.amount += amount; user_info.reward_debt = user_info.amount * farm.reward_per_token; farm.total_staked += amount; } }",
        "vulnerabilities": [
            "Potential for reward calculation errors due to precision loss",
            "Lack of cap on total rewards or emission rate",
            "No mechanism to pause farming in case of emergency"
        ]
    },
    {
        "code": "module LiquidationBot { struct LoanPosition has key { collateral_amount: u64, borrowed_amount: u64, liquidation_threshold: u64, } public fun liquidate(liquidator: &signer, borrower: address) acquires LoanPosition { let position = borrow_global_mut<LoanPosition>(borrower); let current_price = get_oracle_price(); assert!(is_liquidatable(position, current_price), 109); // Liquidation logic: transfer collateral to liquidator and repay debt } }",
        "vulnerabilities": [
            "Dependence on centralized price oracle",
            "Potential for front-running liquidation transactions",
            "Lack of partial liquidation mechanism"
        ]
    },
    {
        "code": "module DutchAuction { struct Auction has key { start_price: u64, end_price: u64, start_time: u64, end_time: u64, token_id: u64, } public fun create_auction(creator: &signer, token_id: u64, start_price: u64, end_price: u64, duration: u64) { let start_time = timestamp::now_seconds(); move_to(creator, Auction { start_price, end_price, start_time, end_time: start_time + duration, token_id }); } public fun buy(buyer: &signer) acquires Auction { let auction = borrow_global_mut<Auction>(@auction_address); let current_price = calculate_current_price(auction); // Transfer NFT and handle payment } }",
        "vulnerabilities": [
            "No mechanism to cancel or update auction parameters",
            "Potential for sniping at the end of the auction",
            "Lack of minimum price protection for the seller"
        ]
    },
    {
        "code": "module SyntheticAsset { struct SyntheticToken has key { oracle_price: u64, collateral_ratio: u64, total_supply: u64, } public fun mint(account: &signer, collateral_amount: u64) acquires SyntheticToken { let synth = borrow_global_mut<SyntheticToken>(@synth_address); let mint_amount = (collateral_amount * synth.oracle_price) / synth.collateral_ratio; synth.total_supply += mint_amount; // Transfer synthetic tokens to account } }",
        "vulnerabilities": [
            "Oracle manipulation risks",
            "Potential for over-collateralization in volatile markets",
            "Lack of liquidation mechanism for undercollateralized positions"
        ]
    },
    {
        "code": "module RecurringPayment { struct Subscription has key { recipient: address, amount: u64, interval: u64, last_payment: u64, } public fun create_subscription(creator: &signer, recipient: address, amount: u64, interval: u64) { move_to(creator, Subscription { recipient, amount, interval, last_payment: timestamp::now_seconds() }); } public fun process_payment(processor: &signer) acquires Subscription { let sub = borrow_global_mut<Subscription>(@subscription_address); assert!(timestamp::now_seconds() >= sub.last_payment + sub.interval, 110); // Transfer payment and update last_payment } }",
        "vulnerabilities": [
            "No mechanism to cancel or modify subscriptions",
            "Potential for missed payments if not called regularly",
            "Lack of balance check before processing payment"
        ]
    },
    {
        "code": "module RandomNumberGenerator { use std::hash; struct VRFConfig has key { seed: vector<u8>, last_block: u64, } public fun request_random(account: &signer) acquires VRFConfig { let config = borrow_global_mut<VRFConfig>(@vrf_address); let current_block = block::get_current_block_height(); assert!(current_block > config.last_block, 111); let seed = hash::sha3_256(config.seed); // Generate and return random number config.seed = seed; config.last_block = current_block; } }",
        "vulnerabilities": [
            "Predictability of randomness due to on-chain data",
            "Potential for miner manipulation of block data",
            "Lack of external entropy source"
        ]
    },
    {
        "code": "module DEX { struct LiquidityPool has key { token_a_reserve: u64, token_b_reserve: u64, lp_token_supply: u64 } public fun swap(account: &signer, amount_in: u64, token_in: address, token_out: address) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@dex_address); let amount_out = (amount_in * pool.token_b_reserve) / (pool.token_a_reserve + amount_in); // Transfer tokens } }",
        "vulnerabilities": [
            "Front-running attacks",
            "Impermanent loss for liquidity providers",
            "Potential for flash loan attacks"
        ]
    },
    {
        "code": "module NFTMarketplace { struct Listing has key { token_id: u64, price: u64, seller: address } public fun create_listing(account: &signer, token_id: u64, price: u64) { let listing = Listing { token_id, price, seller: Signer::address_of(account) }; move_to(account, listing); } public fun buy_nft(buyer: &signer, token_id: u64) acquires Listing { let listing = move_from<Listing>(token_id); // Transfer NFT and payment } }",
        "vulnerabilities": [
            "Lack of royalty mechanism for original creators",
            "Potential for wash trading to manipulate prices",
            "No mechanism to handle disputed transactions"
        ]
    },
    {
        "code": "module Governance { struct Proposal has key { id: u64, description: vector<u8>, votes_for: u64, votes_against: u64, status: u8 } public fun create_proposal(account: &signer, description: vector<u8>) { let proposal = Proposal { id: get_next_id(), description, votes_for: 0, votes_against: 0, status: 0 }; move_to(account, proposal); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_id); if (vote) proposal.votes_for += 1 else proposal.votes_against += 1; } }",
        "vulnerabilities": [
            "Potential for governance attacks with large token holders",
            "Lack of quorum requirements for proposal execution",
            "No time-lock mechanism for implemented changes"
        ]
    },
    {
        "code": "module StableCoin { struct ReservePool has key { collateral_amount: u64, stablecoin_supply: u64 } public fun mint_stablecoin(account: &signer, collateral_amount: u64) acquires ReservePool { let reserve = borrow_global_mut<ReservePool>(@stablecoin_address); let mint_amount = collateral_amount * 2; // 200% collateralization reserve.collateral_amount += collateral_amount; reserve.stablecoin_supply += mint_amount; // Transfer stablecoins to account } }",
        "vulnerabilities": [
            "Reliance on external price feeds for collateral valuation",
            "Potential for bank run in extreme market conditions",
            "Lack of dynamic interest rates to manage supply and demand"
        ]
    },
    {
        "code": "module Lending { struct LendingPool has key { total_borrowed: u64, total_supplied: u64, interest_rate: u64 } public fun borrow(account: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool>(@lending_address); assert!(pool.total_supplied >= pool.total_borrowed + amount, 101); pool.total_borrowed += amount; // Transfer borrowed amount to account } }",
        "vulnerabilities": [
            "Interest rate manipulation risks",
            "Potential for uncollateralized loans",
            "Lack of liquidation mechanism for underwater positions"
        ]
    },
    {
        "code": "module Insurance { struct PolicyPool has key { total_premiums: u64, total_payouts: u64, active_policies: u64 } public fun create_policy(account: &signer, premium: u64) acquires PolicyPool { let pool = borrow_global_mut<PolicyPool>(@insurance_address); pool.total_premiums += premium; pool.active_policies += 1; // Create and store policy for account } public fun claim_payout(account: &signer, amount: u64) acquires PolicyPool { let pool = borrow_global_mut<PolicyPool>(@insurance_address); assert!(pool.total_premiums >= pool.total_payouts + amount, 102); pool.total_payouts += amount; // Transfer payout to account } }",
        "vulnerabilities": [
            "Potential for fraudulent claims",
            "Risk of insolvency in case of correlated claim events",
            "Lack of risk assessment mechanism for policy pricing"
        ]
    },
    {
        "code": "module Prediction { struct PredictionMarket has key { outcome_a_stake: u64, outcome_b_stake: u64, resolution_time: u64 } public fun place_bet(account: &signer, outcome: bool, amount: u64) acquires PredictionMarket { let market = borrow_global_mut<PredictionMarket>(@prediction_address); if (outcome) market.outcome_a_stake += amount else market.outcome_b_stake += amount; // Transfer stake from account } public fun resolve_market(oracle: &signer, outcome: bool) acquires PredictionMarket { let market = borrow_global_mut<PredictionMarket>(@prediction_address); assert!(Timestamp::now_seconds() >= market.resolution_time, 103); // Distribute winnings based on outcome } }",
        "vulnerabilities": [
            "Centralization risk with single oracle for resolution",
            "Potential for market manipulation with large bets",
            "Lack of mechanism to handle disputed outcomes"
        ]
    },
    {
        "code": "module DAO { struct Member has key { voting_power: u64, proposal_count: u64 } public fun create_proposal(account: &signer, description: vector<u8>) acquires Member { let member = borrow_global_mut<Member>(Signer::address_of(account)); assert!(member.voting_power >= 100, 104); // Minimum voting power required member.proposal_count += 1; // Create and store proposal } public fun vote(voter: &signer, proposal_id: u64, support: bool) acquires Member { let member = borrow_global<Member>(Signer::address_of(voter)); // Cast vote with weight equal to voting_power } }",
        "vulnerabilities": [
            "Plutocracy risks with wealth-based voting power",
            "Potential for proposal spamming",
            "Lack of delegation mechanism for voting power"
        ]
    },
    {
        "code": "module CrossChainBridge { struct Bridge has key { locked_funds: u64, pending_withdrawals: vector<Withdrawal> } struct Withdrawal { recipient: address, amount: u64, chain_id: u8 } public fun lock_funds(account: &signer, amount: u64, target_chain: u8) acquires Bridge { let bridge = borrow_global_mut<Bridge>(@bridge_address); bridge.locked_funds += amount; // Emit event for off-chain relayers } public fun process_withdrawal(relayer: &signer, recipient: address, amount: u64, chain_id: u8) acquires Bridge { let bridge = borrow_global_mut<Bridge>(@bridge_address); // Verify relayer signature and process withdrawal } }",
        "vulnerabilities": [
            "Centralization risks with trusted relayers",
            "Potential for double-spending across chains",
            "Lack of mechanism to handle failed withdrawals on target chain"
        ]
    },
    {
        "code": "module Escrow { struct EscrowContract has key { seller: address, buyer: address, amount: u64, status: u8 } public fun create_escrow(seller: &signer, buyer: address, amount: u64) { let escrow = EscrowContract { seller: Signer::address_of(seller), buyer, amount, status: 0 }; move_to(seller, escrow); } public fun release_funds(account: &signer) acquires EscrowContract { let escrow = borrow_global_mut<EscrowContract>(Signer::address_of(account)); assert!(Signer::address_of(account) == escrow.buyer, 105); escrow.status = 1; // Transfer funds to seller } }",
        "vulnerabilities": [
            "Lack of dispute resolution mechanism",
            "No time-based auto-refund for unreleased escrows",
            "Potential for front-running on release transactions"
        ]
    },
    {
        "code": "module Governance { use std::signer; use aptos_framework::coin; struct Proposal has key { description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64, } struct VoteRecord has key { voted: bool, } public fun create_proposal(account: &signer, description: vector<u8>, duration: u64) { let proposal_address = signer::address_of(account); move_to(account, Proposal { description, yes_votes: 0, no_votes: 0, end_time: timestamp::now_seconds() + duration, }); } public fun vote(account: &signer, proposal_address: address, vote: bool) acquires Proposal, VoteRecord { let voter = signer::address_of(account); assert!(!exists<VoteRecord>(voter), 1); move_to(account, VoteRecord { voted: true }); let proposal = borrow_global_mut<Proposal>(proposal_address); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } } public fun execute_proposal(proposal_address: address) acquires Proposal { let proposal = borrow_global<Proposal>(proposal_address); assert!(timestamp::now_seconds() > proposal.end_time, 2); assert!(proposal.yes_votes > proposal.no_votes, 3); // Execute proposal logic here } }",
        "vulnerabilities": [
            "No minimum quorum for proposal execution",
            "Lack of access control for proposal creation",
            "Missing checks for proposal uniqueness",
            "No mechanism to cancel or update proposals",
            "Potential for last-minute voting attacks",
            "Missing event emissions for proposal and vote actions",
            "No token-weighted voting system",
            "Lack of time-lock for proposal execution",
            "No checks for voter eligibility (e.g., token holdings)",
            "Centralized control of the governance contract"
        ]
    },
    {
        "code": "module TokenSwap { struct LiquidityPool has key { token_a_reserve: u64, token_b_reserve: u64, lp_token_supply: u64 } public fun create_pool(creator: &signer, initial_a: u64, initial_b: u64) { let pool = LiquidityPool { token_a_reserve: initial_a, token_b_reserve: initial_b, lp_token_supply: 0 }; move_to(creator, pool); } public fun swap_a_to_b(account: &signer, amount_in: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); let amount_out = (amount_in * pool.token_b_reserve) / (pool.token_a_reserve + amount_in); pool.token_a_reserve = pool.token_a_reserve + amount_in; pool.token_b_reserve = pool.token_b_reserve - amount_out; // Transfer tokens } }",
        "vulnerabilities": [
            "No slippage protection",
            "Susceptible to flash loan attacks",
            "Lack of access control for pool creation"
        ]
    },
    {
        "code": "module NFTMarketplace { struct Listing has key { creator: address, price: u64, is_active: bool } public fun create_listing(creator: &signer, token_id: u64, price: u64) { let listing = Listing { creator: signer::address_of(creator), price, is_active: true }; move_to(creator, listing); } public fun buy_nft(buyer: &signer, token_id: u64) acquires Listing { let listing = borrow_global_mut<Listing>(token_id); assert!(listing.is_active, 101); // Transfer NFT and funds listing.is_active = false; } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow for secure transactions",
            "No mechanism to update listing price"
        ]
    },
    {
        "code": "module GovernanceDAO { struct Proposal has key { proposer: address, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64 } public fun create_proposal(proposer: &signer, description: vector<u8>, voting_period: u64) { let proposal = Proposal { proposer: signer::address_of(proposer), description, yes_votes: 0, no_votes: 0, end_time: timestamp::now_seconds() + voting_period }; move_to(proposer, proposal); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_id); assert!(timestamp::now_seconds() < proposal.end_time, 102); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } } }",
        "vulnerabilities": [
            "No quorum requirement for proposal passing",
            "Lack of vote weight based on token holdings",
            "No mechanism to prevent double voting"
        ]
    },
    {
        "code": "module TokenStaking { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakingPool<phantom TokenType> has key { total_staked: u64, reward_rate: u64, last_update_time: u64 } struct UserStake<phantom TokenType> has key { amount: u64, last_claim_time: u64 } public fun initialize<TokenType>(admin: &signer, initial_reward_rate: u64) { let sender = signer::address_of(admin); assert!(!exists<StakingPool<TokenType>>(sender), 1); move_to(admin, StakingPool<TokenType> { total_staked: 0, reward_rate: initial_reward_rate, last_update_time: timestamp::now_seconds() }); } public fun stake<TokenType>(account: &signer, amount: u64) acquires StakingPool, UserStake { let sender = signer::address_of(account); let pool = borrow_global_mut<StakingPool<TokenType>>(sender); pool.total_staked = pool.total_staked + amount; if (!exists<UserStake<TokenType>>(sender)) { move_to(account, UserStake<TokenType> { amount: 0, last_claim_time: timestamp::now_seconds() }); } let user_stake = borrow_global_mut<UserStake<TokenType>>(sender); user_stake.amount = user_stake.amount + amount; coin::transfer<TokenType>(account, sender, amount); } public fun unstake<TokenType>(account: &signer, amount: u64) acquires StakingPool, UserStake { let sender = signer::address_of(account); let pool = borrow_global_mut<StakingPool<TokenType>>(sender); let user_stake = borrow_global_mut<UserStake<TokenType>>(sender); assert!(user_stake.amount >= amount, 2); pool.total_staked = pool.total_staked - amount; user_stake.amount = user_stake.amount - amount; coin::transfer<TokenType>(account, sender, amount); } public fun claim_rewards<TokenType>(account: &signer) acquires StakingPool, UserStake { let sender = signer::address_of(account); let pool = borrow_global<StakingPool<TokenType>>(sender); let user_stake = borrow_global_mut<UserStake<TokenType>>(sender); let time_elapsed = timestamp::now_seconds() - user_stake.last_claim_time; let reward = (user_stake.amount * pool.reward_rate * time_elapsed) / 1000000; user_stake.last_claim_time = timestamp::now_seconds(); coin::transfer<TokenType>(account, sender, reward); } }",
        "vulnerabilities": [
            "No access control for initialization function",
            "Potential integer overflow in reward calculation",
            "Lack of slippage protection for staking and unstaking",
            "No mechanism to update reward rate",
            "Missing event emissions for important actions",
            "Centralization risk with single pool design",
            "No checks for contract pause or emergency scenarios",
            "Potential reentrancy in stake and unstake functions",
            "Lack of minimum stake amount check",
            "No time lock for unstaking"
        ]
    },
    {
        "code": "module StableCoin { struct ReservePool has key { collateral_amount: u64, stablecoin_supply: u64 } public fun mint_stablecoin(account: &signer, collateral_amount: u64) acquires ReservePool { let pool = borrow_global_mut<ReservePool>(@reserve_address); let mint_amount = collateral_amount * 2; // 200% collateralization ratio pool.collateral_amount = pool.collateral_amount + collateral_amount; pool.stablecoin_supply = pool.stablecoin_supply + mint_amount; // Mint stablecoins to account } public fun redeem_collateral(account: &signer, stablecoin_amount: u64) acquires ReservePool { let pool = borrow_global_mut<ReservePool>(@reserve_address); let collateral_to_return = stablecoin_amount / 2; pool.collateral_amount = pool.collateral_amount - collateral_to_return; pool.stablecoin_supply = pool.stablecoin_supply - stablecoin_amount; // Burn stablecoins and return collateral } }",
        "vulnerabilities": [
            "No price oracle for collateral valuation",
            "Fixed collateralization ratio may not adapt to market conditions",
            "Lack of liquidation mechanism for undercollateralized positions"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Auction<phantom TokenType> has key { beneficiary: address, highest_bidder: address, highest_bid: u64, end_time: u64, ended: bool } public fun create_auction<TokenType>(creator: &signer, beneficiary: address, auction_duration: u64) { let sender = signer::address_of(creator); assert!(!exists<Auction<TokenType>>(sender), 1); move_to(creator, Auction<TokenType> { beneficiary, highest_bidder: sender, highest_bid: 0, end_time: timestamp::now_seconds() + auction_duration, ended: false }); } public fun bid<TokenType>(bidder: &signer, amount: u64) acquires Auction { let sender = signer::address_of(bidder); let auction = borrow_global_mut<Auction<TokenType>>(sender); assert!(!auction.ended && timestamp::now_seconds() < auction.end_time, 2); assert!(amount > auction.highest_bid, 3); if (auction.highest_bid != 0) { coin::transfer<TokenType>(bidder, auction.highest_bidder, auction.highest_bid); } auction.highest_bidder = sender; auction.highest_bid = amount; coin::transfer<TokenType>(bidder, sender, amount); } public fun end_auction<TokenType>(ender: &signer) acquires Auction { let sender = signer::address_of(ender); let auction = borrow_global_mut<Auction<TokenType>>(sender); assert!(!auction.ended && timestamp::now_seconds() >= auction.end_time, 4); auction.ended = true; coin::transfer<TokenType>(ender, auction.beneficiary, auction.highest_bid); } }",
        "vulnerabilities": [
            "No mechanism to cancel or update auction",
            "Lack of access control for ending the auction",
            "Potential for front-running in bid function",
            "No minimum bid increment enforced",
            "Missing event emissions for bids and auction end",
            "Centralization risk with single auction contract",
            "No slippage protection for bids",
            "Potential reentrancy in bid function",
            "Lack of checks for zero address in beneficiary",
            "No mechanism to handle tied bids"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Listing has key { creator: address, price: u64, expiration: u64 } struct NFT has key { id: u64, owner: address } public fun create_nft(creator: &signer, id: u64) { let sender = signer::address_of(creator); assert!(!exists<NFT>(sender), 1); move_to(creator, NFT { id, owner: sender }); } public fun list_nft(seller: &signer, nft_id: u64, price: u64, duration: u64) acquires NFT { let sender = signer::address_of(seller); let nft = borrow_global_mut<NFT>(sender); assert!(nft.owner == sender, 2); move_to(seller, Listing { creator: sender, price, expiration: timestamp::now_seconds() + duration }); } public fun buy_nft<CoinType>(buyer: &signer, nft_id: u64) acquires NFT, Listing { let sender = signer::address_of(buyer); let nft = borrow_global_mut<NFT>(sender); let listing = move_from<Listing>(nft.owner); assert!(timestamp::now_seconds() < listing.expiration, 3); coin::transfer<CoinType>(buyer, listing.creator, listing.price); nft.owner = sender; } public fun cancel_listing(seller: &signer, nft_id: u64) acquires Listing { let sender = signer::address_of(seller); let listing = move_from<Listing>(sender); } }",
        "vulnerabilities": [
            "Lack of royalty mechanism for original creators",
            "No checks for NFT ownership in buy function",
            "Potential integer overflow in expiration calculation",
            "Missing event emissions for listings and sales",
            "No mechanism to update listing price or duration",
            "Centralization risk with single marketplace contract",
            "Lack of access control for cancelling listings",
            "No slippage protection for purchases",
            "Potential reentrancy in buy_nft function",
            "Missing checks for zero values in price and duration"
        ]
    },

    {
        "code": "module DeFiLending { struct LendingPool has key { total_borrows: u64, total_deposits: u64, interest_rate: u64 } public fun deposit(account: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool>(@pool_address); pool.total_deposits = pool.total_deposits + amount; // Transfer tokens to pool } public fun borrow(account: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool>(@pool_address); assert!(amount <= pool.total_deposits - pool.total_borrows, 103); pool.total_borrows = pool.total_borrows + amount; // Transfer tokens to borrower } }",
        "vulnerabilities": [
            "No collateral requirement for borrowing",
            "Fixed interest rate not adapting to utilization",
            "Lack of borrowing limits per user"
        ]
    },
    {
        "code": "module PredictionMarket { struct Market has key { question: vector<u8>, yes_stake: u64, no_stake: u64, resolution_time: u64 } public fun create_market(creator: &signer, question: vector<u8>, resolution_time: u64) { let market = Market { question, yes_stake: 0, no_stake: 0, resolution_time }; move_to(creator, market); } public fun place_bet(account: &signer, market_id: u64, bet_amount: u64, bet_yes: bool) acquires Market { let market = borrow_global_mut<Market>(market_id); assert!(timestamp::now_seconds() < market.resolution_time, 104); if (bet_yes) { market.yes_stake = market.yes_stake + bet_amount; } else { market.no_stake = market.no_stake + bet_amount; } // Transfer tokens } }",
        "vulnerabilities": [
            "No mechanism for resolving markets",
            "Lack of fee structure for market creators",
            "Potential for market manipulation with large bets"
        ]
    },
    {
        "code": "module CrossChainBridge { struct BridgeReserve has key { locked_tokens: u64 } public fun lock_tokens(account: &signer, amount: u64) acquires BridgeReserve { let reserve = borrow_global_mut<BridgeReserve>(@bridge_address); reserve.locked_tokens = reserve.locked_tokens + amount; // Transfer tokens to bridge } public fun release_tokens(account: &signer, amount: u64, proof: vector<u8>) acquires BridgeReserve { let reserve = borrow_global_mut<BridgeReserve>(@bridge_address); assert!(verify_proof(proof), 105); reserve.locked_tokens = reserve.locked_tokens - amount; // Transfer tokens to account } }",
        "vulnerabilities": [
            "Centralized proof verification",
            "No rate limiting on token releases",
            "Lack of multi-sig for large transfers"
        ]
    },
    {
        "code": "module DEX { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom TokenX, phantom TokenY> has key { reserve_x: u64, reserve_y: u64, total_shares: u64 } struct LiquidityProvider<phantom TokenX, phantom TokenY> has key { shares: u64 } public fun create_pool<TokenX, TokenY>(creator: &signer) { let sender = signer::address_of(creator); assert!(!exists<LiquidityPool<TokenX, TokenY>>(sender), 1); move_to(creator, LiquidityPool<TokenX, TokenY> { reserve_x: 0, reserve_y: 0, total_shares: 0 }); } public fun add_liquidity<TokenX, TokenY>(provider: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool, LiquidityProvider { let sender = signer::address_of(provider); let pool = borrow_global_mut<LiquidityPool<TokenX, TokenY>>(sender); let shares = if (pool.total_shares == 0) { (amount_x * amount_y) as u64 } else { std::math::min((amount_x * pool.total_shares) / pool.reserve_x, (amount_y * pool.total_shares) / pool.reserve_y) }; pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; pool.total_shares = pool.total_shares + shares; if (!exists<LiquidityProvider<TokenX, TokenY>>(sender)) { move_to(provider, LiquidityProvider<TokenX, TokenY> { shares: 0 }); } let lp = borrow_global_mut<LiquidityProvider<TokenX, TokenY>>(sender); lp.shares = lp.shares + shares; coin::transfer<TokenX>(provider, sender, amount_x); coin::transfer<TokenY>(provider, sender, amount_y); } public fun swap<TokenX, TokenY>(trader: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let sender = signer::address_of(trader); let pool = borrow_global_mut<LiquidityPool<TokenX, TokenY>>(sender); let amount_out = (amount_in * 997 * pool.reserve_y) / (pool.reserve_x * 1000 + amount_in * 997); assert!(amount_out >= min_amount_out, 2); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; coin::transfer<TokenX>(trader, sender, amount_in); coin::transfer<TokenY>(sender, trader, amount_out); } }",
        "vulnerabilities": [
            "Lack of access control for pool creation",
            "Potential integer overflow in liquidity calculations",
            "No mechanism to remove liquidity",
            "Missing checks for minimum liquidity",
            "Lack of price oracle integration",
            "Centralization risk with single pool per token pair",
            "No slippage protection for liquidity provision",
            "Potential reentrancy in swap function",
            "Missing event emissions for important actions",
            "No mechanism to pause trading or liquidity provision"
        ]
    },
    {
        "code": "module TimelockVault { struct Vault has key { owner: address, balance: u64, unlock_time: u64 } public fun create_vault(creator: &signer, unlock_time: u64) { let vault = Vault { owner: signer::address_of(creator), balance: 0, unlock_time }; move_to(creator, vault); } public fun deposit(account: &signer, amount: u64) acquires Vault { let vault = borrow_global_mut<Vault>(signer::address_of(account)); vault.balance = vault.balance + amount; // Transfer tokens to vault } public fun withdraw(account: &signer, amount: u64) acquires Vault { let vault = borrow_global_mut<Vault>(signer::address_of(account)); assert!(timestamp::now_seconds() >= vault.unlock_time, 106); assert!(amount <= vault.balance, 107); vault.balance = vault.balance - amount; // Transfer tokens to account } }",
        "vulnerabilities": [
            "No mechanism to extend lock time",
            "Lack of emergency withdrawal feature",
            "All-or-nothing withdrawal may be inflexible"
        ]
    },
    {
        "code": "module RandomizedNFTMint { use std::hash; struct MintInfo has key { total_supply: u64, minted: u64, price: u64 } public fun initialize_mint(creator: &signer, total_supply: u64, price: u64) { let info = MintInfo { total_supply, minted: 0, price }; move_to(creator, info); } public fun mint_nft(account: &signer) acquires MintInfo { let info = borrow_global_mut<MintInfo>(@mint_address); assert!(info.minted < info.total_supply, 108); let seed = hash::sha3_256(bcs::to_bytes(&timestamp::now_microseconds())); // Use seed to determine NFT traits info.minted = info.minted + 1; // Mint NFT with randomized traits } }",
        "vulnerabilities": [
            "Predictable randomness based on timestamp",
            "No mechanism to update mint price",
            "Lack of whitelist or presale functionality"
        ]
    },
    {
        "code": "module GovernanceToken { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Proposal has key { id: u64, creator: address, description: vector<u8>, votes_for: u64, votes_against: u64, end_time: u64, executed: bool } struct UserVote has key { proposals: vector<u64> } public fun create_proposal(creator: &signer, description: vector<u8>, voting_period: u64) { let sender = signer::address_of(creator); let proposal_id = get_next_proposal_id(); move_to(creator, Proposal { id: proposal_id, creator: sender, description, votes_for: 0, votes_against: 0, end_time: timestamp::now_seconds() + voting_period, executed: false }); } public fun vote<TokenType>(voter: &signer, proposal_id: u64, vote_for: bool) acquires Proposal, UserVote { let sender = signer::address_of(voter); let proposal = borrow_global_mut<Proposal>(sender); assert!(timestamp::now_seconds() < proposal.end_time, 1); let vote_amount = coin::balance<TokenType>(sender); if (vote_for) { proposal.votes_for = proposal.votes_for + vote_amount; } else { proposal.votes_against = proposal.votes_against + vote_amount; } if (!exists<UserVote>(sender)) { move_to(voter, UserVote { proposals: vector::empty() }); } let user_vote = borrow_global_mut<UserVote>(sender); vector::push_back(&mut user_vote.proposals, proposal_id); } public fun execute_proposal(executor: &signer, proposal_id: u64) acquires Proposal { let sender = signer::address_of(executor); let proposal = borrow_global_mut<Proposal>(sender); assert!(timestamp::now_seconds() >= proposal.end_time, 2); assert!(!proposal.executed, 3); assert!(proposal.votes_for > proposal.votes_against, 4); proposal.executed = true; // Execute proposal logic here } public fun get_next_proposal_id(): u64 { // Implementation to get next proposal ID } }",
        "vulnerabilities": [
            "Lack of access control for proposal creation",
            "No mechanism to cancel or update proposals",
            "Potential integer overflow in vote counting",
            "Missing checks for minimum voting power",
            "Centralization risk with single contract for all proposals",
            "No quorum requirements for proposal execution",
            "Lack of time lock for executed proposals",
            "Potential reentrancy in vote function",
            "Missing event emissions for votes and executions",
            "No mechanism to pause voting or proposal creation"
        ]
    },

    {
        "code": "module ReputationSystem { struct UserReputation has key { score: u64, last_update: u64 } public fun initialize_user(account: &signer) { let rep = UserReputation { score: 100, last_update: timestamp::now_seconds() }; move_to(account, rep); } public fun update_reputation(moderator: &signer, user_address: address, change: i64) acquires UserReputation { assert!(is_moderator(signer::address_of(moderator)), 109); let user_rep = borrow_global_mut<UserReputation>(user_address); user_rep.score = if (change > 0) { user_rep.score + (change as u64) } else { user_rep.score - ((-change) as u64) }; user_rep.last_update = timestamp::now_seconds(); } }",
        "vulnerabilities": [
            "Centralized moderation system",
            "No mechanism to dispute reputation changes",
            "Lack of decay for old reputation scores"
        ]
    },
    {
        "code": "module DynamicNFT { struct NFT has key { owner: address, level: u64, experience: u64 } public fun mint_nft(account: &signer) { let nft = NFT { owner: signer::address_of(account), level: 1, experience: 0 }; move_to(account, nft); } public fun gain_experience(nft_owner: &signer, amount: u64) acquires NFT { let nft = borrow_global_mut<NFT>(signer::address_of(nft_owner)); nft.experience = nft.experience + amount; if (nft.experience >= nft.level * 100) { nft.level = nft.level + 1; nft.experience = 0; } } }",
        "vulnerabilities": [
            "No mechanism to prevent rapid experience farming",
            "Lack of burning or retirement functionality",
            "Fixed level-up threshold may become unbalanced"
        ]
    },
    {
        "code": "module DecentralizedExchange { struct LiquidityPool has key { token_a: address, token_b: address, reserve_a: u64, reserve_b: u64, lp_token_supply: u64 } public fun create_pool(creator: &signer, token_a: address, token_b: address) { let pool = LiquidityPool { token_a, token_b, reserve_a: 0, reserve_b: 0, lp_token_supply: 0 }; move_to(creator, pool); } public fun add_liquidity(account: &signer, amount_a: u64, amount_b: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); pool.reserve_a = pool.reserve_a + amount_a; pool.reserve_b = pool.reserve_b + amount_b; // Mint LP tokens } public fun swap(account: &signer, amount_in: u64, token_in: address) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); assert!(token_in == pool.token_a || token_in == pool.token_b, 110); let (reserve_in, reserve_out) = if (token_in == pool.token_a) { (pool.reserve_a, pool.reserve_b) } else { (pool.reserve_b, pool.reserve_a) }; let amount_out = (amount_in * reserve_out) / (reserve_in + amount_in); // Perform swap } }",
        "vulnerabilities": [
            "No slippage protection for liquidity providers",
            "Lack of fee mechanism for liquidity providers",
            "Susceptible to sandwich attacks"
        ]
    },
    {
        "code": "module TimeLockWallet { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct TimeLock<phantom CoinType> has key { beneficiary: address, release_time: u64, amount: u64 } public fun create_timelock<CoinType>(creator: &signer, beneficiary: address, amount: u64, lock_duration: u64) { let sender = signer::address_of(creator); assert!(!exists<TimeLock<CoinType>>(sender), 1); let release_time = timestamp::now_seconds() + lock_duration; move_to(creator, TimeLock<CoinType> { beneficiary, release_time, amount }); coin::transfer<CoinType>(creator, sender, amount); } public fun release<CoinType>(releaser: &signer) acquires TimeLock { let sender = signer::address_of(releaser); let timelock = move_from<TimeLock<CoinType>>(sender); assert!(timestamp::now_seconds() >= timelock.release_time, 2); coin::transfer<CoinType>(releaser, timelock.beneficiary, timelock.amount); } public fun extend_lock<CoinType>(owner: &signer, additional_time: u64) acquires TimeLock { let sender = signer::address_of(owner); let timelock = borrow_global_mut<TimeLock<CoinType>>(sender); timelock.release_time = timelock.release_time + additional_time; } }",
        "vulnerabilities": [
            "Lack of access control for extending lock time",
            "No mechanism to cancel or update beneficiary",
            "Potential integer overflow in release time calculation",
            "Missing event emissions for lock creation and release",
            "No partial release functionality",
            "Centralization risk with single contract for all timelocks",
            "Lack of checks for zero values in amount and duration",
            "Potential reentrancy in release function",
            "No mechanism to handle lost keys or deceased beneficiary",
            "Missing checks for maximum lock duration"
        ]
    },
    {
        "code": "module UpgradeableProxy { struct Proxy has key { implementation: address } public fun initialize(account: &signer, initial_implementation: address) { let proxy = Proxy { implementation: initial_implementation }; move_to(account, proxy); } public fun upgrade(admin: &signer, new_implementation: address) acquires Proxy { assert!(signer::address_of(admin) == @admin_address, 111); let proxy = borrow_global_mut<Proxy>(@proxy_address); proxy.implementation = new_implementation; } public fun execute(account: &signer, function: vector<u8>, args: vector<vector<u8>>) acquires Proxy { let proxy = borrow_global<Proxy>(@proxy_address); // Call function on implementation address } }",
        "vulnerabilities": [
            "Single point of failure with admin key",
            "No time lock or voting for upgrades",
            "Potential for breaking changes in upgrades"
        ]
    },
    {
        "code": "module Fundraiser { struct Campaign has key { creator: address, goal: u64, raised: u64, end_time: u64 } public fun create_campaign(creator: &signer, goal: u64, duration: u64) { let campaign = Campaign { creator: signer::address_of(creator), goal, raised: 0, end_time: timestamp::now_seconds() + duration }; move_to(creator, campaign); } public fun donate(donor: &signer, campaign_id: u64, amount: u64) acquires Campaign { let campaign = borrow_global_mut<Campaign>(campaign_id); assert!(timestamp::now_seconds() < campaign.end_time, 112); campaign.raised = campaign.raised + amount; // Transfer tokens to campaign } public fun claim_funds(creator: &signer, campaign_id: u64) acquires Campaign { let campaign = borrow_global<Campaign>(campaign_id); assert!(signer::address_of(creator) == campaign.creator, 113); assert!(timestamp::now_seconds() >= campaign.end_time, 114); assert!(campaign.raised >= campaign.goal, 115); // Transfer raised funds to creator } }",
        "vulnerabilities": [
            "No refund mechanism if goal isn't met",
            "Lack of partial fundraising option",
            "No mechanism to extend campaign duration"
        ]
    },
    {
        "code": "module SecureVault { use std::signer; use aptos_framework::coin; struct Vault has key { balance: u64, owner: address, } public fun create_vault(account: &signer) { let owner = signer::address_of(account); assert!(!exists<Vault>(owner), 1); move_to(account, Vault { balance: 0, owner }); } public fun deposit(account: &signer, amount: u64) acquires Vault { let owner = signer::address_of(account); let vault = borrow_global_mut<Vault>(owner); vault.balance = vault.balance + amount; coin::transfer<AptosCoin>(account, @vault_address, amount); } public fun withdraw(account: &signer, amount: u64) acquires Vault { let owner = signer::address_of(account); let vault = borrow_global_mut<Vault>(owner); assert!(vault.balance >= amount, 2); vault.balance = vault.balance - amount; coin::transfer<AptosCoin>(@vault_address, owner, amount); } }",
        "vulnerabilities": [
            "Lack of events for tracking deposits and withdrawals",
            "No mechanism for vault upgrades or migrations"
        ]
    },
    {
        "code": "module TokenVesting { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct VestingSchedule has key { beneficiary: address, total_amount: u64, released_amount: u64, start_time: u64, duration: u64, } public fun create_vesting(account: &signer, beneficiary: address, total_amount: u64, duration: u64) { let sender = signer::address_of(account); assert!(!exists<VestingSchedule>(sender), 1); move_to(account, VestingSchedule { beneficiary, total_amount, released_amount: 0, start_time: timestamp::now_seconds(), duration }); coin::transfer<AptosCoin>(account, @vesting_contract, total_amount); } public fun release(account: &signer) acquires VestingSchedule { let beneficiary = signer::address_of(account); let vesting = borrow_global_mut<VestingSchedule>(@vesting_contract); assert!(beneficiary == vesting.beneficiary, 2); let vested_amount = calculate_vested_amount(vesting); let to_release = vested_amount - vesting.released_amount; vesting.released_amount = vested_amount; coin::transfer<AptosCoin>(@vesting_contract, beneficiary, to_release); } fun calculate_vested_amount(vesting: &VestingSchedule): u64 { let elapsed = timestamp::now_seconds() - vesting.start_time; if (elapsed >= vesting.duration) { vesting.total_amount } else { (vesting.total_amount * elapsed) / vesting.duration } } }",
        "vulnerabilities": [
            "No mechanism for contract owner to revoke or modify vesting",
            "Lack of events for vesting creation and token releases"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::token; struct Listing has key { creator: address, token_id: token::TokenId, price: u64, } public fun list_token(account: &signer, creator: address, collection: vector<u8>, name: vector<u8>, price: u64) { let token_id = token::create_token_id_raw(creator, collection, name, 0); let sender = signer::address_of(account); assert!(!exists<Listing>(sender), 1); move_to(account, Listing { creator, token_id, price }); } public fun buy_token<CoinType>(account: &signer, seller: address) acquires Listing { let listing = move_from<Listing>(seller); let buyer = signer::address_of(account); coin::transfer<CoinType>(account, seller, listing.price); token::transfer(seller, listing.token_id, buyer, 1); } public fun cancel_listing(account: &signer) acquires Listing { let sender = signer::address_of(account); let Listing { creator: _, token_id: _, price: _ } = move_from<Listing>(sender); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of access control for listing cancellation",
            "No escrow mechanism for secure transactions",
            "Potential for front-running in buy_token function",
            "Absence of price validation in list_token",
            "No support for batch listings or purchases",
            "Lack of event emissions for important operations",
            "No mechanism to update listing price",
            "Potential for lost tokens if listing is not properly removed",
            "No support for auctions or time-limited sales"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use std::vector; use aptos_framework::coin; struct MultiSig has key { owners: vector<address>, required_confirmations: u64, } struct Transaction has key { to: address, amount: u64, confirmations: u64, executed: bool, } public fun create_wallet(account: &signer, owners: vector<address>, required: u64) { assert!(vector::length(&owners) >= required, 1); move_to(account, MultiSig { owners, required_confirmations: required }); } public fun submit_transaction(account: &signer, to: address, amount: u64) acquires MultiSig { let sender = signer::address_of(account); let multisig = borrow_global<MultiSig>(@multisig_address); assert!(vector::contains(&multisig.owners, &sender), 2); move_to(account, Transaction { to, amount, confirmations: 1, executed: false }); } public fun confirm_transaction(account: &signer, tx_address: address) acquires MultiSig, Transaction { let sender = signer::address_of(account); let multisig = borrow_global<MultiSig>(@multisig_address); assert!(vector::contains(&multisig.owners, &sender), 2); let tx = borrow_global_mut<Transaction>(tx_address); tx.confirmations = tx.confirmations + 1; if (tx.confirmations >= multisig.required_confirmations && !tx.executed) { tx.executed = true; coin::transfer<AptosCoin>(@multisig_address, tx.to, tx.amount); } } }",
        "vulnerabilities": [
            "Lack of event emissions for wallet creation and transaction confirmations"
        ]
    },
    {
        "code": "module LiquidityMining { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct UserInfo has key { amount: u64, reward_debt: u64, } struct Pool has key { total_stake: u64, accum_reward_per_share: u64, last_reward_time: u64, } public fun create_pool(account: &signer) { move_to(account, Pool { total_stake: 0, accum_reward_per_share: 0, last_reward_time: timestamp::now_seconds() }); } public fun stake(account: &signer, amount: u64) acquires Pool, UserInfo { let sender = signer::address_of(account); let pool = borrow_global_mut<Pool>(@pool_address); update_pool(pool); if (!exists<UserInfo>(sender)) { move_to(account, UserInfo { amount: 0, reward_debt: 0 }); } let user_info = borrow_global_mut<UserInfo>(sender); let pending_reward = (user_info.amount * pool.accum_reward_per_share) / 1e12 - user_info.reward_debt; if (pending_reward > 0) { coin::transfer<RewardCoin>(@pool_address, sender, pending_reward); } user_info.amount = user_info.amount + amount; user_info.reward_debt = (user_info.amount * pool.accum_reward_per_share) / 1e12; pool.total_stake = pool.total_stake + amount; coin::transfer<StakeCoin>(account, @pool_address, amount); } fun update_pool(pool: &mut Pool) { let current_time = timestamp::now_seconds(); if (current_time <= pool.last_reward_time) { return }; if (pool.total_stake == 0) { pool.last_reward_time = current_time; return }; let reward = calculate_reward(current_time - pool.last_reward_time); pool.accum_reward_per_share = pool.accum_reward_per_share + (reward * 1e12) / pool.total_stake; pool.last_reward_time = current_time; } fun calculate_reward(time_elapsed: u64): u64 { // Implement reward calculation logic here } }",
        "vulnerabilities": [
            "Potential for precision loss in reward calculations",
            "Lack of cap on total rewards"
        ]
    },
    {
        "code": "module Governance { use std::signer; use aptos_framework::coin; struct Proposal has key { id: u64, creator: address, description: vector<u8>, for_votes: u64, against_votes: u64, end_time: u64, executed: bool, } struct VoteRecord has key { voted_proposals: vector<u64>, } public fun create_proposal(account: &signer, description: vector<u8>, voting_period: u64) acquires Proposal { let sender = signer::address_of(account); let proposal_id = get_next_proposal_id(); move_to(account, Proposal { id: proposal_id, creator: sender, description, for_votes: 0, against_votes: 0, end_time: aptos_framework::timestamp::now_seconds() + voting_period, executed: false, }); } public fun vote<VotingPowerToken>(account: &signer, proposal_id: u64, support: bool) acquires Proposal, VoteRecord { let sender = signer::address_of(account); let proposal = borrow_global_mut<Proposal>(@governance); assert!(aptos_framework::timestamp::now_seconds() <= proposal.end_time, 1); let voting_power = coin::balance<VotingPowerToken>(sender); if (support) { proposal.for_votes = proposal.for_votes + voting_power; } else { proposal.against_votes = proposal.against_votes + voting_power; } if (!exists<VoteRecord>(sender)) { move_to(account, VoteRecord { voted_proposals: vector::empty() }); } let vote_record = borrow_global_mut<VoteRecord>(sender); vector::push_back(&mut vote_record.voted_proposals, proposal_id); } public fun execute_proposal(proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@governance); assert!(!proposal.executed, 2); assert!(aptos_framework::timestamp::now_seconds() > proposal.end_time, 3); assert!(proposal.for_votes > proposal.against_votes, 4); proposal.executed = true; // Execute proposal logic here } fun get_next_proposal_id(): u64 { // Implementation omitted 0 } }",
        "vulnerabilities": [
            "Lack of quorum requirement for proposal execution",
            "No mechanism to cancel or update proposals",
            "Potential for governance attacks through token concentration",
            "Absence of time lock for executed proposals",
            "No delegation mechanism for voting power",
            "Lack of proposal threshold to prevent spam",
            "No support for quadratic voting or other advanced voting systems",
            "Potential for flash loan attacks to influence votes",
            "Absence of vote privacy (all votes are public)",
            "No mechanism to slash tokens for malicious proposals"
        ]
    },
    {
        "code": "module NFTFractionalOwnership { use std::signer; use aptos_framework::nft; use aptos_framework::coin; struct FractionalNFT has key { token_id: u64, total_shares: u64, available_shares: u64, price_per_share: u64, } struct ShareOwnership has key { shares: u64, } public fun fractionalize_nft(account: &signer, token_id: u64, total_shares: u64, price_per_share: u64) { let owner = signer::address_of(account); assert!(!exists<FractionalNFT>(owner), 1); nft::transfer(account, @nft_vault, token_id); move_to(account, FractionalNFT { token_id, total_shares, available_shares: total_shares, price_per_share }); } public fun buy_shares(account: &signer, nft_owner: address, num_shares: u64) acquires FractionalNFT, ShareOwnership { let buyer = signer::address_of(account); let fnft = borrow_global_mut<FractionalNFT>(nft_owner); assert!(fnft.available_shares >= num_shares, 2); let total_cost = num_shares * fnft.price_per_share; coin::transfer<AptosCoin>(account, nft_owner, total_cost); fnft.available_shares = fnft.available_shares - num_shares; if (!exists<ShareOwnership>(buyer)) { move_to(account, ShareOwnership { shares: 0 }); } let ownership = borrow_global_mut<ShareOwnership>(buyer); ownership.shares = ownership.shares + num_shares; } public fun redeem_nft(account: &signer, nft_owner: address) acquires FractionalNFT, ShareOwnership { let redeemer = signer::address_of(account); let fnft = borrow_global<FractionalNFT>(nft_owner); let ownership = borrow_global<ShareOwnership>(redeemer); assert!(ownership.shares == fnft.total_shares, 3); nft::transfer(@nft_vault, redeemer, fnft.token_id); } }",
        "vulnerabilities": [
            "Lack of mechanism for partial share redemption",
            "No events for tracking fractional ownership changes"
        ]
    },
    {
        "code": "module DecentralizedExchange { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom CoinTypeA, phantom CoinTypeB> has key { reserve_a: u64, reserve_b: u64, total_shares: u64, } struct LiquidityProviderInfo<phantom CoinTypeA, phantom CoinTypeB> has key { shares: u64, } const MINIMUM_LIQUIDITY: u64 = 1000; public fun create_pool<CoinTypeA, CoinTypeB>(account: &signer) { assert!(!exists<LiquidityPool<CoinTypeA, CoinTypeB>>(@exchange), 1); move_to(account, LiquidityPool<CoinTypeA, CoinTypeB> { reserve_a: 0, reserve_b: 0, total_shares: 0, }); } public fun add_liquidity<CoinTypeA, CoinTypeB>(account: &signer, amount_a: u64, amount_b: u64) acquires LiquidityPool, LiquidityProviderInfo { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(@exchange); let shares = if (pool.total_shares == 0) { sqrt(amount_a * amount_b) - MINIMUM_LIQUIDITY } else { min((amount_a * pool.total_shares) / pool.reserve_a, (amount_b * pool.total_shares) / pool.reserve_b) }; pool.reserve_a = pool.reserve_a + amount_a; pool.reserve_b = pool.reserve_b + amount_b; pool.total_shares = pool.total_shares + shares; if (!exists<LiquidityProviderInfo<CoinTypeA, CoinTypeB>>(sender)) { move_to(account, LiquidityProviderInfo<CoinTypeA, CoinTypeB> { shares: 0 }); } let provider_info = borrow_global_mut<LiquidityProviderInfo<CoinTypeA, CoinTypeB>>(sender); provider_info.shares = provider_info.shares + shares; coin::transfer<CoinTypeA>(account, @exchange, amount_a); coin::transfer<CoinTypeB>(account, @exchange, amount_b); } public fun swap<CoinTypeA, CoinTypeB>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(@exchange); let amount_out = (amount_in * pool.reserve_b) / (pool.reserve_a + amount_in); assert!(amount_out >= min_amount_out, 2); pool.reserve_a = pool.reserve_a + amount_in; pool.reserve_b = pool.reserve_b - amount_out; coin::transfer<CoinTypeA>(account, @exchange, amount_in); coin::transfer<CoinTypeB>(@exchange, signer::address_of(account), amount_out); } fun sqrt(y: u64): u64 { if (y < 4) { if (y == 0) { 0 } else { 1 } } else { let z = y; let x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; }; z } } fun min(a: u64, b: u64): u64 { if (a < b) { a } else { b } } }",
        "vulnerabilities": [
            "Lack of slippage protection in add_liquidity function",
            "No mechanism for removing liquidity"
        ]
    },
    {
        "code": "module DAO { use std::signer; use aptos_framework::coin; struct Proposal has key { id: u64, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64, executed: bool, } struct MemberInfo has key { voting_power: u64, } struct DAOConfig has key { proposal_threshold: u64, voting_period: u64, quorum: u64, next_proposal_id: u64, } public fun initialize(account: &signer, proposal_threshold: u64, voting_period: u64, quorum: u64) { move_to(account, DAOConfig { proposal_threshold, voting_period, quorum, next_proposal_id: 0 }); } public fun create_proposal(account: &signer, description: vector<u8>) acquires DAOConfig, MemberInfo { let sender = signer::address_of(account); let member_info = borrow_global<MemberInfo>(sender); let config = borrow_global_mut<DAOConfig>(@dao); assert!(member_info.voting_power >= config.proposal_threshold, 1); let proposal_id = config.next_proposal_id; config.next_proposal_id = proposal_id + 1; move_to(account, Proposal { id: proposal_id, description, yes_votes: 0, no_votes: 0, end_time: timestamp::now_seconds() + config.voting_period, executed: false }); } public fun vote(account: &signer, proposal_id: u64, support: bool) acquires Proposal, MemberInfo { let sender = signer::address_of(account); let member_info = borrow_global<MemberInfo>(sender); let proposal = borrow_global_mut<Proposal>(@dao); assert!(timestamp::now_seconds() <= proposal.end_time, 2); if (support) { proposal.yes_votes = proposal.yes_votes + member_info.voting_power; } else { proposal.no_votes = proposal.no_votes + member_info.voting_power; } } public fun execute_proposal(proposal_id: u64) acquires Proposal, DAOConfig { let config = borrow_global<DAOConfig>(@dao); let proposal = borrow_global_mut<Proposal>(@dao); assert!(timestamp::now_seconds() > proposal.end_time, 3); assert!(!proposal.executed, 4); assert!(proposal.yes_votes + proposal.no_votes >= config.quorum, 5); assert!(proposal.yes_votes > proposal.no_votes, 6); proposal.executed = true; // Execute proposal logic here } }",
        "vulnerabilities": [
            "Lack of time-lock for proposal execution",
            "No mechanism for cancelling proposals"
        ]
    },
    {
        "code": "module SimpleDEX { use std::signer; use aptos_framework::coin; use aptos_framework::event; struct LiquidityPool<phantom CoinTypeA, phantom CoinTypeB> has key { reserve_a: u64, reserve_b: u64, lp_token_supply: u64, } struct LPToken<phantom CoinTypeA, phantom CoinTypeB> {} struct SwapEvent has drop, store { user: address, amount_in: u64, amount_out: u64, } struct SwapEventHandle has key { swap_events: event::EventHandle<SwapEvent>, } const MINIMUM_LIQUIDITY: u64 = 1000; const FEE_NUMERATOR: u64 = 3; const FEE_DENOMINATOR: u64 = 1000; public fun initialize_pool<CoinTypeA, CoinTypeB>(account: &signer) { let sender = signer::address_of(account); assert!(!exists<LiquidityPool<CoinTypeA, CoinTypeB>>(sender), 1); move_to(account, LiquidityPool<CoinTypeA, CoinTypeB> { reserve_a: 0, reserve_b: 0, lp_token_supply: 0, }); move_to(account, SwapEventHandle { swap_events: event::new_event_handle<SwapEvent>(account), }); } public fun add_liquidity<CoinTypeA, CoinTypeB>(account: &signer, amount_a: u64, amount_b: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(@dex_address); let lp_tokens = if (pool.lp_token_supply == 0) { amount_a.min(amount_b) - MINIMUM_LIQUIDITY } else { (amount_a * pool.lp_token_supply / pool.reserve_a).min(amount_b * pool.lp_token_supply / pool.reserve_b) }; pool.reserve_a = pool.reserve_a + amount_a; pool.reserve_b = pool.reserve_b + amount_b; pool.lp_token_supply = pool.lp_token_supply + lp_tokens; coin::transfer<CoinTypeA>(account, @dex_address, amount_a); coin::transfer<CoinTypeB>(account, @dex_address, amount_b); coin::mint<LPToken<CoinTypeA, CoinTypeB>>(lp_tokens, account); } public fun swap<CoinTypeIn, CoinTypeOut>(account: &signer, amount_in: u64) acquires LiquidityPool, SwapEventHandle { let pool = borrow_global_mut<LiquidityPool<CoinTypeIn, CoinTypeOut>>(@dex_address); let amount_out = (amount_in * (1000 - FEE_NUMERATOR) * pool.reserve_out) / (pool.reserve_in * 1000 + amount_in * (1000 - FEE_NUMERATOR)); pool.reserve_in = pool.reserve_in + amount_in; pool.reserve_out = pool.reserve_out - amount_out; coin::transfer<CoinTypeIn>(account, @dex_address, amount_in); coin::transfer<CoinTypeOut>(@dex_address, signer::address_of(account), amount_out); let event_handle = borrow_global_mut<SwapEventHandle>(@dex_address); event::emit_event(&mut event_handle.swap_events, SwapEvent { user: signer::address_of(account), amount_in, amount_out, }); } }",
        "vulnerabilities": [
            "No slippage protection in swap function",
            "Lack of access control for initialize_pool function",
            "Potential integer overflow in liquidity calculations",
            "No mechanism to remove liquidity",
            "Missing checks for minimum liquidity requirements",
            "Centralized control of the DEX contract",
            "No checks for contract balance before transfers",
            "Potential for price manipulation through large swaps",
            "Lack of oracle integration for price feeds",
            "No time-weighted average price (TWAP) mechanism"
        ]
    },
    {
        "code": "module DecentralizedVoting { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Proposal has key { id: u64, description: vector<u8>, vote_count: u64, end_time: u64, } struct Voter has key { has_voted: bool, } public fun create_proposal(creator: &signer, id: u64, description: vector<u8>, duration: u64) { let end_time = timestamp::now_seconds() + duration; move_to(creator, Proposal { id, description, vote_count: 0, end_time }); } public fun vote(voter: &signer, proposal_address: address) acquires Proposal, Voter { let sender = signer::address_of(voter); assert!(!exists<Voter>(sender), 1); let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(timestamp::now_seconds() < proposal.end_time, 2); proposal.vote_count = proposal.vote_count + 1; move_to(voter, Voter { has_voted: true }); } public fun get_result(proposal_address: address): u64 acquires Proposal { let proposal = borrow_global<Proposal>(proposal_address); assert!(timestamp::now_seconds() >= proposal.end_time, 3); proposal.vote_count } }",
        "vulnerabilities": [
            "No mechanism to prevent double voting across multiple proposals",
            "Lack of vote weight or delegation functionality"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::event; struct Listing has key { creator: address, price: u64, } struct SaleEvent has drop, store { seller: address, buyer: address, nft_id: u64, price: u64, } struct MarketplaceEventHandle has key { sale_events: event::EventHandle<SaleEvent>, } public fun list_nft(account: &signer, nft_id: u64, price: u64) { let sender = signer::address_of(account); move_to(account, Listing { creator: sender, price, }); } public fun buy_nft(account: &signer, nft_id: u64) acquires Listing, MarketplaceEventHandle { let listing = move_from<Listing>(nft_id); coin::transfer<AptosCoin>(account, listing.creator, listing.price); let event_handle = borrow_global_mut<MarketplaceEventHandle>(@marketplace); event::emit_event(&mut event_handle.sale_events, SaleEvent { seller: listing.creator, buyer: signer::address_of(account), nft_id, price: listing.price, }); } }",
        "vulnerabilities": [
            "No ownership verification for NFT listing",
            "Lack of access control for marketplace functions",
            "No commission mechanism for the marketplace",
            "Missing checks for sufficient balance before purchase",
            "Potential for front-running attacks",
            "No mechanism to cancel or update listings",
            "Lack of royalty distribution to original creators",
            "No checks for NFT authenticity",
            "Centralized control of the marketplace contract",
            "Missing events for listing creation and cancellation"
        ]
    },
    {
        "code": "module Governance { use std::signer; use aptos_framework::coin; use aptos_framework::event; struct Proposal has key { proposer: address, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64, } struct VoteEvent has drop, store { voter: address, proposal_id: u64, vote: bool, } struct GovernanceEventHandle has key { vote_events: event::EventHandle<VoteEvent>, } public fun create_proposal(account: &signer, description: vector<u8>, voting_period: u64) { let sender = signer::address_of(account); move_to(account, Proposal { proposer: sender, description, yes_votes: 0, no_votes: 0, end_time: aptos_framework::timestamp::now_seconds() + voting_period, }); } public fun vote(account: &signer, proposal_id: u64, vote: bool) acquires Proposal, GovernanceEventHandle { let proposal = borrow_global_mut<Proposal>(proposal_id); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } let event_handle = borrow_global_mut<GovernanceEventHandle>(@governance); event::emit_event(&mut event_handle.vote_events, VoteEvent { voter: signer::address_of(account), proposal_id, vote, }); } }",
        "vulnerabilities": [
            "No token-weighted voting mechanism",
            "Lack of quorum requirements",
            "Missing checks for proposal execution",
            "No mechanism to prevent double voting",
            "Absence of proposal cancellation functionality",
            "Potential for last-minute voting attacks",
            "Lack of time lock for approved proposals",
            "No delegation mechanism for voting power",
            "Missing events for proposal creation and completion",
            "Centralized control of the governance contract"
        ]
    },
    {
        "code": "module StablecoinProtocol { use std::signer; use aptos_framework::coin; struct StableCoin {} struct CollateralVault has key { collateral_amount: u64, debt_amount: u64, } public fun mint_stablecoin(account: &signer, collateral_amount: u64) acquires CollateralVault { let sender = signer::address_of(account); let vault = borrow_global_mut<CollateralVault>(sender); let mint_amount = collateral_amount * 2 / 3; // 150% collateralization ratio vault.collateral_amount = vault.collateral_amount + collateral_amount; vault.debt_amount = vault.debt_amount + mint_amount; coin::transfer<AptosCoin>(account, @protocol, collateral_amount); coin::mint<StableCoin>(mint_amount, account); } public fun repay_and_withdraw(account: &signer, repay_amount: u64) acquires CollateralVault { let sender = signer::address_of(account); let vault = borrow_global_mut<CollateralVault>(sender); let withdraw_amount = repay_amount * 3 / 2; vault.collateral_amount = vault.collateral_amount - withdraw_amount; vault.debt_amount = vault.debt_amount - repay_amount; coin::burn<StableCoin>(repay_amount, account); coin::transfer<AptosCoin>(@protocol, sender, withdraw_amount); } }",
        "vulnerabilities": [
            "No price oracle integration for collateral valuation",
            "Lack of liquidation mechanism for undercollateralized positions",
            "Missing checks for minimum collateralization ratio",
            "No interest rate or stability fee implementation",
            "Potential for flash loan attacks",
            "Absence of governance for protocol parameters",
            "No emergency shutdown mechanism",
            "Missing events for minting and repayment actions",
            "Lack of multi-collateral support",
            "No mechanism to adjust collateralization ratio dynamically"
        ]
    },
    {
        "code": "module FlashLoan { use std::signer; use aptos_framework::coin; struct FlashLoanVault has key { balance: u64, } public fun take_flash_loan(account: &signer, amount: u64) acquires FlashLoanVault { let vault = borrow_global_mut<FlashLoanVault>(@flash_loan); assert!(vault.balance >= amount, 1); coin::transfer<AptosCoin>(@flash_loan, signer::address_of(account), amount); } public fun repay_flash_loan(account: &signer, amount: u64, fee: u64) acquires FlashLoanVault { let vault = borrow_global_mut<FlashLoanVault>(@flash_loan); coin::transfer<AptosCoin>(account, @flash_loan, amount + fee); vault.balance = vault.balance + fee; } }",
        "vulnerabilities": [
            "No check for loan repayment within the same transaction",
            "Lack of access control for flash loan functions",
            "Missing checks for sufficient balance before loan",
            "No mechanism to prevent recursive flash loans",
            "Absence of events for loan taking and repayment",
            "Potential for reentrancy attacks",
            "No limit on maximum loan amount",
            "Missing checks for minimum fee requirements",
            "Lack of integration with other DeFi protocols",
            "No mechanism to adjust fee dynamically based on utilization"
        ]
    },
    {
        "code": "module Lottery { use std::signer; use aptos_framework::coin; use aptos_framework::random; struct LotteryPool has key { total_tickets: u64, prize_pool: u64, } struct Ticket has key { owner: address, number: u64, } public fun buy_ticket(account: &signer) acquires LotteryPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LotteryPool>(@lottery); coin::transfer<AptosCoin>(account, @lottery, 1000000); // 1 APT pool.total_tickets = pool.total_tickets + 1; pool.prize_pool = pool.prize_pool + 1000000; move_to(account, Ticket { owner: sender, number: pool.total_tickets, }); } public fun draw_winner() acquires LotteryPool, Ticket { let pool = borrow_global_mut<LotteryPool>(@lottery); let winning_number = random::rand_u64() % pool.total_tickets + 1; let winner_ticket = borrow_global<Ticket>(winning_number); coin::transfer<AptosCoin>(@lottery, winner_ticket.owner, pool.prize_pool); pool.total_tickets = 0; pool.prize_pool = 0; } }",
        "vulnerabilities": [
            "Centralized control of lottery drawing",
            "Lack of true randomness in winner selection",
            "No mechanism to prevent insider trading",
            "Missing events for ticket purchases and winner drawing",
            "Absence of time-based lottery rounds",
            "No refund mechanism for unclaimed prizes",
            "Potential for block timestamp manipulation",
            "Lack of multiple prize tiers",
            "No checks for minimum number of participants",
            "Missing access control for drawing function"
        ]
    },
    {
        "code": "module NFTMarketplace { struct Listing has key { creator: address, price: u64, is_active: bool } public fun create_listing(creator: &signer, nft_id: u64, price: u64) { move_to(creator, Listing { creator: signer::address_of(creator), price, is_active: true }); } public fun buy_nft(buyer: &signer, nft_id: u64) acquires Listing { let listing = borrow_global_mut<Listing>(@nft_address); assert!(listing.is_active, 1); // Transfer NFT and payment logic here listing.is_active = false; } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow for secure transactions",
            "No checks for NFT ownership before listing"
        ]
    },
    {
        "code": "module Governance { struct Proposal has key { proposer: address, votes_for: u64, votes_against: u64, executed: bool } public fun create_proposal(proposer: &signer, proposal_id: u64) { move_to(proposer, Proposal { proposer: signer::address_of(proposer), votes_for: 0, votes_against: 0, executed: false }); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@proposal_address); if (vote) { proposal.votes_for += 1; } else { proposal.votes_against += 1; } } }",
        "vulnerabilities": [
            "No time limit for voting",
            "Lack of quorum checks",
            "No mechanism to prevent double voting"
        ]
    },
    {
        "code": "module TokenSwap { use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: coin::Coin<X>, reserve_y: coin::Coin<Y>, total_shares: u64, } public fun create_pool<X, Y>(account: &signer) { move_to(account, LiquidityPool<X, Y> { reserve_x: coin::zero<X>(), reserve_y: coin::zero<Y>(), total_shares: 0, }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let coin_x = coin::withdraw<X>(account, amount_x); let coin_y = coin::withdraw<Y>(account, amount_y); coin::merge(&mut pool.reserve_x, coin_x); coin::merge(&mut pool.reserve_y, coin_y); let shares = if (pool.total_shares == 0) { (amount_x * amount_y) as u64 } else { min((amount_x * pool.total_shares) / coin::value(&pool.reserve_x), (amount_y * pool.total_shares) / coin::value(&pool.reserve_y)) }; pool.total_shares = pool.total_shares + shares; } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address); let coin_in = coin::withdraw<X>(account, amount_in); let reserve_in = coin::value(&pool.reserve_x); let reserve_out = coin::value(&pool.reserve_y); let amount_out = (amount_in * reserve_out) / (reserve_in + amount_in); assert!(amount_out >= min_amount_out, 1); coin::merge(&mut pool.reserve_x, coin_in); let coin_out = coin::extract(&mut pool.reserve_y, amount_out); coin::deposit(signer::address_of(account), coin_out); } }",
        "vulnerabilities": [
            "No slippage protection in add_liquidity function",
            "Potential for front-running attacks in swap function",
            "Lack of access control for pool creation",
            "No mechanism for removing liquidity",
            "Missing events for important operations",
            "Potential integer overflow in share calculation",
            "No fees implemented for swaps",
            "Centralized control of the pool address",
            "No time-weighted average price (TWAP) oracle",
            "Vulnerability to flash loan attacks"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::timestamp; struct Listing has key { creator: address, token_id: u64, price: u64, expiration: u64, } public fun create_listing(seller: &signer, token_id: u64, price: u64, duration: u64) { let sender = signer::address_of(seller); move_to(seller, Listing { creator: sender, token_id, price, expiration: timestamp::now_seconds() + duration, }); } public fun buy_nft(buyer: &signer, seller: address, token_id: u64) acquires Listing { let listing = move_from<Listing>(seller); assert!(listing.token_id == token_id, 1); assert!(timestamp::now_seconds() < listing.expiration, 2); let payment = coin::withdraw<AptosCoin>(buyer, listing.price); coin::deposit(seller, payment); // Transfer NFT logic here } public fun cancel_listing(seller: &signer, token_id: u64) acquires Listing { let Listing { creator, token_id: _, price: _, expiration: _ } = move_from<Listing>(signer::address_of(seller)); assert!(creator == signer::address_of(seller), 1); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of access control for marketplace functions",
            "Missing checks for NFT ownership in create_listing",
            "No mechanism to update listing price or duration",
            "Potential for integer overflow in expiration calculation",
            "Missing events for listing creation, purchases, and cancellations",
            "No support for bundle sales or auctions",
            "Centralized control of the marketplace contract",
            "Lack of checks for zero-price listings",
            "No mechanism to pause the marketplace in case of emergencies"
        ]
    },
    {
        "code": "module StakingRewards { use aptos_framework::coin; use aptos_framework::timestamp; struct StakeInfo has key { amount: u64, reward_debt: u64, } struct Pool has key { total_stake: u64, reward_per_token: u64, last_update_time: u64, reward_rate: u64, } public fun initialize(admin: &signer) { move_to(admin, Pool { total_stake: 0, reward_per_token: 0, last_update_time: timestamp::now_seconds(), reward_rate: 100, // tokens per second }); } public fun stake(account: &signer, amount: u64) acquires Pool, StakeInfo { let pool = borrow_global_mut<Pool>(@staking_address); update_rewards(); let sender = signer::address_of(account); if (!exists<StakeInfo>(sender)) { move_to(account, StakeInfo { amount: 0, reward_debt: 0 }); } let stake_info = borrow_global_mut<StakeInfo>(sender); let tokens = coin::withdraw<StakingToken>(account, amount); coin::deposit(@staking_address, tokens); stake_info.amount = stake_info.amount + amount; stake_info.reward_debt = stake_info.amount * pool.reward_per_token; pool.total_stake = pool.total_stake + amount; } public fun claim_rewards(account: &signer) acquires Pool, StakeInfo { update_rewards(); let sender = signer::address_of(account); let stake_info = borrow_global_mut<StakeInfo>(sender); let pool = borrow_global<Pool>(@staking_address); let pending_reward = stake_info.amount * pool.reward_per_token - stake_info.reward_debt; if (pending_reward > 0) { let reward_coins = coin::withdraw<RewardToken>(@staking_address, pending_reward); coin::deposit(sender, reward_coins); } stake_info.reward_debt = stake_info.amount * pool.reward_per_token; } fun update_rewards() acquires Pool { let pool = borrow_global_mut<Pool>(@staking_address); let current_time = timestamp::now_seconds(); if (current_time > pool.last_update_time) { if (pool.total_stake > 0) { let time_elapsed = current_time - pool.last_update_time; let rewards = time_elapsed * pool.reward_rate; pool.reward_per_token = pool.reward_per_token + (rewards / pool.total_stake); } pool.last_update_time = current_time; } } }",
        "vulnerabilities": [
            "Potential for division by zero in update_rewards if total_stake is 0",
            "Lack of access control for initialize function",
            "No mechanism to change reward rate or pause rewards",
            "Missing events for staking and reward claiming",
            "Potential integer overflow in reward calculations",
            "No unstaking mechanism implemented",
            "Centralized control of the staking contract",
            "No slashing mechanism for misbehaving stakers",
            "Lack of time-lock for stake withdrawals",
            "No mechanism to recover stuck tokens in the contract"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::token; struct Listing { creator: address, token_id: token::TokenId, price: u64 } public fun list_token(account: &signer, token_id: token::TokenId, price: u64) { let sender = signer::address_of(account); token::transfer(account, @marketplace, token_id); move_to(account, Listing { creator: sender, token_id, price }); } public fun buy_token(account: &signer, listing: &Listing) { let sender = signer::address_of(account); coin::transfer<AptosCoin>(account, listing.creator, listing.price); token::transfer(@marketplace, sender, listing.token_id); } }",
        "vulnerabilities": [
            "No mechanism to delist tokens",
            "Lack of royalty distribution",
            "Missing access control for marketplace operations",
            "No event emissions for listing and buying",
            "Absence of price validation"
        ]
    },
    {
        "code": "module DeFiLending { use std::signer; use aptos_framework::coin; struct LendingPool<phantom CoinType> { total_borrowed: u64, total_supplied: u64 } public fun supply<CoinType>(account: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_pool); coin::transfer<CoinType>(account, @lending_pool, amount); pool.total_supplied = pool.total_supplied + amount; } public fun borrow<CoinType>(account: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_pool); assert!(pool.total_supplied >= pool.total_borrowed + amount, 1); coin::transfer<CoinType>(@lending_pool, signer::address_of(account), amount); pool.total_borrowed = pool.total_borrowed + amount; } }",
        "vulnerabilities": [
            "No interest rate calculation",
            "Lack of collateralization mechanism",
            "Missing liquidation functionality",
            "Absence of borrow limits",
            "No mechanism to handle bad debts"
        ]
    },
    {
        "code": "module GovernanceDAO { use std::signer; use aptos_framework::coin; struct Proposal { id: u64, description: vector<u8>, votes_for: u64, votes_against: u64, executed: bool } public fun create_proposal(account: &signer, description: vector<u8>) { let sender = signer::address_of(account); assert!(coin::balance<GovernanceToken>(sender) >= 100, 1); // Require 100 tokens to create proposal let proposal_id = get_next_proposal_id(); move_to(account, Proposal { id: proposal_id, description, votes_for: 0, votes_against: 0, executed: false }); } public fun vote(account: &signer, proposal_id: u64, vote: bool) acquires Proposal { let sender = signer::address_of(account); let voting_power = coin::balance<GovernanceToken>(sender); let proposal = borrow_global_mut<Proposal>(@dao_address); if (vote) { proposal.votes_for = proposal.votes_for + voting_power; } else { proposal.votes_against = proposal.votes_against + voting_power; } } }",
        "vulnerabilities": [
            "No time limit for voting",
            "Lack of quorum requirement",
            "Missing vote delegation mechanism",
            "Absence of proposal execution logic",
            "No protection against flash loan attacks"
        ]
    },
    {
        "code": "module DecentralizedExchange { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> { reserve_x: u64, reserve_y: u64 } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex_address); coin::transfer<X>(account, @dex_address, amount_x); coin::transfer<Y>(account, @dex_address, amount_y); pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; } public fun swap<X, Y>(account: &signer, amount_in: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex_address); let amount_out = calculate_output_amount(pool.reserve_x, pool.reserve_y, amount_in); coin::transfer<X>(account, @dex_address, amount_in); coin::transfer<Y>(@dex_address, signer::address_of(account), amount_out); pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; } }",
        "vulnerabilities": [
            "No slippage protection",
            "Lack of oracle price feeds",
            "Missing liquidity provider token minting",
            "Absence of fee collection mechanism",
            "Vulnerability to front-running attacks"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; use aptos_framework::coin; struct BridgeRequest { id: u64, amount: u64, recipient: address, processed: bool } public fun initiate_transfer(account: &signer, amount: u64, recipient: address) { let sender = signer::address_of(account); coin::transfer<BridgeToken>(account, @bridge_address, amount); let request_id = get_next_request_id(); move_to(account, BridgeRequest { id: request_id, amount, recipient, processed: false }); } public fun process_transfer(oracle: &signer, request_id: u64) acquires BridgeRequest { assert!(signer::address_of(oracle) == @trusted_oracle, 1); let request = borrow_global_mut<BridgeRequest>(@bridge_address); assert!(!request.processed, 2); coin::transfer<BridgeToken>(@bridge_address, request.recipient, request.amount); request.processed = true; } }",
        "vulnerabilities": [
            "Single point of failure with trusted oracle",
            "Lack of multi-signature validation",
            "Missing event emissions for transfers",
            "Absence of fee mechanism for bridge operations",
            "No mechanism to handle failed transfers"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::object; struct Listing has key { creator: address, price: u64, nft_id: object::ObjectId } public fun list_nft(account: &signer, nft_id: object::ObjectId, price: u64) { let listing = Listing { creator: signer::address_of(account), price, nft_id }; move_to(account, listing); } public fun buy_nft(buyer: &signer, seller: address, nft_id: object::ObjectId) acquires Listing { let listing = move_from<Listing>(seller); coin::transfer<AptosCoin>(buyer, listing.creator, listing.price); object::transfer(seller, signer::address_of(buyer), nft_id); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow for secure transactions",
            "Missing price validation",
            "No mechanism to update or cancel listings",
            "Vulnerability to front-running attacks"
        ]
    },
    {
        "code": "module StakingPool { use std::signer; use aptos_framework::coin; struct StakeInfo has key { amount: u64, last_claim_time: u64 } public fun stake(account: &signer, amount: u64) { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); coin::transfer<AptosCoin>(account, @staking_pool, amount); stake_info.amount = stake_info.amount + amount; stake_info.last_claim_time = timestamp::now_seconds(); } public fun claim_rewards(account: &signer) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(account)); let reward = calculate_reward(stake_info.amount, stake_info.last_claim_time); coin::transfer<AptosCoin>(@staking_pool, signer::address_of(account), reward); stake_info.last_claim_time = timestamp::now_seconds(); } }",
        "vulnerabilities": [
            "Centralized reward distribution",
            "Lack of slashing mechanism",
            "No minimum staking period",
            "Potential for reward calculation errors",
            "Missing unstaking functionality"
        ]
    },
    {
        "code": "module VotingSystem { use std::signer; use aptos_framework::table; struct Proposal has key { id: u64, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64 } public fun create_proposal(creator: &signer, description: vector<u8>, duration: u64) { let proposal = Proposal { id: generate_unique_id(), description, yes_votes: 0, no_votes: 0, end_time: timestamp::now_seconds() + duration }; move_to(creator, proposal); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@voting_system); assert!(timestamp::now_seconds() < proposal.end_time, 1); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } } }",
        "vulnerabilities": [
            "No mechanism to prevent double voting",
            "Lack of voter weight consideration",
            "Missing proposal execution logic",
            "Centralized proposal creation",
            "No quorum requirement"
        ]
    },
    {
        "code": "module TimeLock { use std::signer; use aptos_framework::coin; struct LockedFunds has key { amount: u64, unlock_time: u64 } public fun lock_funds(account: &signer, amount: u64, lock_duration: u64) { let locked_funds = LockedFunds { amount, unlock_time: timestamp::now_seconds() + lock_duration }; coin::transfer<AptosCoin>(account, @timelock, amount); move_to(account, locked_funds); } public fun withdraw(account: &signer) acquires LockedFunds { let locked_funds = move_from<LockedFunds>(signer::address_of(account)); assert!(timestamp::now_seconds() >= locked_funds.unlock_time, 1); coin::transfer<AptosCoin>(@timelock, signer::address_of(account), locked_funds.amount); } }",
        "vulnerabilities": [
            "No partial withdrawal option",
            "Lack of emergency unlock mechanism",
            "Missing fee structure for early withdrawal",
            "No option to extend lock period",
            "Potential for precision loss in time calculations"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use aptos_framework::coin; use aptos_framework::vector; struct Transaction has key { id: u64, to: address, amount: u64, approvals: vector<address> } public fun propose_transaction(proposer: &signer, to: address, amount: u64) { let transaction = Transaction { id: generate_unique_id(), to, amount, approvals: vector::empty() }; move_to(proposer, transaction); } public fun approve_transaction(approver: &signer, transaction_id: u64) acquires Transaction { let transaction = borrow_global_mut<Transaction>(@multi_sig_wallet); vector::push_back(&mut transaction.approvals, signer::address_of(approver)); if (vector::length(&transaction.approvals) >= required_approvals()) { execute_transaction(transaction); } } }",
        "vulnerabilities": [
            "Lack of approval revocation mechanism",
            "Missing transaction cancellation option",
            "No time limit for transaction approval",
            "Potential for centralization if required approvals are low",
            "Absence of role-based access control"
        ]
    },
    {
        "code": "module LiquidityMining { use std::signer; use aptos_framework::coin; struct UserStake has key { amount: u64, last_claim_time: u64 } public fun stake(account: &signer, amount: u64) { let user_stake = borrow_global_mut<UserStake>(signer::address_of(account)); coin::transfer<LPToken>(account, @liquidity_mining, amount); user_stake.amount = user_stake.amount + amount; user_stake.last_claim_time = timestamp::now_seconds(); } public fun claim_rewards(account: &signer) acquires UserStake { let user_stake = borrow_global_mut<UserStake>(signer::address_of(account)); let reward = calculate_reward(user_stake.amount, user_stake.last_claim_time); coin::transfer<RewardToken>(@liquidity_mining, signer::address_of(account), reward); user_stake.last_claim_time = timestamp::now_seconds(); } }",
        "vulnerabilities": [
            "Potential for reward calculation errors",
            "Lack of cooldown period for unstaking",
            "Missing mechanism to update reward rates",
            "No cap on total staked amount",
            "Absence of emergency pause functionality"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; use aptos_framework::coin; struct BridgeRequest has key { id: u64, amount: u64, target_chain: u8, recipient: vector<u8>, status: u8 } public fun initiate_transfer(sender: &signer, amount: u64, target_chain: u8, recipient: vector<u8>) { let request = BridgeRequest { id: generate_unique_id(), amount, target_chain, recipient, status: 0 }; coin::transfer<AptosCoin>(sender, @bridge, amount); move_to(sender, request); } public fun finalize_transfer(validator: &signer, request_id: u64) acquires BridgeRequest { let request = borrow_global_mut<BridgeRequest>(@bridge); assert!(signer::address_of(validator) == @trusted_validator, 1); request.status = 1; } }",
        "vulnerabilities": [
            "Centralized validator control",
            "Lack of multi-signature validation",
            "Missing mechanism for handling failed transfers",
            "No timeout for pending transfers",
            "Absence of fee structure for cross-chain transfers"
        ]
    },
    {
        "code": "module FlashLoan { use std::signer; use aptos_framework::coin; struct LoanPool has key { balance: u64 } public fun request_loan(borrower: &signer, amount: u64) acquires LoanPool { let pool = borrow_global_mut<LoanPool>(@flash_loan); assert!(amount <= pool.balance, 1); coin::transfer<AptosCoin>(@flash_loan, signer::address_of(borrower), amount); call_external_function(signer::address_of(borrower), amount); let repayment = amount + calculate_fee(amount); coin::transfer<AptosCoin>(borrower, @flash_loan, repayment); pool.balance = pool.balance + calculate_fee(amount); } }",
        "vulnerabilities": [
            "Reentrancy vulnerabilities in external function calls",
            "Lack of access control for loan requests",
            "Missing checks for borrower's ability to repay",
            "No mechanism to handle failed repayments",
            "Potential for manipulation of fee calculation"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; struct Prediction has key { id: u64, outcome: bool, total_stake: u64, resolution_time: u64 } public fun create_prediction(creator: &signer, resolution_time: u64) { let prediction = Prediction { id: generate_unique_id(), outcome: false, total_stake: 0, resolution_time }; move_to(creator, prediction); } public fun place_bet(bettor: &signer, prediction_id: u64, amount: u64, outcome: bool) acquires Prediction { let prediction = borrow_global_mut<Prediction>(@prediction_market); coin::transfer<AptosCoin>(bettor, @prediction_market, amount); prediction.total_stake = prediction.total_stake + amount; } }",
        "vulnerabilities": [
            "Lack of oracle for result verification",
            "Missing mechanism for handling disputed outcomes",
            "No provision for cancelling or updating predictions",
            "Potential for front-running high-value bets",
            "Absence of fee structure for market creators"
        ]
    },
    {
        "code": "module DAO { use std::signer; use aptos_framework::coin; struct Proposal has key { id: u64, description: vector<u8>, vote_count: u64, status: u8 } public fun create_proposal(creator: &signer, description: vector<u8>) { let proposal = Proposal { id: generate_unique_id(), description, vote_count: 0, status: 0 }; move_to(creator, proposal); } public fun vote(voter: &signer, proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@dao); let voting_power = get_voting_power(signer::address_of(voter)); proposal.vote_count = proposal.vote_count + voting_power; if (proposal.vote_count >= quorum_threshold()) { proposal.status = 1; } } }",
        "vulnerabilities": [
            "Centralized proposal creation",
            "Lack of time limit for voting",
            "Missing mechanism for vote delegation",
            "No provision for proposal execution",
            "Absence of vote weighting based on token holdings"
        ]
    },
    {
        "code": "module DynamicNFT { use std::signer; use aptos_framework::object; struct NFTMetadata has key { id: object::ObjectId, level: u64, experience: u64 } public fun mint_nft(creator: &signer) { let nft = object::create_object(signer::address_of(creator)); let metadata = NFTMetadata { id: object::id(&nft), level: 1, experience: 0 }; move_to(&nft, metadata); } public fun gain_experience(nft_owner: &signer, amount: u64) acquires NFTMetadata { let nft = object::address_to_object<NFTMetadata>(signer::address_of(nft_owner)); let metadata = borrow_global_mut<NFTMetadata>(object::object_address(&nft)); metadata.experience = metadata.experience + amount; if (metadata.experience >= level_up_threshold(metadata.level)) { metadata.level = metadata.level + 1; } } }",
        "vulnerabilities": [
            "Lack of access control for experience gain",
            "Missing mechanism for experience decay",
            "No limit on maximum level or experience",
            "Absence of event emission for level-ups",
            "Potential for manipulation of level-up threshold"
        ]
    },
    {
        "code": "module AuctionHouse { use std::signer; use aptos_framework::coin; use aptos_framework::object; struct Auction has key { id: u64, nft_id: object::ObjectId, current_bid: u64, highest_bidder: address, end_time: u64 } public fun create_auction(seller: &signer, nft_id: object::ObjectId, starting_price: u64, duration: u64) { let auction = Auction { id: generate_unique_id(), nft_id, current_bid: starting_price, highest_bidder: @auction_house, end_time: timestamp::now_seconds() + duration }; move_to(seller, auction); } public fun place_bid(bidder: &signer, auction_id: u64, bid_amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@auction_house); assert!(bid_amount > auction.current_bid, 1); assert!(timestamp::now_seconds() < auction.end_time, 2); coin::transfer<AptosCoin>(bidder, @auction_house, bid_amount); if (auction.highest_bidder != @auction_house) { coin::transfer<AptosCoin>(@auction_house, auction.highest_bidder, auction.current_bid); } auction.current_bid = bid_amount; auction.highest_bidder = signer::address_of(bidder); } }",
        "vulnerabilities": [
            "Lack of minimum bid increment",
            "Missing mechanism for auction cancellation",
            "No provision for extending auction time on last-minute bids",
            "Absence of escrow for bid amounts",
            "Potential for sniping attacks"
        ]
    },
    {
        "code": "module TokenVesting { use std::signer; use aptos_framework::coin; struct VestingSchedule has key { beneficiary: address, total_amount: u64, released_amount: u64, start_time: u64, duration: u64 } public fun create_vesting(creator: &signer, beneficiary: address, total_amount: u64, start_time: u64, duration: u64) { let schedule = VestingSchedule { beneficiary, total_amount, released_amount: 0, start_time, duration }; coin::transfer<VestingToken>(creator, @vesting_contract, total_amount); move_to(creator, schedule); } public fun release() acquires VestingSchedule { let schedule = borrow_global_mut<VestingSchedule>(@vesting_contract); let vested_amount = calculate_vested_amount(schedule); let to_release = vested_amount - schedule.released_amount; coin::transfer<VestingToken>(@vesting_contract, schedule.beneficiary, to_release); schedule.released_amount = vested_amount; } }",
        "vulnerabilities": [
            "Lack of revocation mechanism",
            "Missing functionality for partial releases",
            "No provision for changing beneficiary",
            "Absence of cliff period implementation",
            "Potential for precision loss in vesting calculations"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; struct Market { id: u64, description: vector<u8>, resolution_time: u64, outcome: bool, resolved: bool } struct Position { market_id: u64, is_yes: bool, amount: u64 } public fun create_market(account: &signer, description: vector<u8>, resolution_time: u64) { let market_id = get_next_market_id(); move_to(account, Market { id: market_id, description, resolution_time, outcome: false, resolved: false }); } public fun place_bet(account: &signer, market_id: u64, is_yes: bool, amount: u64) acquires Market { let market = borrow_global<Market>(@prediction_market); assert!(!market.resolved, 1); coin::transfer<StableCoin>(account, @prediction_market, amount); move_to(account, Position { market_id, is_yes, amount }); } public fun resolve_market(oracle: &signer, market_id: u64, outcome: bool) acquires Market { assert!(signer::address_of(oracle) == @trusted_oracle, 1); let market = borrow_global_mut<Market>(@prediction_market); market.outcome = outcome; market.resolved = true; } }",
        "vulnerabilities": [
            "Centralized oracle for market resolution",
            "Lack of mechanism to cancel bets",
            "Missing liquidity pool for instant settlement",
            "Absence of fee distribution to market creators",
            "No protection against last-minute large bets"
        ]
    },
    {
        "code": "module TimelockVault { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct TimeLock { owner: address, amount: u64, unlock_time: u64 } public fun deposit(account: &signer, amount: u64, lock_duration: u64) { let sender = signer::address_of(account); coin::transfer<AptosCoin>(account, @vault_address, amount); let unlock_time = timestamp::now_seconds() + lock_duration; move_to(account, TimeLock { owner: sender, amount, unlock_time }); } public fun withdraw(account: &signer) acquires TimeLock { let sender = signer::address_of(account); let timelock = move_from<TimeLock>(sender); assert!(timestamp::now_seconds() >= timelock.unlock_time, 1); coin::transfer<AptosCoin>(@vault_address, sender, timelock.amount); } }",
        "vulnerabilities": [
            "No partial withdrawal mechanism",
            "Lack of emergency withdrawal function",
            "Missing events for deposit and withdrawal",
            "Absence of interest accrual for locked funds",
            "No mechanism to extend lock duration"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use aptos_framework::coin; struct MultiSig { owners: vector<address>, required_confirmations: u64 } struct Transaction { id: u64, to: address, amount: u64, confirmations: u64, executed: bool } public fun create_wallet(account: &signer, owners: vector<address>, required_confirmations: u64) { assert!(required_confirmations <= vector::length(&owners), 1); move_to(account, MultiSig { owners, required_confirmations }); } public fun submit_transaction(account: &signer, to: address, amount: u64) acquires MultiSig { let multisig = borrow_global<MultiSig>(@wallet_address); assert!(vector::contains(&multisig.owners, &signer::address_of(account)), 1); let tx_id = get_next_tx_id(); move_to(account, Transaction { id: tx_id, to, amount, confirmations: 1, executed: false }); } public fun confirm_transaction(account: &signer, tx_id: u64) acquires MultiSig, Transaction { let multisig = borrow_global<MultiSig>(@wallet_address); let tx = borrow_global_mut<Transaction>(@wallet_address); assert!(vector::contains(&multisig.owners, &signer::address_of(account)), 1); tx.confirmations = tx.confirmations + 1; if (tx.confirmations >= multisig.required_confirmations) { coin::transfer<AptosCoin>(@wallet_address, tx.to, tx.amount); tx.executed = true; } } }",
        "vulnerabilities": [
            "No mechanism to change owners or required confirmations",
            "Lack of transaction cancellation functionality",
            "Missing events for wallet creation and transaction submission",
            "Absence of time lock for large transactions",
            "No protection against duplicate confirmations"
        ]
    },
    {
        "code": "module TokenVesting { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct VestingSchedule { beneficiary: address, total_amount: u64, start_time: u64, duration: u64, released_amount: u64 } public fun create_vesting(account: &signer, beneficiary: address, total_amount: u64, start_time: u64, duration: u64) { coin::transfer<VestingToken>(account, @vesting_contract, total_amount); move_to(account, VestingSchedule { beneficiary, total_amount, start_time, duration, released_amount: 0 }); } public fun release(account: &signer) acquires VestingSchedule { let sender = signer::address_of(account); let vesting = borrow_global_mut<VestingSchedule>(@vesting_contract); assert!(sender == vesting.beneficiary, 1); let current_time = timestamp::now_seconds(); let vested_amount = if (current_time >= vesting.start_time + vesting.duration) { vesting.total_amount } else { vesting.total_amount * (current_time - vesting.start_time) / vesting.duration }; let releasable = vested_amount - vesting.released_amount; coin::transfer<VestingToken>(@vesting_contract, sender, releasable); vesting.released_amount = vesting.released_amount + releasable; } }",
        "vulnerabilities": [
            "No mechanism to revoke or modify vesting schedule",
            "Lack of cliff period implementation",
            "Missing events for vesting creation and token release",
            "Absence of multiple vesting schedules per beneficiary",
            "No protection against contract upgrade affecting ongoing vestings"
        ]
    },
    {
        "code": "module SupplyChainTracking { use std::signer; struct Product { id: u64, name: vector<u8>, current_owner: address, status: u8 } struct Shipment { product_id: u64, from: address, to: address, timestamp: u64 } public fun create_product(account: &signer, name: vector<u8>) { let sender = signer::address_of(account); let product_id = get_next_product_id(); move_to(account, Product { id: product_id, name, current_owner: sender, status: 0 }); } public fun transfer_product(account: &signer, product_id: u64, to: address) acquires Product { let product = borrow_global_mut<Product>(@supply_chain); assert!(signer::address_of(account) == product.current_owner, 1); product.current_owner = to; move_to(account, Shipment { product_id, from: signer::address_of(account), to, timestamp: timestamp::now_seconds() }); } public fun update_status(account: &signer, product_id: u64, new_status: u8) acquires Product { let product = borrow_global_mut<Product>(@supply_chain); assert!(signer::address_of(account) == product.current_owner, 1); product.status = new_status; } }",
        "vulnerabilities": [
            "Lack of access control for different supply chain roles",
            "Missing events for product creation and transfers",
            "Absence of product authentication mechanism",
            "No functionality to handle product recalls or returns",
            "Lack of privacy for sensitive supply chain data"
        ]
    },
    {
        "code": "module FlashLoan { use aptos_framework::coin; struct FlashLoanFee has key { fee_percentage: u64, } struct LoanInfo has store { amount: u64, fee: u64, } public fun initialize(admin: &signer) { move_to(admin, FlashLoanFee { fee_percentage: 1, // 0.1% fee }); } public fun execute_flash_loan<CoinType>(borrower: &signer, amount: u64, callback: |&signer, LoanInfo|) acquires FlashLoanFee { let fee_info = borrow_global<FlashLoanFee>(@flash_loan_address); let fee = (amount * fee_info.fee_percentage) / 1000; let loan_info = LoanInfo { amount, fee }; let loan = coin::withdraw<CoinType>(@flash_loan_address, amount); coin::deposit(signer::address_of(borrower), loan); callback(borrower, loan_info); let repayment = coin::withdraw<CoinType>(borrower, amount + fee); coin::deposit(@flash_loan_address, repayment); } }",
        "vulnerabilities": [
            "No checks for available liquidity before loan execution",
            "Lack of access control for initialize function",
            "Potential for reentrancy attacks in execute_flash_loan",
            "Missing events for flash loan executions",
            "No mechanism to update fee percentage",
            "Centralized control of the flash loan contract",
            "Potential integer overflow in fee calculation",
            "Lack of pausable functionality for emergencies",
            "No checks for minimum or maximum loan amounts",
            "Vulnerability to malicious callbacks that may not repay the loan"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::vector; use aptos_framework::coin; struct Transaction has store { to: address, amount: u64, executed: bool, } struct MultiSig has key { owners: vector<address>, required_confirmations: u64, transaction_count: u64, transactions: vector<Transaction>, confirmations: vector<vector<bool>>, } public fun create_wallet(creator: &signer, owners: vector<address>, required: u64) { assert!(vector::length(&owners) >= required, 1); move_to(creator, MultiSig { owners, required_confirmations: required, transaction_count: 0, transactions: vector::empty(), confirmations: vector::empty(), }); } public fun submit_transaction(submitter: &signer, to: address, amount: u64) acquires MultiSig { let multi_sig = borrow_global_mut<MultiSig>(@wallet_address); assert!(vector::contains(&multi_sig.owners, &signer::address_of(submitter)), 1); let tx = Transaction { to, amount, executed: false }; vector::push_back(&mut multi_sig.transactions, tx); vector::push_back(&mut multi_sig.confirmations, vector::empty()); multi_sig.transaction_count = multi_sig.transaction_count + 1; } public fun confirm_transaction(confirmer: &signer, tx_id: u64) acquires MultiSig { let multi_sig = borrow_global_mut<MultiSig>(@wallet_address); assert!(vector::contains(&multi_sig.owners, &signer::address_of(confirmer)), 1); assert!(tx_id < multi_sig.transaction_count, 2); let confirmations = vector::borrow_mut(&mut multi_sig.confirmations, tx_id); vector::push_back(confirmations, true); } public fun execute_transaction(executor: &signer, tx_id: u64) acquires MultiSig { let multi_sig = borrow_global_mut<MultiSig>(@wallet_address); assert!(vector::contains(&multi_sig.owners, &signer::address_of(executor)), 1); assert!(tx_id < multi_sig.transaction_count, 2); let transaction = vector::borrow_mut(&mut multi_sig.transactions, tx_id); assert!(!transaction.executed, 3); let confirmations = vector::borrow(&multi_sig.confirmations, tx_id); assert!(vector::length(confirmations) >= multi_sig.required_confirmations, 4); transaction.executed = true; let payment = coin::withdraw<AptosCoin>(@wallet_address, transaction.amount); coin::deposit(transaction.to, payment); } }",
        "vulnerabilities": [
            "Lack of mechanism to change owners or required confirmations",
            "No checks for duplicate owners in create_wallet",
            "Missing events for transaction submission, confirmation, and execution",
            "Potential for front-running in confirm_transaction and execute_transaction",
            "No mechanism to cancel or invalidate pending transactions",
            "Centralized control of the wallet address",
            "Lack of time-lock for transaction execution",
            "No support for different coin types in transactions",
            "Potential integer overflow in transaction_count",
            "Missing checks for zero amount transactions"
        ]
    },
    {
        "code": "module DecentralizedExchange { use aptos_framework::coin; use aptos_framework::timestamp; struct LiquidityPool<phantom TokenX, phantom TokenY> has key { reserve_x: coin::Coin<TokenX>, reserve_y: coin::Coin<TokenY>, lp_token_supply: u64, } struct LPToken<phantom TokenX, phantom TokenY> has key { value: u64, } public fun create_pool<TokenX, TokenY>(creator: &signer, initial_x: u64, initial_y: u64) { let token_x = coin::withdraw<TokenX>(creator, initial_x); let token_y = coin::withdraw<TokenY>(creator, initial_y); move_to(creator, LiquidityPool<TokenX, TokenY> { reserve_x: token_x, reserve_y: token_y, lp_token_supply: (initial_x * initial_y) as u64, }); move_to(creator, LPToken<TokenX, TokenY> { value: (initial_x * initial_y) as u64 }); } public fun add_liquidity<TokenX, TokenY>(provider: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool, LPToken { let pool = borrow_global_mut<LiquidityPool<TokenX, TokenY>>(@dex_address); let token_x = coin::withdraw<TokenX>(provider, amount_x); let token_y = coin::withdraw<TokenY>(provider, amount_y); let lp_tokens = min( (amount_x * pool.lp_token_supply) / coin::value(&pool.reserve_x), (amount_y * pool.lp_token_supply) / coin::value(&pool.reserve_y) ); coin::merge(&mut pool.reserve_x, token_x); coin::merge(&mut pool.reserve_y, token_y); pool.lp_token_supply = pool.lp_token_supply + lp_tokens; if (!exists<LPToken<TokenX, TokenY>>(signer::address_of(provider))) { move_to(provider, LPToken<TokenX, TokenY> { value: 0 }); } let provider_lp_tokens = borrow_global_mut<LPToken<TokenX, TokenY>>(signer::address_of(provider)); provider_lp_tokens.value = provider_lp_tokens.value + lp_tokens; } public fun swap<TokenX, TokenY>(trader: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<TokenX, TokenY>>(@dex_address); let token_in = coin::withdraw<TokenX>(trader, amount_in); let reserve_in = coin::value(&pool.reserve_x); let reserve_out = coin::value(&pool.reserve_y); let amount_out = (amount_in * reserve_out) / (reserve_in + amount_in); assert!(amount_out >= min_amount_out, 1); coin::merge(&mut pool.reserve_x, token_in); let token_out = coin::extract(&mut pool.reserve_y, amount_out); coin::deposit(signer::address_of(trader), token_out); } }",
        "vulnerabilities": [
            "Lack of slippage protection in add_liquidity",
            "No mechanism to remove liquidity",
            "Potential for front-running attacks in swap function",
            "Missing events for important operations (pool creation, liquidity addition, swaps)",
            "No access control for pool creation",
            "Centralized control of the DEX address",
            "Potential integer overflow in LP token calculation",
            "No fees implemented for swaps or liquidity provision"
        ]
    },
    {
        "code": "module StableCoin { struct ReservePool has key { collateral: u64, stablecoins: u64 } public fun mint_stablecoin(minter: &signer, collateral_amount: u64) acquires ReservePool { let pool = borrow_global_mut<ReservePool>(@reserve_address); pool.collateral += collateral_amount; let mint_amount = collateral_amount * 2; // Simplified 200% collateralization pool.stablecoins += mint_amount; // Transfer stablecoins to minter } }",
        "vulnerabilities": [
            "No price oracle for collateral valuation",
            "Lack of liquidation mechanism",
            "Fixed collateralization ratio may not adapt to market conditions"
        ]
    },
    {
        "code": "module FlashLoan { struct LendingPool has key { balance: u64 } public fun flash_loan(borrower: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool>(@pool_address); assert!(pool.balance >= amount, 1); pool.balance -= amount; // Transfer amount to borrower // Execute borrower's code here assert!(pool.balance >= amount, 2); // Ensure repayment pool.balance += amount; // Add fee } }",
        "vulnerabilities": [
            "No access control on flash loan initiation",
            "Lack of fee mechanism",
            "Potential for reentrancy attacks"
        ]
    },
    {
        "code": "module TimeLock { struct LockedFunds has key { owner: address, amount: u64, unlock_time: u64 } public fun lock_funds(owner: &signer, amount: u64, lock_duration: u64) { let current_time = timestamp::now_seconds(); move_to(owner, LockedFunds { owner: signer::address_of(owner), amount, unlock_time: current_time + lock_duration }); } public fun withdraw(owner: &signer) acquires LockedFunds { let locked = borrow_global_mut<LockedFunds>(signer::address_of(owner)); assert!(timestamp::now_seconds() >= locked.unlock_time, 1); // Transfer funds to owner } }",
        "vulnerabilities": [
            "No partial withdrawal option",
            "Lack of emergency unlock mechanism",
            "Potential issues with timestamp manipulation"
        ]
    },
    {
        "code": "module MultiSigWallet { struct Wallet has key { owners: vector<address>, required_signatures: u64 } public fun create_wallet(creator: &signer, owners: vector<address>, required_signatures: u64) { assert!(vector::length(&owners) >= required_signatures, 1); move_to(creator, Wallet { owners, required_signatures }); } public fun submit_transaction(submitter: &signer, destination: address, amount: u64) acquires Wallet { let wallet = borrow_global_mut<Wallet>(@wallet_address); assert!(vector::contains(&wallet.owners, &signer::address_of(submitter)), 2); // Logic for transaction submission and signature collection } }",
        "vulnerabilities": [
            "No mechanism to change owners or required signatures",
            "Lack of transaction expiration",
            "Potential for signature reuse across transactions"
        ]
    },
    {
        "code": "module Lottery { struct LotteryPool has key { tickets: vector<address>, prize: u64 } public fun buy_ticket(buyer: &signer) acquires LotteryPool { let pool = borrow_global_mut<LotteryPool>(@pool_address); vector::push_back(&mut pool.tickets, signer::address_of(buyer)); pool.prize += 1000000; // Assume 1 APT ticket price } public fun draw_winner(admin: &signer) acquires LotteryPool { let pool = borrow_global_mut<LotteryPool>(@pool_address); let winner_index = (timestamp::now_microseconds() as u64) % vector::length(&pool.tickets); let winner = *vector::borrow(&pool.tickets, winner_index); // Transfer prize to winner } }",
        "vulnerabilities": [
            "Centralized winner selection",
            "No randomness source for winner selection",
            "Lack of access control for drawing winner"
        ]
    },
    {
        "code": "module SupplyChain { struct Product has key { manufacturer: address, current_owner: address, status: u8 } public fun create_product(manufacturer: &signer) { move_to(manufacturer, Product { manufacturer: signer::address_of(manufacturer), current_owner: signer::address_of(manufacturer), status: 0 }); } public fun transfer_ownership(current_owner: &signer, new_owner: address, product_id: u64) acquires Product { let product = borrow_global_mut<Product>(@product_address); assert!(product.current_owner == signer::address_of(current_owner), 1); product.current_owner = new_owner; product.status += 1; } }",
        "vulnerabilities": [
            "No verification of new owner's authenticity",
            "Lack of product history tracking",
            "No mechanism to handle lost or stolen products"
        ]
    },
    {
        "code": "module Escrow { struct EscrowAccount has key { seller: address, buyer: address, amount: u64, released: bool } public fun create_escrow(buyer: &signer, seller: address, amount: u64) { move_to(buyer, EscrowAccount { seller, buyer: signer::address_of(buyer), amount, released: false }); } public fun release_funds(seller: &signer) acquires EscrowAccount { let escrow = borrow_global_mut<EscrowAccount>(@escrow_address); assert!(escrow.seller == signer::address_of(seller), 1); assert!(!escrow.released, 2); // Transfer funds to seller escrow.released = true; } }",
        "vulnerabilities": [
            "No dispute resolution mechanism",
            "Lack of time-based auto-release",
            "No partial release option"
        ]
    },
    {
        "code": "module DataOracle { struct OracleData has key { value: u64, last_updated: u64 } public fun update_data(oracle: &signer, new_value: u64) acquires OracleData { let data = borrow_global_mut<OracleData>(@oracle_address); data.value = new_value; data.last_updated = timestamp::now_seconds(); } public fun get_data(): (u64, u64) acquires OracleData { let data = borrow_global<OracleData>(@oracle_address); (data.value, data.last_updated) } }",
        "vulnerabilities": [
            "Single point of failure with one oracle",
            "No mechanism to detect and handle stale data",
            "Lack of access control for data updates"
        ]
    },
    {
        "code": "module TokenVesting { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct VestingSchedule has key { beneficiary: address, total_amount: u64, start_time: u64, duration: u64, released_amount: u64, } public fun create_vesting(account: &signer, beneficiary: address, total_amount: u64, duration: u64) { let sender = signer::address_of(account); move_to(account, VestingSchedule { beneficiary, total_amount, start_time: timestamp::now_seconds(), duration, released_amount: 0, }); coin::transfer<AptosCoin>(account, @vesting, total_amount); } public fun release(account: &signer) acquires VestingSchedule { let sender = signer::address_of(account); let vesting = borrow_global_mut<VestingSchedule>(sender); let vested_amount = (vesting.total_amount * (timestamp::now_seconds() - vesting.start_time) / vesting.duration).min(vesting.total_amount); let unreleased = vested_amount - vesting.released_amount; vesting.released_amount = vesting.released_amount + unreleased; coin::transfer<AptosCoin>(@vesting, vesting.beneficiary, unreleased); } }",
        "vulnerabilities": [
            "No mechanism to handle multiple vesting schedules per beneficiary",
            "Lack of access control for vesting creation",
            "Missing events for vesting creation and token release",
            "No option for cliff periods in vesting schedule",
            "Absence of emergency revocation mechanism",
            "Potential for precision loss in vesting calculations",
            "No checks for minimum vesting duration",
            "Missing functionality to update beneficiary address",
            "Lack of support for different token types",
            "No mechanism to pause or resume vesting schedules"
        ]
    },
    {
        "code": "module DAO { use std::signer; use aptos_framework::coin; struct Proposal has key { proposer: address, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64, executed: bool, } struct MembershipToken {} public fun create_proposal(account: &signer, description: vector<u8>) { let sender = signer::address_of(account); assert!(coin::balance<MembershipToken>(sender) > 0, 1); move_to(account, Proposal { proposer: sender, description, yes_votes: 0, no_votes: 0, end_time: aptos_framework::timestamp::now_seconds() + 604800, // 1 week executed: false, }); } public fun vote(account: &signer, proposal_id: u64, support: bool) acquires Proposal { let sender = signer::address_of(account); let voting_power = coin::balance<MembershipToken>(sender); let proposal = borrow_global_mut<Proposal>(proposal_id); if (support) { proposal.yes_votes = proposal.yes_votes + voting_power; } else { proposal.no_votes = proposal.no_votes + voting_power; } } public fun execute_proposal(proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_id); assert!(aptos_framework::timestamp::now_seconds() > proposal.end_time, 2); assert!(!proposal.executed, 3); assert!(proposal.yes_votes > proposal.no_votes, 4); // Execute proposal logic here proposal.executed = true; } }",
        "vulnerabilities": [
            "No quorum requirements for proposal execution",
            "Lack of time lock for approved proposals",
            "Missing events for proposal creation, voting, and execution",
            "No mechanism to prevent double voting",
            "Absence of proposal cancellation functionality",
            "Potential for flash loan attacks to manipulate voting",
            "No delegation mechanism for voting power",
            "Lack of vote privacy (on-chain votes are visible)",
            "Missing checks for minimum proposal duration",
            "No support for quadratic voting or other advanced voting mechanisms"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; use aptos_framework::coin; use aptos_framework::event; struct BridgePool has key { locked_amount: u64, } struct BridgeEvent has drop, store { user: address, amount: u64, destination_chain: vector<u8>, } struct BridgeEventHandle has key { bridge_events: event::EventHandle<BridgeEvent>, } public fun lock_tokens(account: &signer, amount: u64, destination_chain: vector<u8>) acquires BridgePool, BridgeEventHandle { let sender = signer::address_of(account); let pool = borrow_global_mut<BridgePool>(@bridge); coin::transfer<AptosCoin>(account, @bridge, amount); pool.locked_amount = pool.locked_amount + amount; let event_handle = borrow_global_mut<BridgeEventHandle>(@bridge); event::emit_event(&mut event_handle.bridge_events, BridgeEvent { user: sender, amount, destination_chain, }); } public fun unlock_tokens(account: &signer, amount: u64, proof: vector<u8>) acquires BridgePool { let pool = borrow_global_mut<BridgePool>(@bridge); // Verify proof logic here pool.locked_amount = pool.locked_amount - amount; coin::transfer<AptosCoin>(@bridge, signer::address_of(account), amount); } }",
        "vulnerabilities": [
            "Lack of proper verification for cross-chain proofs",
            "No mechanism to handle failed or stuck transactions",
            "Missing access control for unlocking tokens",
            "Absence of rate limiting to prevent spamming",
            "No support for different token types",
            "Lack of emergency pause functionality",
            "Missing events for token unlocking",
            "No mechanism to update supported chains dynamically",
            "Potential for front-running attacks on unlock transactions",
            "Absence of fee mechanism for bridge operations"
        ]
    },
    {
        "code": "module LiquidStaking { use std::signer; use aptos_framework::coin; use aptos_framework::stake; struct StakedCoin {} public fun stake(account: &signer, amount: u64) { let sender = signer::address_of(account); coin::transfer<AptosCoin>(account, @staking_pool, amount); let staked_amount = amount * 99 / 100; // 1% fee stake::add_stake(@staking_pool, staked_amount); coin::mint<StakedCoin>(staked_amount, account); } public fun unstake(account: &signer, amount: u64) { let sender = signer::address_of(account); coin::burn<StakedCoin>(amount, account); stake::unlock(@staking_pool, amount); // Assume instant unstaking for simplicity coin::transfer<AptosCoin>(@staking_pool, sender, amount); } public fun claim_rewards(account: &signer) { let sender = signer::address_of(account); let rewards = stake::distribute_rewards(@staking_pool); coin::transfer<AptosCoin>(@staking_pool, sender, rewards); } }",
        "vulnerabilities": [
            "No slashing protection for stakers",
            "Lack of unbonding period for unstaking",
            "Missing events for staking, unstaking, and reward claiming",
            "No mechanism to update staking parameters",
            "Absence of minimum stake amount requirement"
        ]
    },
    {
        "code": "module SimpleEscrow { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Escrow<phantom CoinType> has key { seller: address, buyer: address, arbiter: address, amount: u64, release_time: u64, completed: bool, } const E_NOT_AUTHORIZED: u64 = 1; const E_ALREADY_COMPLETED: u64 = 2; const E_RELEASE_TIME_NOT_REACHED: u64 = 3; public fun create_escrow<CoinType>(buyer: &signer, seller: address, arbiter: address, amount: u64, release_time: u64) { let sender = signer::address_of(buyer); move_to(buyer, Escrow<CoinType> { seller, buyer: sender, arbiter, amount, release_time, completed: false, }); coin::transfer<CoinType>(buyer, @escrow_address, amount); } public fun release_to_seller<CoinType>(account: &signer) acquires Escrow<CoinType> { let sender = signer::address_of(account); let escrow = borrow_global_mut<Escrow<CoinType>>(@escrow_address); assert!(!escrow.completed, E_ALREADY_COMPLETED); assert!(sender == escrow.buyer || sender == escrow.arbiter, E_NOT_AUTHORIZED); escrow.completed = true; coin::transfer<CoinType>(@escrow_address, escrow.seller, escrow.amount); } public fun refund_to_buyer<CoinType>(account: &signer) acquires Escrow<CoinType> { let sender = signer::address_of(account); let escrow = borrow_global_mut<Escrow<CoinType>>(@escrow_address); assert!(!escrow.completed, E_ALREADY_COMPLETED); assert!(sender == escrow.seller || sender == escrow.arbiter, E_NOT_AUTHORIZED); escrow.completed = true; coin::transfer<CoinType>(@escrow_address, escrow.buyer, escrow.amount); } public fun auto_release<CoinType>() acquires Escrow<CoinType> { let escrow = borrow_global_mut<Escrow<CoinType>>(@escrow_address); assert!(!escrow.completed, E_ALREADY_COMPLETED); assert!(timestamp::now_seconds() >= escrow.release_time, E_RELEASE_TIME_NOT_REACHED); escrow.completed = true; coin::transfer<CoinType>(@escrow_address, escrow.seller, escrow.amount); } }",
        "vulnerabilities": [
            "Lack of access control for create_escrow function",
            "No mechanism to extend or shorten the release time",
            "Missing event emissions for escrow creation and completion",
            "Potential reentrancy in release and refund functions",
            "No partial release or refund functionality",
            "Centralized control of the escrow contract",
            "Lack of fee mechanism for the arbiter",
            "No checks for contract balance before transfers",
            "Potential for frontrunning in auto_release function",
            "Missing checks for zero address in transfers"
        ]
    },
    {
        "code": "module SimpleDEX { use std::signer; use aptos_framework::coin; use aptos_framework::managed_coin; struct LiquidityPool<phantom CoinTypeA, phantom CoinTypeB> has key { coin_a: coin::Coin<CoinTypeA>, coin_b: coin::Coin<CoinTypeB>, } public fun create_pool<CoinTypeA, CoinTypeB>(creator: &signer, amount_a: u64, amount_b: u64) { let sender = signer::address_of(creator); assert!(!exists<LiquidityPool<CoinTypeA, CoinTypeB>>(sender), 1); let coin_a = coin::withdraw<CoinTypeA>(creator, amount_a); let coin_b = coin::withdraw<CoinTypeB>(creator, amount_b); move_to(creator, LiquidityPool<CoinTypeA, CoinTypeB> { coin_a, coin_b }); } public fun swap<CoinTypeA, CoinTypeB>(account: &signer, amount: u64, min_out: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(@dex_address); let coin_in = coin::withdraw<CoinTypeA>(account, amount); let balance_a = coin::value(&pool.coin_a); let balance_b = coin::value(&pool.coin_b); let out_amount = (amount * balance_b) / (balance_a + amount); assert!(out_amount >= min_out, 2); coin::merge(&mut pool.coin_a, coin_in); let coin_out = coin::extract(&mut pool.coin_b, out_amount); coin::deposit(sender, coin_out); } }",
        "vulnerabilities": [
            "No slippage protection",
            "Vulnerable to flash loan attacks",
            "Lack of fee mechanism for liquidity providers"
        ]
    },
    {
        "code": "module TokenStaking { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakeInfo has key { amount: u64, start_time: u64, reward_rate: u64, } const E_INSUFFICIENT_BALANCE: u64 = 1; const E_NO_STAKE_FOUND: u64 = 2; const E_MINIMUM_STAKE_DURATION_NOT_MET: u64 = 3; public fun stake<CoinType>(account: &signer, amount: u64, reward_rate: u64) { let sender = signer::address_of(account); assert!(coin::balance<CoinType>(sender) >= amount, E_INSUFFICIENT_BALANCE); coin::transfer<CoinType>(account, @staking_pool, amount); move_to(account, StakeInfo { amount, start_time: timestamp::now_seconds(), reward_rate, }); } public fun unstake<CoinType>(account: &signer) acquires StakeInfo { let sender = signer::address_of(account); let stake_info = move_from<StakeInfo>(sender); assert!(timestamp::now_seconds() - stake_info.start_time >= 7 * 24 * 60 * 60, E_MINIMUM_STAKE_DURATION_NOT_MET); let reward = (stake_info.amount * stake_info.reward_rate * (timestamp::now_seconds() - stake_info.start_time)) / (365 * 24 * 60 * 60 * 100); let total_amount = stake_info.amount + reward; coin::transfer<CoinType>(@staking_pool, sender, total_amount); } public fun get_stake_info(account: address): (u64, u64, u64) acquires StakeInfo { let stake_info = borrow_global<StakeInfo>(account); (stake_info.amount, stake_info.start_time, stake_info.reward_rate) } }",
        "vulnerabilities": [
            "No access control for setting reward rates",
            "Potential for integer overflow in reward calculation",
            "Lack of slashing mechanism for malicious actors",
            "No cap on total staked amount",
            "Missing events for important actions like staking and unstaking",
            "No mechanism to pause staking in case of emergencies",
            "Centralized control of the staking pool",
            "No checks for minimum stake amount",
            "Potential for frontrunning in unstake function",
            "Lack of compound interest calculation"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct NFT has key, store { id: u64, creator: address, metadata: vector<u8>, } struct Listing has key { nft: NFT, price: u64, } public fun mint_nft(creator: &signer, metadata: vector<u8>): NFT { let sender = signer::address_of(creator); let nft = NFT { id: get_next_id(), creator: sender, metadata }; nft } public fun list_nft(seller: &signer, nft: NFT, price: u64) { let sender = signer::address_of(seller); move_to(seller, Listing { nft, price }); } public fun buy_nft<CoinType>(buyer: &signer, seller: address) acquires Listing { let sender = signer::address_of(buyer); let Listing { nft, price } = move_from<Listing>(seller); let payment = coin::withdraw<CoinType>(buyer, price); coin::deposit(seller, payment); move_to(buyer, nft); } public fun cancel_listing(seller: &signer) acquires Listing { let sender = signer::address_of(seller); let Listing { nft, price: _ } = move_from<Listing>(sender); move_to(seller, nft); } public fun get_next_id(): u64 { static mut next_id: u64 = 0; next_id = next_id + 1; next_id } }",
        "vulnerabilities": [
            "Lack of royalty mechanism for original creators",
            "No verification of NFT authenticity",
            "Potential for front-running in purchase transactions"
        ]
    },
    {
        "code": "module TimedSavings { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct SavingsAccount<phantom CoinType> has key { balance: u64, lock_end_time: u64, } public fun create_account<CoinType>(account: &signer, initial_deposit: u64, lock_duration: u64) { let sender = signer::address_of(account); assert!(!exists<SavingsAccount<CoinType>>(sender), 1); move_to(account, SavingsAccount<CoinType> { balance: initial_deposit, lock_end_time: timestamp::now_seconds() + lock_duration }); coin::transfer<CoinType>(account, @savings_address, initial_deposit); } public fun deposit<CoinType>(account: &signer, amount: u64) acquires SavingsAccount { let sender = signer::address_of(account); let savings = borrow_global_mut<SavingsAccount<CoinType>>(sender); savings.balance = savings.balance + amount; coin::transfer<CoinType>(account, @savings_address, amount); } public fun withdraw<CoinType>(account: &signer, amount: u64) acquires SavingsAccount { let sender = signer::address_of(account); let savings = borrow_global_mut<SavingsAccount<CoinType>>(sender); assert!(timestamp::now_seconds() >= savings.lock_end_time, 2); assert!(amount <= savings.balance, 3); savings.balance = savings.balance - amount; coin::transfer<CoinType>(@savings_address, sender, amount); } }",
        "vulnerabilities": [
            "Lack of partial withdrawal before lock end time",
            "No mechanism to extend lock duration"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Market<phantom CoinType> has key { question: vector<u8>, end_time: u64, total_yes: u64, total_no: u64, outcome: bool, resolved: bool, } public fun create_market<CoinType>(creator: &signer, question: vector<u8>, duration: u64) { let sender = signer::address_of(creator); move_to(creator, Market<CoinType> { question, end_time: timestamp::now_seconds() + duration, total_yes: 0, total_no: 0, outcome: false, resolved: false }); } public fun predict<CoinType>(predictor: &signer, amount: u64, prediction: bool) acquires Market { let sender = signer::address_of(predictor); let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(!market.resolved && timestamp::now_seconds() < market.end_time, 1); if (prediction) { market.total_yes = market.total_yes + amount; } else { market.total_no = market.total_no + amount; } coin::transfer<CoinType>(predictor, @market_address, amount); } public fun resolve<CoinType>(resolver: &signer, outcome: bool) acquires Market { let sender = signer::address_of(resolver); let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(!market.resolved && timestamp::now_seconds() >= market.end_time, 2); market.outcome = outcome; market.resolved = true; } public fun claim_winnings<CoinType>(claimer: &signer) acquires Market { let sender = signer::address_of(claimer); let market = borrow_global<Market<CoinType>>(@market_address); assert!(market.resolved, 3); // Implement claiming logic here } }",
        "vulnerabilities": [
            "Centralized market resolution",
            "Lack of oracle integration for automated resolution"
        ]
    },
    {
        "code": "module DecentralizedVoting { use std::signer; use std::vector; use aptos_framework::timestamp; struct Ballot has key { proposals: vector<Proposal>, end_time: u64, } struct Proposal has store { name: vector<u8>, vote_count: u64, } struct Vote has key { proposal_index: u64, } public fun create_ballot(creator: &signer, proposals: vector<vector<u8>>, duration: u64) { let ballot = Ballot { proposals: vector::empty(), end_time: timestamp::now_seconds() + duration }; let i = 0; while (i < vector::length(&proposals)) { vector::push_back(&mut ballot.proposals, Proposal { name: *vector::borrow(&proposals, i), vote_count: 0 }); i = i + 1; }; move_to(creator, ballot); } public fun cast_vote(voter: &signer, proposal_index: u64) acquires Ballot { let sender = signer::address_of(voter); assert!(!exists<Vote>(sender), 1); let ballot = borrow_global_mut<Ballot>(@ballot_address); assert!(timestamp::now_seconds() < ballot.end_time, 2); assert!(proposal_index < vector::length(&ballot.proposals), 3); let proposal = vector::borrow_mut(&mut ballot.proposals, proposal_index); proposal.vote_count = proposal.vote_count + 1; move_to(voter, Vote { proposal_index }); } public fun get_winner() acquires Ballot { let ballot = borrow_global<Ballot>(@ballot_address); assert!(timestamp::now_seconds() >= ballot.end_time, 4); // Implement winner calculation logic here } }",
        "vulnerabilities": [
            "No mechanism to update proposals or voting duration",
            "Lack of vote weight based on token holdings"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Listing has key { seller: address, token_id: u64, price: u64, } public fun list_nft(seller: &signer, token_id: u64, price: u64) { let sender = signer::address_of(seller); move_to(seller, Listing { seller: sender, token_id, price }); } public fun buy_nft<CoinType>(buyer: &signer, token_id: u64) acquires Listing { let sender = signer::address_of(buyer); let listing = move_from<Listing>(@marketplace_address); assert!(listing.token_id == token_id, 1); coin::transfer<CoinType>(buyer, listing.seller, listing.price); // Transfer NFT logic here } public fun cancel_listing(seller: &signer, token_id: u64) acquires Listing { let sender = signer::address_of(seller); let listing = move_from<Listing>(@marketplace_address); assert!(listing.seller == sender, 1); assert!(listing.token_id == token_id, 2); } }",
        "vulnerabilities": [
            "Lack of access control for list_nft function",
            "No mechanism to update listing price",
            "Missing event emissions for listing creation, purchase, and cancellation",
            "Potential reentrancy in buy_nft function",
            "No royalty mechanism for original creators",
            "Centralized control of the marketplace contract",
            "Lack of escrow mechanism for secure trades",
            "No checks for contract balance before transfers",
            "Potential for frontrunning in buy_nft function",
            "Missing checks for zero values in listing creation"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Market<phantom CoinType> has key { creator: address, description: vector<u8>, resolution_time: u64, total_yes_shares: u64, total_no_shares: u64, resolved: bool, outcome: bool, } struct UserPosition<phantom CoinType> has key { yes_shares: u64, no_shares: u64, } public fun create_market<CoinType>(creator: &signer, description: vector<u8>, resolution_time: u64) { let sender = signer::address_of(creator); assert!(!exists<Market<CoinType>>(sender), 1); move_to(creator, Market<CoinType> { creator: sender, description, resolution_time, total_yes_shares: 0, total_no_shares: 0, resolved: false, outcome: false, }); } public fun buy_shares<CoinType>(buyer: &signer, amount: u64, yes: bool) acquires Market, UserPosition { let sender = signer::address_of(buyer); let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(!market.resolved, 2); assert!(timestamp::now_seconds() < market.resolution_time, 3); coin::transfer<CoinType>(buyer, @market_address, amount); if (yes) { market.total_yes_shares = market.total_yes_shares + amount; } else { market.total_no_shares = market.total_no_shares + amount; } if (!exists<UserPosition<CoinType>>(sender)) { move_to(buyer, UserPosition<CoinType> { yes_shares: 0, no_shares: 0 }); } let position = borrow_global_mut<UserPosition<CoinType>>(sender); if (yes) { position.yes_shares = position.yes_shares + amount; } else { position.no_shares = position.no_shares + amount; } } public fun resolve_market<CoinType>(resolver: &signer, outcome: bool) acquires Market { let sender = signer::address_of(resolver); let market = borrow_global_mut<Market<CoinType>>(@market_address); assert!(sender == market.creator, 4); assert!(!market.resolved, 5); assert!(timestamp::now_seconds() >= market.resolution_time, 6); market.resolved = true; market.outcome = outcome; } public fun claim_winnings<CoinType>(claimer: &signer) acquires Market, UserPosition { let sender = signer::address_of(claimer); let market = borrow_global<Market<CoinType>>(@market_address); assert!(market.resolved, 7); let position = borrow_global_mut<UserPosition<CoinType>>(sender); let winnings = if (market.outcome) { position.yes_shares } else { position.no_shares }; position.yes_shares = 0; position.no_shares = 0; coin::transfer<CoinType>(@market_address, sender, winnings); } }",
        "vulnerabilities": [
            "No mechanism for partial share selling",
            "Centralized market resolution"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Auction has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64, ended: bool } const E_AUCTION_ENDED: u64 = 1; const E_BID_TOO_LOW: u64 = 2; const E_AUCTION_NOT_ENDED: u64 = 3; const E_NOT_SELLER: u64 = 4; public fun create_auction<CoinType>(seller: &signer, duration: u64, starting_price: u64) { let sender = signer::address_of(seller); move_to(seller, Auction { seller: sender, highest_bidder: sender, highest_bid: starting_price, end_time: timestamp::now_seconds() + duration, ended: false }); } public fun bid<CoinType>(bidder: &signer, amount: u64) acquires Auction { let sender = signer::address_of(bidder); let auction = borrow_global_mut<Auction>(@auction_address); assert!(!auction.ended && timestamp::now_seconds() < auction.end_time, E_AUCTION_ENDED); assert!(amount > auction.highest_bid, E_BID_TOO_LOW); if (auction.highest_bidder != auction.seller) { coin::transfer<CoinType>(@auction_address, auction.highest_bidder, auction.highest_bid); } coin::transfer<CoinType>(bidder, @auction_address, amount); auction.highest_bidder = sender; auction.highest_bid = amount; } public fun end_auction<CoinType>(account: &signer) acquires Auction { let sender = signer::address_of(account); let auction = borrow_global_mut<Auction>(@auction_address); assert!(sender == auction.seller, E_NOT_SELLER); assert!(!auction.ended && timestamp::now_seconds() >= auction.end_time, E_AUCTION_NOT_ENDED); auction.ended = true; coin::transfer<CoinType>(@auction_address, auction.seller, auction.highest_bid); } }",
        "vulnerabilities": [
            "No mechanism to cancel an auction",
            "Lack of access control for creating auctions",
            "Potential for seller to manipulate end time",
            "Missing events for bidding and auction end",
            "No minimum bid increment",
            "Centralized storage of auction funds",
            "Potential for griefing by creating many small auctions",
            "No mechanism to extend auction time on last-minute bids",
            "Lack of withdrawal pattern for refunds",
            "Missing checks for zero address and zero amount"
        ]
    },
    {
        "code": "module TimedSavings { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct SavingsAccount<phantom CoinType> has key { balance: u64, lock_end_time: u64, } public fun create_account<CoinType>(account: &signer, initial_deposit: u64, lock_duration: u64) { let sender = signer::address_of(account); assert!(!exists<SavingsAccount<CoinType>>(sender), 1); move_to(account, SavingsAccount<CoinType> { balance: initial_deposit, lock_end_time: timestamp::now_seconds() + lock_duration }); coin::transfer<CoinType>(account, @savings_address, initial_deposit); } public fun deposit<CoinType>(account: &signer, amount: u64) acquires SavingsAccount { let sender = signer::address_of(account); let savings = borrow_global_mut<SavingsAccount<CoinType>>(sender); savings.balance = savings.balance + amount; coin::transfer<CoinType>(account, @savings_address, amount); } public fun withdraw<CoinType>(account: &signer, amount: u64) acquires SavingsAccount { let sender = signer::address_of(account); let savings = borrow_global_mut<SavingsAccount<CoinType>>(sender); assert!(timestamp::now_seconds() >= savings.lock_end_time, 2); assert!(amount <= savings.balance, 3); savings.balance = savings.balance - amount; coin::transfer<CoinType>(@savings_address, sender, amount); } }",
        "vulnerabilities": [
            "Lack of partial withdrawal before lock end time",
            "No mechanism to extend lock duration"
        ]
    },
    {
        "code": "module SimpleVoting { use std::signer; use std::vector; use aptos_framework::timestamp; struct Proposal has key { description: vector<u8>, vote_count: u64, end_time: u64, } struct Voter has key { has_voted: bool, } const E_ALREADY_VOTED: u64 = 1; const E_VOTING_ENDED: u64 = 2; const E_VOTING_NOT_ENDED: u64 = 3; public fun create_proposal(creator: &signer, description: vector<u8>, duration: u64) { move_to(creator, Proposal { description, vote_count: 0, end_time: timestamp::now_seconds() + duration, }); } public fun vote(voter: &signer) acquires Proposal, Voter { let sender = signer::address_of(voter); let proposal = borrow_global_mut<Proposal>(@proposal_address); assert!(timestamp::now_seconds() < proposal.end_time, E_VOTING_ENDED); if (!exists<Voter>(sender)) { move_to(voter, Voter { has_voted: false }); } let voter_info = borrow_global_mut<Voter>(sender); assert!(!voter_info.has_voted, E_ALREADY_VOTED); voter_info.has_voted = true; proposal.vote_count = proposal.vote_count + 1; } public fun get_result(): (vector<u8>, u64) acquires Proposal { let proposal = borrow_global<Proposal>(@proposal_address); assert!(timestamp::now_seconds() >= proposal.end_time, E_VOTING_NOT_ENDED); (proposal.description, proposal.vote_count) } }",
        "vulnerabilities": [
            "No mechanism to change voting duration",
            "Lack of access control for creating proposals",
            "No way to cancel or update a proposal",
            "Missing events for proposal creation and voting",
            "Centralized storage of voting data",
            "No support for multiple concurrent proposals",
            "Lack of voter privacy (votes are public)",
            "No mechanism to delegate votes",
            "Potential for frontrunning in the vote function",
            "Missing checks for empty proposal description"
        ]
    },
    {
        "code": "module SimpleGovernance { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Proposal has key { id: u64, creator: address, description: vector<u8>, votes_for: u64, votes_against: u64, end_time: u64, executed: bool, } struct VoteRecord has key { proposal_id: u64, vote: bool, } let proposal_count: u64 = 0; public fun create_proposal(creator: &signer, description: vector<u8>, duration: u64) { let sender = signer::address_of(creator); proposal_count = proposal_count + 1; move_to(creator, Proposal { id: proposal_count, creator: sender, description, votes_for: 0, votes_against: 0, end_time: timestamp::now_seconds() + duration, executed: false, }); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal, VoteRecord { let sender = signer::address_of(voter); let proposal = borrow_global_mut<Proposal>(@governance_address); assert!(proposal.id == proposal_id, 1); assert!(timestamp::now_seconds() < proposal.end_time, 2); assert!(!exists<VoteRecord>(sender), 3); if (vote) { proposal.votes_for = proposal.votes_for + 1; } else { proposal.votes_against = proposal.votes_against + 1; } move_to(voter, VoteRecord { proposal_id, vote }); } public fun execute_proposal(proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@governance_address); assert!(proposal.id == proposal_id, 1); assert!(timestamp::now_seconds() >= proposal.end_time, 2); assert!(!proposal.executed, 3); assert!(proposal.votes_for > proposal.votes_against, 4); proposal.executed = true; // Execute proposal logic here } }",
        "vulnerabilities": [
            "Lack of access control for create_proposal function",
            "No mechanism to cancel or extend proposals",
            "Missing event emissions for proposal creation, voting, and execution",
            "Potential integer overflow in vote counting",
            "No quorum requirements for proposal execution",
            "Centralized control of the governance contract",
            "Lack of token-weighted voting",
            "No delegation mechanism for voting power",
            "Potential for last-minute voting attacks",
            "Missing checks for empty proposal descriptions"
        ]
    },
    {
        "code": "module YieldFarming { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Farm<phantom DepositToken, phantom RewardToken> has key { total_staked: u64, reward_per_second: u64, last_update_time: u64, reward_per_share: u128, } struct UserInfo<phantom DepositToken, phantom RewardToken> has key { amount: u64, reward_debt: u128, } public fun create_farm<DepositToken, RewardToken>(creator: &signer, reward_per_second: u64) { let sender = signer::address_of(creator); assert!(!exists<Farm<DepositToken, RewardToken>>(sender), 1); move_to(creator, Farm<DepositToken, RewardToken> { total_staked: 0, reward_per_second, last_update_time: timestamp::now_seconds(), reward_per_share: 0, }); } public fun stake<DepositToken, RewardToken>(account: &signer, amount: u64) acquires Farm, UserInfo { let sender = signer::address_of(account); let farm = borrow_global_mut<Farm<DepositToken, RewardToken>>(@farm_address); update_pool<DepositToken, RewardToken>(farm); if (!exists<UserInfo<DepositToken, RewardToken>>(sender)) { move_to(account, UserInfo<DepositToken, RewardToken> { amount: 0, reward_debt: 0, }); } let user_info = borrow_global_mut<UserInfo<DepositToken, RewardToken>>(sender); if (user_info.amount > 0) { let pending = (((user_info.amount as u128) * farm.reward_per_share) / 1e12 as u128) - user_info.reward_debt; if (pending > 0) { coin::transfer<RewardToken>(@farm_address, sender, (pending as u64)); } } coin::transfer<DepositToken>(account, @farm_address, amount); user_info.amount = user_info.amount + amount; farm.total_staked = farm.total_staked + amount; user_info.reward_debt = ((user_info.amount as u128) * farm.reward_per_share) / 1e12 as u128; } public fun unstake<DepositToken, RewardToken>(account: &signer, amount: u64) acquires Farm, UserInfo { let sender = signer::address_of(account); let farm = borrow_global_mut<Farm<DepositToken, RewardToken>>(@farm_address); let user_info = borrow_global_mut<UserInfo<DepositToken, RewardToken>>(sender); update_pool<DepositToken, RewardToken>(farm); let pending = (((user_info.amount as u128) * farm.reward_per_share) / 1e12 as u128) - user_info.reward_debt; if (pending > 0) { coin::transfer<RewardToken>(@farm_address, sender, (pending as u64)); } user_info.amount = user_info.amount - amount; farm.total_staked = farm.total_staked - amount; user_info.reward_debt = ((user_info.amount as u128) * farm.reward_per_share) / 1e12 as u128; coin::transfer<DepositToken>(@farm_address, sender, amount); } fun update_pool<DepositToken, RewardToken>(farm: &mut Farm<DepositToken, RewardToken>) { let current_time = timestamp::now_seconds(); if (current_time <= farm.last_update_time) { return } ; if (farm.total_staked == 0) { farm.last_update_time = current_time; return } ; let time_elapsed = current_time - farm.last_update_time; let reward = (time_elapsed as u128) * (farm.reward_per_second as u128); farm.reward_per_share = farm.reward_per_share + ((reward * 1e12 as u128) / (farm.total_staked as u128)); farm.last_update_time = current_time; } }",
        "vulnerabilities": [
            "No mechanism to update reward rate",
            "Potential for precision loss in reward calculations"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Auction has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64, } public fun create_auction<CoinType>(seller: &signer, duration: u64) { let sender = signer::address_of(seller); move_to(seller, Auction { seller: sender, highest_bidder: @0x0, highest_bid: 0, end_time: timestamp::now_seconds() + duration, }); } public fun place_bid<CoinType>(bidder: &signer, bid_amount: u64) acquires Auction { let sender = signer::address_of(bidder); let auction = borrow_global_mut<Auction>(@auction_address); assert!(timestamp::now_seconds() < auction.end_time, 1); assert!(bid_amount > auction.highest_bid, 2); if (auction.highest_bidder != @0x0) { coin::transfer<CoinType>(@auction_address, auction.highest_bidder, auction.highest_bid); } coin::transfer<CoinType>(bidder, @auction_address, bid_amount); auction.highest_bidder = sender; auction.highest_bid = bid_amount; } public fun end_auction<CoinType>(account: &signer) acquires Auction { let auction = move_from<Auction>(@auction_address); assert!(signer::address_of(account) == auction.seller, 3); assert!(timestamp::now_seconds() >= auction.end_time, 4); coin::transfer<CoinType>(@auction_address, auction.seller, auction.highest_bid); } }",
        "vulnerabilities": [
            "Lack of access control for create_auction function",
            "No mechanism to cancel or extend the auction",
            "Missing event emissions for bid placement and auction end",
            "Potential reentrancy in place_bid function",
            "No minimum bid increment enforced",
            "Centralized control of the auction contract",
            "Lack of refund mechanism for outbid participants",
            "No checks for contract balance before transfers",
            "Potential for frontrunning in place_bid function",
            "Missing checks for zero address in transfers"
        ]
    },
    {
        "code": "module GovernanceToken { use std::signer; use std::vector; use aptos_framework::coin; use aptos_framework::timestamp; struct GovernanceToken {} struct Proposal has key { proposer: address, description: vector<u8>, for_votes: u64, against_votes: u64, start_time: u64, end_time: u64, executed: bool, } struct VoteInfo has key { voted_proposals: vector<u64>, } public fun create_proposal(proposer: &signer, description: vector<u8>, voting_period: u64) acquires VoteInfo { let sender = signer::address_of(proposer); let proposal_id = get_proposal_count() + 1; move_to(proposer, Proposal { proposer: sender, description, for_votes: 0, against_votes: 0, start_time: timestamp::now_seconds(), end_time: timestamp::now_seconds() + voting_period, executed: false, }); if (!exists<VoteInfo>(sender)) { move_to(proposer, VoteInfo { voted_proposals: vector::empty() }); } let vote_info = borrow_global_mut<VoteInfo>(sender); vector::push_back(&mut vote_info.voted_proposals, proposal_id); } public fun vote(voter: &signer, proposal_id: u64, support: bool) acquires Proposal, VoteInfo { let sender = signer::address_of(voter); assert!(exists<Proposal>(@proposal_address), 1); let proposal = borrow_global_mut<Proposal>(@proposal_address); assert!(timestamp::now_seconds() >= proposal.start_time && timestamp::now_seconds() <= proposal.end_time, 2); let vote_weight = coin::balance<GovernanceToken>(sender); if (support) { proposal.for_votes = proposal.for_votes + vote_weight; } else { proposal.against_votes = proposal.against_votes + vote_weight; } if (!exists<VoteInfo>(sender)) { move_to(voter, VoteInfo { voted_proposals: vector::empty() }); } let vote_info = borrow_global_mut<VoteInfo>(sender); vector::push_back(&mut vote_info.voted_proposals, proposal_id); } public fun execute_proposal(executor: &signer, proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@proposal_address); assert!(!proposal.executed, 3); assert!(timestamp::now_seconds() > proposal.end_time, 4); assert!(proposal.for_votes > proposal.against_votes, 5); // Execute proposal logic here proposal.executed = true; } fun get_proposal_count(): u64 { // Implementation to get the current proposal count } }",
        "vulnerabilities": [
            "Lack of quorum requirement for proposal execution",
            "No mechanism to cancel or update proposals"
        ]
    },
    {
        "code": "module TokenVesting { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct VestingSchedule has key { beneficiary: address, total_amount: u64, released_amount: u64, start_time: u64, duration: u64, } public fun create_vesting<CoinType>(creator: &signer, beneficiary: address, total_amount: u64, start_time: u64, duration: u64) { let sender = signer::address_of(creator); move_to(creator, VestingSchedule { beneficiary, total_amount, released_amount: 0, start_time, duration, }); coin::transfer<CoinType>(creator, @vesting_address, total_amount); } public fun release<CoinType>() acquires VestingSchedule { let vesting = borrow_global_mut<VestingSchedule>(@vesting_address); let current_time = timestamp::now_seconds(); let elapsed_time = current_time - vesting.start_time; if (elapsed_time > vesting.duration) { elapsed_time = vesting.duration; } let vested_amount = (vesting.total_amount * elapsed_time) / vesting.duration; let unreleased_amount = vested_amount - vesting.released_amount; if (unreleased_amount > 0) { vesting.released_amount = vesting.released_amount + unreleased_amount; coin::transfer<CoinType>(@vesting_address, vesting.beneficiary, unreleased_amount); } } }",
        "vulnerabilities": [
            "Lack of access control for create_vesting function",
            "No mechanism to revoke or modify vesting schedule",
            "Missing event emissions for vesting creation and token release",
            "Potential integer overflow in vested amount calculation",
            "No checks for contract balance before transfers",
            "Centralized control of the vesting contract",
            "Lack of multi-beneficiary support",
            "No cliff period implementation",
            "Potential for frontrunning in release function",
            "Missing checks for zero values in vesting schedule creation"
        ]
    },
    {
        "code": "module SimpleDEX { use std::signer; use aptos_framework::coin; use aptos_framework::event; struct LiquidityPool<phantom CoinTypeA, phantom CoinTypeB> has key { reserve_a: u64, reserve_b: u64, } struct SwapEvent has drop, store { user: address, amount_in: u64, amount_out: u64, } public fun create_pool<CoinTypeA, CoinTypeB>(creator: &signer, initial_a: u64, initial_b: u64) { let sender = signer::address_of(creator); assert!(!exists<LiquidityPool<CoinTypeA, CoinTypeB>>(sender), 1); move_to(creator, LiquidityPool<CoinTypeA, CoinTypeB> { reserve_a: initial_a, reserve_b: initial_b }); coin::transfer<CoinTypeA>(creator, @dex_address, initial_a); coin::transfer<CoinTypeB>(creator, @dex_address, initial_b); } public fun swap<CoinTypeIn, CoinTypeOut>(user: &signer, amount_in: u64) acquires LiquidityPool { let sender = signer::address_of(user); let pool = borrow_global_mut<LiquidityPool<CoinTypeIn, CoinTypeOut>>(@dex_address); let amount_out = (amount_in * pool.reserve_b) / (pool.reserve_a + amount_in); assert!(amount_out > 0, 2); pool.reserve_a = pool.reserve_a + amount_in; pool.reserve_b = pool.reserve_b - amount_out; coin::transfer<CoinTypeIn>(user, @dex_address, amount_in); coin::transfer<CoinTypeOut>(@dex_address, sender, amount_out); event::emit(SwapEvent { user: sender, amount_in, amount_out }); } }",
        "vulnerabilities": [
            "Lack of slippage protection in swap function",
            "No mechanism to add or remove liquidity after pool creation",
            "Potential for price manipulation in low liquidity situations"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::event; use aptos_framework::timestamp; struct Listing has key { creator: address, price: u64, expiration: u64, } struct SaleEvent has drop, store { seller: address, buyer: address, nft_id: u64, price: u64, } struct MarketplaceEventHandle has key { sale_events: event::EventHandle<SaleEvent>, } const E_NOT_AUTHORIZED: u64 = 1; const E_LISTING_NOT_FOUND: u64 = 2; const E_LISTING_EXPIRED: u64 = 3; public fun create_listing(seller: &signer, nft_id: u64, price: u64, duration: u64) { let sender = signer::address_of(seller); assert!(!exists<Listing>(sender), E_LISTING_NOT_FOUND); move_to(seller, Listing { creator: sender, price, expiration: timestamp::now_seconds() + duration, }); } public fun buy_nft<CoinType>(buyer: &signer, nft_id: u64) acquires Listing, MarketplaceEventHandle { let listing = move_from<Listing>(@nft_address); assert!(timestamp::now_seconds() < listing.expiration, E_LISTING_EXPIRED); coin::transfer<CoinType>(buyer, listing.creator, listing.price); // Transfer NFT ownership (simplified) let event_handle = borrow_global_mut<MarketplaceEventHandle>(@marketplace_address); event::emit_event(&mut event_handle.sale_events, SaleEvent { seller: listing.creator, buyer: signer::address_of(buyer), nft_id, price: listing.price, }); } public fun cancel_listing(seller: &signer, nft_id: u64) acquires Listing { let sender = signer::address_of(seller); let listing = move_from<Listing>(sender); assert!(listing.creator == sender, E_NOT_AUTHORIZED); } public fun initialize_marketplace(account: &signer) { move_to(account, MarketplaceEventHandle { sale_events: event::new_event_handle<SaleEvent>(account), }); } }",
        "vulnerabilities": [
            "Lack of royalty mechanism for original creators",
            "No support for bidding or auctions",
            "Potential for frontrunning in buy_nft function",
            "Missing checks for NFT ownership before listing",
            "No mechanism to update listing price or duration",
            "Centralized control of the marketplace contract",
            "Lack of escrow mechanism for secure trades",
            "No support for batch listings or purchases",
            "Missing events for listing creation and cancellation",
            "Potential for lost NFTs if transfer fails in buy_nft"
        ]
    },
    {
        "code": "module DecentralizedLottery { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; use aptos_framework::random; struct Lottery<phantom CoinType> has key { participants: vector<address>, ticket_price: u64, end_time: u64, winner: address, } public fun create_lottery<CoinType>(creator: &signer, ticket_price: u64, duration: u64) { move_to(creator, Lottery<CoinType> { participants: vector::empty(), ticket_price, end_time: timestamp::now_seconds() + duration, winner: @0x0, }); } public fun buy_ticket<CoinType>(buyer: &signer) acquires Lottery { let sender = signer::address_of(buyer); let lottery = borrow_global_mut<Lottery<CoinType>>(@lottery_address); assert!(timestamp::now_seconds() < lottery.end_time, 1); coin::transfer<CoinType>(buyer, @lottery_address, lottery.ticket_price); vector::push_back(&mut lottery.participants, sender); } public fun draw_winner<CoinType>() acquires Lottery { let lottery = borrow_global_mut<Lottery<CoinType>>(@lottery_address); assert!(timestamp::now_seconds() >= lottery.end_time, 2); assert!(lottery.winner == @0x0, 3); let winner_index = random::rand_u64() % vector::length(&lottery.participants); lottery.winner = *vector::borrow(&lottery.participants, winner_index); } public fun claim_prize<CoinType>(claimer: &signer) acquires Lottery { let sender = signer::address_of(claimer); let lottery = borrow_global<Lottery<CoinType>>(@lottery_address); assert!(sender == lottery.winner, 4); let prize = lottery.ticket_price * vector::length(&lottery.participants); coin::transfer<CoinType>(@lottery_address, sender, prize); } }",
        "vulnerabilities": [
            "Centralized lottery creation and winner drawing",
            "Lack of randomness source entropy"
        ]
    },
    {
        "code": "module DecentralizedStorage { use std::signer; use std::vector; struct File has key { owner: address, name: vector<u8>, content_hash: vector<u8>, size: u64, } struct StorageProvider has key { available_space: u64, } public fun register_provider(provider: &signer, space: u64) { let sender = signer::address_of(provider); assert!(!exists<StorageProvider>(sender), 1); move_to(provider, StorageProvider { available_space: space }); } public fun store_file(owner: &signer, name: vector<u8>, content_hash: vector<u8>, size: u64) acquires StorageProvider { let sender = signer::address_of(owner); let provider = borrow_global_mut<StorageProvider>(@storage_address); assert!(provider.available_space >= size, 2); provider.available_space = provider.available_space - size; move_to(owner, File { owner: sender, name, content_hash, size }); } public fun delete_file(owner: &signer, name: vector<u8>) acquires File, StorageProvider { let sender = signer::address_of(owner); let file = move_from<File>(sender); assert!(file.name == name, 3); let provider = borrow_global_mut<StorageProvider>(@storage_address); provider.available_space = provider.available_space + file.size; } }",
        "vulnerabilities": [
            "Centralized storage provider",
            "Lack of file sharing and access control mechanisms"
        ]
    },
    {
        "code": "module YieldFarming { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct FarmInfo<phantom StakeToken, phantom RewardToken> has key { total_staked: u64, reward_per_second: u64, last_update_time: u64, acc_reward_per_share: u128, } struct UserInfo<phantom StakeToken, phantom RewardToken> has key { amount: u64, reward_debt: u128, } const SCALE_FACTOR: u128 = 1000000000000; const E_NOT_INITIALIZED: u64 = 1; const E_INSUFFICIENT_BALANCE: u64 = 2; public fun initialize_farm<StakeToken, RewardToken>(admin: &signer, reward_per_second: u64) { let sender = signer::address_of(admin); assert!(!exists<FarmInfo<StakeToken, RewardToken>>(sender), E_NOT_INITIALIZED); move_to(admin, FarmInfo<StakeToken, RewardToken> { total_staked: 0, reward_per_second, last_update_time: timestamp::now_seconds(), acc_reward_per_share: 0, }); } public fun stake<StakeToken, RewardToken>(account: &signer, amount: u64) acquires FarmInfo, UserInfo { let sender = signer::address_of(account); let farm = borrow_global_mut<FarmInfo<StakeToken, RewardToken>>(@farm_address); update_pool<StakeToken, RewardToken>(); if (!exists<UserInfo<StakeToken, RewardToken>>(sender)) { move_to(account, UserInfo<StakeToken, RewardToken> { amount: 0, reward_debt: 0, }); } let user_info = borrow_global_mut<UserInfo<StakeToken, RewardToken>>(sender); let pending_reward = (user_info.amount as u128 * farm.acc_reward_per_share / SCALE_FACTOR) - user_info.reward_debt; if (pending_reward > 0) { coin::transfer<RewardToken>(@farm_address, sender, (pending_reward as u64)); } user_info.amount = user_info.amount + amount; user_info.reward_debt = (user_info.amount as u128 * farm.acc_reward_per_share) / SCALE_FACTOR; farm.total_staked = farm.total_staked + amount; coin::transfer<StakeToken>(account, @farm_address, amount); } public fun unstake<StakeToken, RewardToken>(account: &signer, amount: u64) acquires FarmInfo, UserInfo { let sender = signer::address_of(account); let farm = borrow_global_mut<FarmInfo<StakeToken, RewardToken>>(@farm_address); let user_info = borrow_global_mut<UserInfo<StakeToken, RewardToken>>(sender); assert!(user_info.amount >= amount, E_INSUFFICIENT_BALANCE); update_pool<StakeToken, RewardToken>(); let pending_reward = (user_info.amount as u128 * farm.acc_reward_per_share / SCALE_FACTOR) - user_info.reward_debt; if (pending_reward > 0) { coin::transfer<RewardToken>(@farm_address, sender, (pending_reward as u64)); } user_info.amount = user_info.amount - amount; user_info.reward_debt = (user_info.amount as u128 * farm.acc_reward_per_share) / SCALE_FACTOR; farm.total_staked = farm.total_staked - amount; coin::transfer<StakeToken>(@farm_address, sender, amount); } fun update_pool<StakeToken, RewardToken>() acquires FarmInfo { let farm = borrow_global_mut<FarmInfo<StakeToken, RewardToken>>(@farm_address); let current_time = timestamp::now_seconds(); if (current_time > farm.last_update_time && farm.total_staked > 0) { let time_elapsed = current_time - farm.last_update_time; let reward = (time_elapsed as u128) * (farm.reward_per_second as u128); farm.acc_reward_per_share = farm.acc_reward_per_share + (reward * SCALE_FACTOR / (farm.total_staked as u128)); farm.last_update_time = current_time; } } }",
        "vulnerabilities": [
            "Lack of access control for initialize_farm function",
            "No mechanism to update reward rate",
            "Potential for precision loss in reward calculations",
            "Missing events for staking and unstaking actions",
            "No checks for contract balance before reward distributions",
            "Centralized control of the farming contract",
            "Potential for flash loan attacks to manipulate rewards",
            "No time-lock or vesting period for rewards",
            "Missing mechanism to pause or stop the farm",
            "Lack of support for multiple reward tokens"
        ]
    },
    {
        "code": "module SimpleToken { use std::signer; struct Token has key { balance: u64 } public fun mint(account: &signer, amount: u64) { move_to(account, Token { balance: amount }); } public fun transfer(from: &signer, to: address, amount: u64) acquires Token { let from_token = borrow_global_mut<Token>(signer::address_of(from)); assert!(from_token.balance >= amount, 1); from_token.balance = from_token.balance - amount; let to_token = borrow_global_mut<Token>(to); to_token.balance = to_token.balance + amount; } }",
        "vulnerabilities": [
            "No access control on minting",
            "Integer overflow vulnerability in transfer function"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::token; struct Listing has key { creator: address, token_id: token::TokenId, price: u64 } public fun list_token(account: &signer, token_id: token::TokenId, price: u64) { let sender = signer::address_of(account); assert!(token::balance_of(sender, token_id) > 0, 1); move_to(account, Listing { creator: sender, token_id, price }); } public fun buy_token(buyer: &signer, seller: address, token_id: token::TokenId) acquires Listing { let listing = move_from<Listing>(seller); assert!(listing.token_id == token_id, 2); coin::transfer<AptosCoin>(buyer, seller, listing.price); token::transfer(seller, buyer, token_id, 1); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of access control for removing listings",
            "Potential for front-running attacks",
            "No checks for token ownership before listing",
            "Missing events for important actions"
        ]
    },
    
    {
        "code": "module DeFiLendingPool { use std::signer; use aptos_framework::coin; struct LendingPool<phantom CoinType> has key { total_borrowed: u64, total_supplied: u64, interest_rate: u64 } struct UserPosition<phantom CoinType> has key { borrowed: u64, supplied: u64 } public fun initialize_pool<CoinType>(admin: &signer, interest_rate: u64) { move_to(admin, LendingPool<CoinType> { total_borrowed: 0, total_supplied: 0, interest_rate }); } public fun supply<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserPosition { let sender = signer::address_of(account); let pool = borrow_global_mut<LendingPool<CoinType>>(@pool_address); pool.total_supplied = pool.total_supplied + amount; if (!exists<UserPosition<CoinType>>(sender)) { move_to(account, UserPosition<CoinType> { borrowed: 0, supplied: 0 }); } let position = borrow_global_mut<UserPosition<CoinType>>(sender); position.supplied = position.supplied + amount; coin::transfer<CoinType>(account, @pool_address, amount); } public fun borrow<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserPosition { let sender = signer::address_of(account); let pool = borrow_global_mut<LendingPool<CoinType>>(@pool_address); assert!(pool.total_supplied >= pool.total_borrowed + amount, 1); pool.total_borrowed = pool.total_borrowed + amount; let position = borrow_global_mut<UserPosition<CoinType>>(sender); position.borrowed = position.borrowed + amount; coin::transfer<CoinType>(@pool_address, sender, amount); } }",
        "vulnerabilities": [
            "No collateralization mechanism",
            "Missing liquidation functionality",
            "Lack of interest accrual implementation",
            "No checks for borrowing limits",
            "Centralized control of the lending pool",
            "Potential for flash loan attacks"
        ]
    },
    
    {
        "code": "module StakingRewards { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakingPool<phantom StakeToken, phantom RewardToken> has key { total_staked: u64, reward_rate: u64, last_update_time: u64, reward_per_token_stored: u128 } struct UserStake<phantom StakeToken, phantom RewardToken> has key { balance: u64, rewards_paid: u128 } public fun initialize_pool<StakeToken, RewardToken>(admin: &signer, reward_rate: u64) { move_to(admin, StakingPool<StakeToken, RewardToken> { total_staked: 0, reward_rate, last_update_time: timestamp::now_seconds(), reward_per_token_stored: 0 }); } public fun stake<StakeToken, RewardToken>(account: &signer, amount: u64) acquires StakingPool, UserStake { let sender = signer::address_of(account); update_reward<StakeToken, RewardToken>(sender); let pool = borrow_global_mut<StakingPool<StakeToken, RewardToken>>(@pool_address); pool.total_staked = pool.total_staked + amount; if (!exists<UserStake<StakeToken, RewardToken>>(sender)) { move_to(account, UserStake<StakeToken, RewardToken> { balance: 0, rewards_paid: 0 }); } let stake = borrow_global_mut<UserStake<StakeToken, RewardToken>>(sender); stake.balance = stake.balance + amount; coin::transfer<StakeToken>(account, @pool_address, amount); } public fun claim_reward<StakeToken, RewardToken>(account: &signer) acquires StakingPool, UserStake { let sender = signer::address_of(account); update_reward<StakeToken, RewardToken>(sender); let stake = borrow_global_mut<UserStake<StakeToken, RewardToken>>(sender); let pool = borrow_global<StakingPool<StakeToken, RewardToken>>(@pool_address); let reward = stake.balance * (pool.reward_per_token_stored - stake.rewards_paid) / 1000000000000; stake.rewards_paid = pool.reward_per_token_stored; coin::transfer<RewardToken>(@pool_address, sender, reward); } fun update_reward<StakeToken, RewardToken>(account: address) acquires StakingPool, UserStake { let pool = borrow_global_mut<StakingPool<StakeToken, RewardToken>>(@pool_address); let current_time = timestamp::now_seconds(); if (current_time > pool.last_update_time) { pool.reward_per_token_stored = pool.reward_per_token_stored + ((current_time - pool.last_update_time) * pool.reward_rate * 1000000000000) / pool.total_staked; pool.last_update_time = current_time; } if (exists<UserStake<StakeToken, RewardToken>>(account)) { let stake = borrow_global_mut<UserStake<StakeToken, RewardToken>>(account); stake.rewards_paid = pool.reward_per_token_stored; } } }",
        "vulnerabilities": [
            "Potential for precision loss in reward calculations",
            "No mechanism to update reward rate",
            "Missing events for important actions",
            "Lack of access control for initializing pool",
            "No checks for contract balance before reward distributions"
        ]
    },
    {
        "code": "module SimpleNFT { use std::string; use std::vector; use aptos_framework::account; use aptos_framework::event; struct NFT has key { id: u64, name: string::String, description: string::String, uri: string::String, } struct MintEvent has drop, store { creator: address, id: u64, } public fun mint(creator: &signer, name: string::String, description: string::String, uri: string::String) { let nft = NFT { id: get_next_nft_id(), name, description, uri }; move_to(creator, nft); event::emit(MintEvent { creator: signer::address_of(creator), id: nft.id }); } public fun transfer(from: &signer, to: address, id: u64) acquires NFT { let nft = move_from<NFT>(signer::address_of(from)); assert!(nft.id == id, 1); move_to<NFT>(account::create_signer_with_capability(to), nft); } }",
        "vulnerabilities": [
            "Lack of royalty mechanism for secondary sales",
            "Missing access control for minting",
            "No burn functionality",
            "Potential for ID collisions",
            "Lack of metadata standards compliance",
            "Missing events for transfers",
            "No mechanism to update NFT metadata",
            "Lack of batch minting functionality",
            "Missing checks for valid URI format",
            "No support for fractional ownership"
        ]
    },
    {
        "code": "module SimpleStaking { use std::signer; use aptos_framework::coin; struct StakeInfo has key { amount: u64, start_time: u64, } public fun stake(staker: &signer, amount: u64) { let start_time = timestamp::now_seconds(); move_to(staker, StakeInfo { amount, start_time }); coin::transfer<StakingToken>(staker, @staking_pool, amount); } public fun unstake(staker: &signer) acquires StakeInfo { let StakeInfo { amount, start_time } = move_from<StakeInfo>(signer::address_of(staker)); let duration = timestamp::now_seconds() - start_time; let reward = calculate_reward(amount, duration); coin::transfer<StakingToken>(@staking_pool, signer::address_of(staker), amount + reward); } fun calculate_reward(amount: u64, duration: u64): u64 { // Simplified reward calculation amount * duration / 31536000 // Annual reward rate } }",
        "vulnerabilities": [
            "Lack of vesting or lock-up period",
            "Missing events for stake and unstake actions",
            "No mechanism to update reward calculation",
            "Potential for reward calculation overflow",
            "Lack of access control for reward distribution",
            "Missing checks for minimum stake amount",
            "No support for partial unstaking",
            "Potential for front-running unstake transactions",
            "Lack of emergency withdraw functionality",
            "Missing mechanism to pause staking/unstaking"
        ]
    },
    {
        "code": "module SimpleVoting { use std::signer; use aptos_framework::coin; struct Ballot has key { proposal_id: u64, votes: vector<Vote>, } struct Vote { voter: address, choice: bool, } public fun create_ballot(creator: &signer, proposal_id: u64) { move_to(creator, Ballot { proposal_id, votes: vector::empty() }); } public fun cast_vote(voter: &signer, proposal_id: u64, choice: bool) acquires Ballot { let ballot = borrow_global_mut<Ballot>(@voting_address); vector::push_back(&mut ballot.votes, Vote { voter: signer::address_of(voter), choice }); } public fun tally_votes(proposal_id: u64): (u64, u64) acquires Ballot { let ballot = borrow_global<Ballot>(@voting_address); let yes_votes = 0; let no_votes = 0; let i = 0; while (i < vector::length(&ballot.votes)) { let vote = vector::borrow(&ballot.votes, i); if (vote.choice) { yes_votes += 1; } else { no_votes += 1; } i += 1; } (yes_votes, no_votes) } }",
        "vulnerabilities": [
            "No mechanism to prevent double voting",
            "Lack of voting power based on token holdings",
            "Missing time constraints for voting period",
            "No quorum requirement for vote validity",
            "Potential for ballot spam",
            "Lack of privacy for individual votes",
            "Missing events for voting activities",
            "No mechanism to update or cancel ballots",
            "Potential for front-running vote submissions",
            "Lack of support for multiple choice voting"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::coin; struct Auction has key { item_id: u64, seller: address, highest_bidder: address, highest_bid: u64, end_time: u64, } public fun create_auction(seller: &signer, item_id: u64, start_price: u64, duration: u64) { let end_time = timestamp::now_seconds() + duration; move_to(seller, Auction { item_id, seller: signer::address_of(seller), highest_bidder: @0x0, highest_bid: start_price, end_time }); } public fun place_bid(bidder: &signer, amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@auction_address); assert!(timestamp::now_seconds() < auction.end_time, 1); assert!(amount > auction.highest_bid, 2); if (auction.highest_bidder != @0x0) { coin::transfer<AptosCoin>(@escrow, auction.highest_bidder, auction.highest_bid); } auction.highest_bidder = signer::address_of(bidder); auction.highest_bid = amount; coin::transfer<AptosCoin>(bidder, @escrow, amount); } public fun end_auction() acquires Auction { let auction = move_from<Auction>(@auction_address); assert!(timestamp::now_seconds() >= auction.end_time, 1); coin::transfer<AptosCoin>(@escrow, auction.seller, auction.highest_bid); // Transfer item to highest bidder } }",
        "vulnerabilities": [
            "Lack of minimum bid increment",
            "Missing events for auction activities",
            "No mechanism to cancel or update auctions",
            "Potential for sniping at the last second",
            "Lack of reserve price functionality",
            "Missing checks for item ownership",
            "No support for Dutch auctions",
            "Potential for front-running bid submissions",
            "Lack of automatic auction settlement",
            "Missing mechanism to handle invalid or malicious bids"
        ]
    },
    {
        "code": "module SimpleEscrow { use std::signer; use aptos_framework::coin; struct Escrow has key { seller: address, buyer: address, amount: u64, released: bool, refunded: bool, } public fun create_escrow(seller: &signer, buyer: address, amount: u64) { move_to(seller, Escrow { seller: signer::address_of(seller), buyer, amount, released: false, refunded: false }); coin::transfer<AptosCoin>(seller, @escrow_address, amount); } public fun release_funds(buyer: &signer) acquires Escrow { let escrow = borrow_global_mut<Escrow>(@escrow_address); assert!(signer::address_of(buyer) == escrow.buyer, 1); assert!(!escrow.released && !escrow.refunded, 2); escrow.released = true; coin::transfer<AptosCoin>(@escrow_address, escrow.seller, escrow.amount); } public fun refund(seller: &signer) acquires Escrow { let escrow = borrow_global_mut<Escrow>(@escrow_address); assert!(signer::address_of(seller) == escrow.seller, 1); assert!(!escrow.released && !escrow.refunded, 2); escrow.refunded = true; coin::transfer<AptosCoin>(@escrow_address, escrow.buyer, escrow.amount); } }",
        "vulnerabilities": [
            "Lack of time-based auto-release mechanism",
            "Missing events for escrow activities",
            "No support for partial releases or refunds",
            "Potential for funds to be locked indefinitely",
            "Lack of dispute resolution mechanism",
            "Missing checks for minimum escrow amount",
            "No mechanism to update escrow terms",
            "Potential for front-running release or refund actions",
            "Lack of multi-signature release option",
            "Missing support for multiple currency types"
        ]
    },
    
    {
        "code": "module MultiSigWallet { use std::signer; use std::vector; use aptos_framework::coin; struct MultiSigWallet has key { owners: vector<address>, required_confirmations: u64, transaction_count: u64 } struct Transaction has store { to: address, value: u64, data: vector<u8>, executed: bool, confirmations: u64 } struct Transactions has key { transactions: vector<Transaction> } public fun create_wallet(account: &signer, owners: vector<address>, required: u64) { assert!(vector::length(&owners) >= required, 1); move_to(account, MultiSigWallet { owners, required_confirmations: required, transaction_count: 0 }); move_to(account, Transactions { transactions: vector::empty() }); } public fun submit_transaction(account: &signer, to: address, value: u64, data: vector<u8>) acquires MultiSigWallet, Transactions { let sender = signer::address_of(account); let wallet = borrow_global_mut<MultiSigWallet>(sender); let transactions = borrow_global_mut<Transactions>(sender); assert!(vector::contains(&wallet.owners, &sender), 2); let tx = Transaction { to, value, data, executed: false, confirmations: 0 }; vector::push_back(&mut transactions.transactions, tx); wallet.transaction_count = wallet.transaction_count + 1; } public fun confirm_transaction(account: &signer, tx_id: u64) acquires MultiSigWallet, Transactions { let sender = signer::address_of(account); let wallet = borrow_global<MultiSigWallet>(sender); let transactions = borrow_global_mut<Transactions>(sender); assert!(vector::contains(&wallet.owners, &sender), 2); assert!(tx_id < vector::length(&transactions.transactions), 3); let tx = vector::borrow_mut(&mut transactions.transactions, tx_id); assert!(!tx.executed, 4); tx.confirmations = tx.confirmations + 1; if (tx.confirmations >= wallet.required_confirmations) { execute_transaction(sender, tx_id); } } fun execute_transaction(wallet_address: address, tx_id: u64) acquires Transactions { let transactions = borrow_global_mut<Transactions>(wallet_address); let tx = vector::borrow_mut(&mut transactions.transactions, tx_id); assert!(!tx.executed, 5); coin::transfer<AptosCoin>(wallet_address, tx.to, tx.value); tx.executed = true; } }",
        "vulnerabilities": [
            "Lack of access control for removing owners",
            "No mechanism to change required confirmations",
            "Missing events for important actions",
            "Potential for transaction ordering attacks",
            "No checks for duplicate owner addresses"
        ]
    },
    {
        "code": "module TokenSwap { use std::signer; use aptos_framework::coin; struct Pool<phantom X, phantom Y> has key { reserve_x: coin::Coin<X>, reserve_y: coin::Coin<Y> } public fun create_pool<X, Y>(account: &signer) { assert!(!exists<Pool<X, Y>>(signer::address_of(account)), 1); move_to(account, Pool<X, Y> { reserve_x: coin::zero<X>(), reserve_y: coin::zero<Y>() }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires Pool { let sender = signer::address_of(account); let pool = borrow_global_mut<Pool<X, Y>>(sender); coin::merge(&mut pool.reserve_x, coin::withdraw<X>(account, amount_x)); coin::merge(&mut pool.reserve_y, coin::withdraw<Y>(account, amount_y)); } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires Pool { let sender = signer::address_of(account); let pool = borrow_global_mut<Pool<X, Y>>(sender); let reserve_x = coin::value(&pool.reserve_x); let reserve_y = coin::value(&pool.reserve_y); let amount_out = (amount_in * reserve_y) / (reserve_x + amount_in); assert!(amount_out >= min_amount_out, 2); coin::merge(&mut pool.reserve_x, coin::withdraw<X>(account, amount_in)); coin::deposit(sender, coin::extract(&mut pool.reserve_y, amount_out)); } }",
        "vulnerabilities": [
            "No slippage protection",
            "Lack of fees mechanism",
            "Potential for flash loan attacks",
            "No access control for pool creation",
            "Missing events for important actions"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::aptos_coin::AptosCoin; use aptos_token::token; struct Listing has key { token_id: token::TokenId, price: u64 } public fun list_token(account: &signer, token_id: token::TokenId, price: u64) { let sender = signer::address_of(account); assert!(!exists<Listing>(sender), 1); token::transfer(account, token_id, sender); move_to(account, Listing { token_id, price }); } public fun buy_token(account: &signer, seller: address) acquires Listing { let listing = move_from<Listing>(seller); let buyer = signer::address_of(account); coin::transfer<AptosCoin>(account, seller, listing.price); token::transfer(seller, listing.token_id, buyer); } public fun cancel_listing(account: &signer) acquires Listing { let Listing { token_id, price: _ } = move_from<Listing>(signer::address_of(account)); token::transfer(account, token_id, signer::address_of(account)); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow for secure transactions",
            "Missing price validation",
            "No mechanism to update listing price",
            "Potential for front-running attacks"
        ]
    },
    {
        "code": "module Staking { use std::signer; use aptos_framework::coin; use aptos_framework::aptos_coin::AptosCoin; struct StakeInfo has key { amount: u64, last_claim_time: u64 } public fun stake(account: &signer, amount: u64) acquires StakeInfo { let sender = signer::address_of(account); if (!exists<StakeInfo>(sender)) { move_to(account, StakeInfo { amount: 0, last_claim_time: aptos_framework::timestamp::now_seconds() }); } let stake_info = borrow_global_mut<StakeInfo>(sender); coin::transfer<AptosCoin>(account, @staking_pool, amount); stake_info.amount = stake_info.amount + amount; } public fun unstake(account: &signer, amount: u64) acquires StakeInfo { let sender = signer::address_of(account); let stake_info = borrow_global_mut<StakeInfo>(sender); assert!(stake_info.amount >= amount, 1); stake_info.amount = stake_info.amount - amount; coin::transfer<AptosCoin>(@staking_pool, sender, amount); } public fun claim_rewards(account: &signer) acquires StakeInfo { let sender = signer::address_of(account); let stake_info = borrow_global_mut<StakeInfo>(sender); let current_time = aptos_framework::timestamp::now_seconds(); let time_elapsed = current_time - stake_info.last_claim_time; let reward = (stake_info.amount * time_elapsed * 5) / (100 * 365 * 86400); // 5% APY coin::transfer<AptosCoin>(@staking_pool, sender, reward); stake_info.last_claim_time = current_time; } }",
        "vulnerabilities": [
            "No lock-up period for staked tokens",
            "Lack of slashing mechanism for misbehavior",
            "Potential for reward calculation errors due to integer division",
            "No mechanism to update reward rate",
            "Missing events for important actions"
        ]
    },
    {
        "code": "module Governance { use std::signer; use std::vector; struct Proposal has key { id: u64, description: vector<u8>, votes_for: u64, votes_against: u64, end_time: u64 } struct VotingPower has key { power: u64 } public fun create_proposal(account: &signer, description: vector<u8>, voting_period: u64) acquires Proposal { let sender = signer::address_of(account); let proposal_id = if (!exists<Proposal>(sender)) { 0 } else { borrow_global<Proposal>(sender).id + 1 }; move_to(account, Proposal { id: proposal_id, description, votes_for: 0, votes_against: 0, end_time: aptos_framework::timestamp::now_seconds() + voting_period }); } public fun vote(account: &signer, proposal_address: address, vote: bool) acquires Proposal, VotingPower { let sender = signer::address_of(account); let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(aptos_framework::timestamp::now_seconds() < proposal.end_time, 1); let voting_power = borrow_global<VotingPower>(sender).power; if (vote) { proposal.votes_for = proposal.votes_for + voting_power; } else { proposal.votes_against = proposal.votes_against + voting_power; } } public fun execute_proposal(account: &signer, proposal_address: address) acquires Proposal { let proposal = move_from<Proposal>(proposal_address); assert!(aptos_framework::timestamp::now_seconds() >= proposal.end_time, 2); assert!(proposal.votes_for > proposal.votes_against, 3); // Execute proposal logic here } }",
        "vulnerabilities": [
            "No quorum requirement for proposal execution",
            "Lack of proposal cancellation mechanism",
            "Missing access control for proposal creation",
            "No mechanism to prevent double voting",
            "Potential for last-minute voting attacks"
        ]
    },
    {
        "code": "module DecentralizedExchange { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> has key { reserve_x: coin::Coin<X>, reserve_y: coin::Coin<Y>, lp_tokens: coin::Coin<LPToken> } struct LPToken has drop {} public fun create_pool<X, Y>(account: &signer) { assert!(!exists<LiquidityPool<X, Y>>(signer::address_of(account)), 1); move_to(account, LiquidityPool<X, Y> { reserve_x: coin::zero<X>(), reserve_y: coin::zero<Y>(), lp_tokens: coin::zero<LPToken>() }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<X, Y>>(sender); let deposit_x = coin::withdraw<X>(account, amount_x); let deposit_y = coin::withdraw<Y>(account, amount_y); let lp_tokens_to_mint = if (coin::value(&pool.lp_tokens) == 0) { (amount_x * amount_y) as u64 } else { std::math::min((amount_x * coin::value(&pool.lp_tokens)) / coin::value(&pool.reserve_x), (amount_y * coin::value(&pool.lp_tokens)) / coin::value(&pool.reserve_y)) }; coin::merge(&mut pool.reserve_x, deposit_x); coin::merge(&mut pool.reserve_y, deposit_y); coin::deposit(sender, coin::extract(&mut pool.lp_tokens, lp_tokens_to_mint)); } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<X, Y>>(sender); let x_reserve = coin::value(&pool.reserve_x); let y_reserve = coin::value(&pool.reserve_y); let amount_out = (amount_in * y_reserve) / (x_reserve + amount_in); assert!(amount_out >= min_amount_out, 2); coin::merge(&mut pool.reserve_x, coin::withdraw<X>(account, amount_in)); coin::deposit(sender, coin::extract(&mut pool.reserve_y, amount_out)); } }",
        "vulnerabilities": [
            "No slippage protection for liquidity providers",
            "Lack of fee mechanism for swaps",
            "Potential for price manipulation through large trades",
            "Missing events for important actions",
            "No mechanism to handle decimal precision issues"
        ]
    },
    {
        "code": "module TimeLock { use std::signer; use aptos_framework::coin; use aptos_framework::aptos_coin::AptosCoin; struct TimeLock has key { amount: u64, unlock_time: u64 } public fun create_timelock(account: &signer, amount: u64, lock_duration: u64) { let sender = signer::address_of(account); assert!(!exists<TimeLock>(sender), 1); coin::transfer<AptosCoin>(account, @timelock_vault, amount); move_to(account, TimeLock { amount, unlock_time: aptos_framework::timestamp::now_seconds() + lock_duration }); } public fun withdraw(account: &signer) acquires TimeLock { let sender = signer::address_of(account); let TimeLock { amount, unlock_time } = move_from<TimeLock>(sender); assert!(aptos_framework::timestamp::now_seconds() >= unlock_time, 2); coin::transfer<AptosCoin>(@timelock_vault, sender, amount); } public fun extend_lock(account: &signer, additional_duration: u64) acquires TimeLock { let timelock = borrow_global_mut<TimeLock>(signer::address_of(account)); timelock.unlock_time = timelock.unlock_time + additional_duration; } }",
        "vulnerabilities": [
            "No partial withdrawal mechanism",
            "Lack of emergency unlock feature",
            "Missing events for important actions",
            "No mechanism to update locked amount",
            "Potential for DOS if unlock time is set too far in the future"
        ]
    },
    {
        "code": "module CrowdFunding { use std::signer; use aptos_framework::coin; use aptos_framework::aptos_coin::AptosCoin; struct Campaign has key { creator: address, goal: u64, raised: u64, end_time: u64, claimed: bool } public fun create_campaign(account: &signer, goal: u64, duration: u64) { let sender = signer::address_of(account); assert!(!exists<Campaign>(sender), 1); move_to(account, Campaign { creator: sender, goal, raised: 0, end_time: aptos_framework::timestamp::now_seconds() + duration, claimed: false }); } public fun contribute(account: &signer, campaign_address: address, amount: u64) acquires Campaign { let campaign = borrow_global_mut<Campaign>(campaign_address); assert!(aptos_framework::timestamp::now_seconds() < campaign.end_time, 2); coin::transfer<AptosCoin>(account, campaign_address, amount); campaign.raised = campaign.raised + amount; } public fun claim_funds(account: &signer) acquires Campaign { let sender = signer::address_of(account); let campaign = borrow_global_mut<Campaign>(sender); assert!(campaign.creator == sender, 3); assert!(campaign.raised >= campaign.goal, 4); assert!(!campaign.claimed, 5); assert!(aptos_framework::timestamp::now_seconds() >= campaign.end_time, 6); coin::transfer<AptosCoin>(sender, campaign.creator, campaign.raised); campaign.claimed = true; } public fun refund(account: &signer, campaign_address: address) acquires Campaign { let campaign = borrow_global<Campaign>(campaign_address); assert!(aptos_framework::timestamp::now_seconds() >= campaign.end_time, 7); assert!(campaign.raised < campaign.goal, 8); assert!(!campaign.claimed, 9); // Logic to refund contributors } }",
        "vulnerabilities": [
            "No mechanism to cancel a campaign",
            "Lack of partial refund feature if goal is not met",
            "Missing events for important actions",
            "No protection against creator withdrawing funds early",
            "Potential for front-running attacks on contributions"
        ]
    },
    
    {
        "code": "module VotingSystem { use std::signer; use aptos_framework::timestamp; struct Proposal has key { description: vector<u8>, vote_start: u64, vote_end: u64, yes_votes: u64, no_votes: u64, executed: bool } struct Voter has key { power: u64, voted: bool } public fun create_proposal(creator: &signer, description: vector<u8>, duration: u64) { let start = timestamp::now_seconds(); move_to(creator, Proposal { description, vote_start: start, vote_end: start + duration, yes_votes: 0, no_votes: 0, executed: false }); } public fun register_voter(account: &signer, power: u64) { move_to(account, Voter { power, voted: false }); } public fun vote(voter: &signer, proposal_address: address, vote: bool) acquires Proposal, Voter { let sender = signer::address_of(voter); let proposal = borrow_global_mut<Proposal>(proposal_address); let voter_info = borrow_global_mut<Voter>(sender); assert!(!voter_info.voted, 1); assert!(timestamp::now_seconds() >= proposal.vote_start && timestamp::now_seconds() <= proposal.vote_end, 2); voter_info.voted = true; if (vote) { proposal.yes_votes = proposal.yes_votes + voter_info.power; } else { proposal.no_votes = proposal.no_votes + voter_info.power; } } public fun execute_proposal(executor: &signer, proposal_address: address) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(timestamp::now_seconds() > proposal.vote_end, 3); assert!(!proposal.executed, 4); assert!(proposal.yes_votes > proposal.no_votes, 5); proposal.executed = true; // Execute proposal logic here } }",
        "vulnerabilities": [
            "No mechanism to update voter power",
            "Lack of access control for creating proposals",
            "Missing events for voting and execution",
            "No support for vote delegation",
            "Potential for flash loan attacks to manipulate voting"
        ]
    },
    {
        "code": "module SimpleDAO { use std::signer; use aptos_framework::coin; struct Proposal has key { id: u64, description: vector<u8>, votes_for: u64, votes_against: u64, executed: bool, } public fun create_proposal(creator: &signer, description: vector<u8>) { let proposal_id = get_next_proposal_id(); move_to(creator, Proposal { id: proposal_id, description, votes_for: 0, votes_against: 0, executed: false }); } public fun vote(voter: &signer, proposal_id: u64, vote_for: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@dao_address); if (vote_for) { proposal.votes_for += 1; } else { proposal.votes_against += 1; } } public fun execute_proposal(executor: &signer, proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@dao_address); assert!(!proposal.executed, 1); assert!(proposal.votes_for > proposal.votes_against, 2); // Execute proposal logic here proposal.executed = true; } }",
        "vulnerabilities": [
            "No check for duplicate votes",
            "Lack of voting power based on token holdings",
            "Missing time-based constraints for voting",
            "No quorum requirement for proposal execution",
            "Potential for proposal spam",
            "Lack of access control for proposal creation",
            "Missing events for proposal lifecycle",
            "No mechanism to cancel or update proposals",
            "Potential for front-running proposal execution",
            "Lack of delay between proposal passing and execution"
        ]
    },
    {
        "code": "module SimpleLending { use std::signer; use aptos_framework::coin; struct Loan has key { borrower: address, amount: u64, interest_rate: u64, due_date: u64, repaid: bool, } public fun request_loan(borrower: &signer, amount: u64, interest_rate: u64, duration: u64) { let due_date = timestamp::now_seconds() + duration; move_to(borrower, Loan { borrower: signer::address_of(borrower), amount, interest_rate, due_date, repaid: false }); coin::transfer<AptosCoin>(@lending_pool, signer::address_of(borrower), amount); } public fun repay_loan(borrower: &signer) acquires Loan { let loan = move_from<Loan>(signer::address_of(borrower)); assert!(!loan.repaid, 1); let repayment_amount = loan.amount + (loan.amount * loan.interest_rate / 100); coin::transfer<AptosCoin>(borrower, @lending_pool, repayment_amount); } }",
        "vulnerabilities": [
            "No collateral requirement",
            "Missing checks for borrower's credit-worthiness",
            "Lack of partial repayment functionality",
            "No mechanism to handle defaulted loans",
            "Missing events for loan lifecycle",
            "Potential for interest rate manipulation",
            "No checks for maximum loan amounts",
            "Lack of access control for loan approval",
            "Missing time-based interest calculation",
            "No mechanism to extend loan duration"
        ]
    },
    {
        "code": "module DecentralizedExchange { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom TokenX, phantom TokenY> has key { reserve_x: u64, reserve_y: u64, total_shares: u64 } struct LiquidityProvider<phantom TokenX, phantom TokenY> has key { shares: u64 } public fun create_pool<TokenX, TokenY>(creator: &signer) { move_to(creator, LiquidityPool<TokenX, TokenY> { reserve_x: 0, reserve_y: 0, total_shares: 0 }); } public fun add_liquidity<TokenX, TokenY>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool, LiquidityProvider { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<TokenX, TokenY>>(@pool_address); let shares = if (pool.total_shares == 0) { (amount_x * amount_y) as u64 } else { std::math::min((amount_x * pool.total_shares) / pool.reserve_x, (amount_y * pool.total_shares) / pool.reserve_y) }; pool.reserve_x = pool.reserve_x + amount_x; pool.reserve_y = pool.reserve_y + amount_y; pool.total_shares = pool.total_shares + shares; if (!exists<LiquidityProvider<TokenX, TokenY>>(sender)) { move_to(account, LiquidityProvider<TokenX, TokenY> { shares: 0 }); } let provider = borrow_global_mut<LiquidityProvider<TokenX, TokenY>>(sender); provider.shares = provider.shares + shares; coin::transfer<TokenX>(account, @pool_address, amount_x); coin::transfer<TokenY>(account, @pool_address, amount_y); } public fun swap<TokenX, TokenY>(account: &signer, amount_in: u64, min_amount_out: u64, x_to_y: bool) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<TokenX, TokenY>>(@pool_address); let (reserve_in, reserve_out) = if (x_to_y) { (pool.reserve_x, pool.reserve_y) } else { (pool.reserve_y, pool.reserve_x) }; let amount_out = (amount_in * 997 * reserve_out) / (reserve_in * 1000 + amount_in * 997); assert!(amount_out >= min_amount_out, 1); if (x_to_y) { pool.reserve_x = pool.reserve_x + amount_in; pool.reserve_y = pool.reserve_y - amount_out; coin::transfer<TokenX>(account, @pool_address, amount_in); coin::transfer<TokenY>(@pool_address, signer::address_of(account), amount_out); } else { pool.reserve_y = pool.reserve_y + amount_in; pool.reserve_x = pool.reserve_x - amount_out; coin::transfer<TokenY>(account, @pool_address, amount_in); coin::transfer<TokenX>(@pool_address, signer::address_of(account), amount_out); } } }",
        "vulnerabilities": [
            "Lack of slippage protection in add_liquidity",
            "No mechanism for removing liquidity",
            "Missing events for important actions",
            "Potential for front-running attacks in swaps",
            "No access control for creating pools",
            "Vulnerability to flash loan attacks"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; struct Auction has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64 } public fun create_auction(seller: &signer, duration: u64) { let now = timestamp::now_seconds(); move_to(seller, Auction { seller: signer::address_of(seller), highest_bidder: @0x0, highest_bid: 0, end_time: now + duration }); } public fun bid(bidder: &signer, amount: u64) acquires Auction { let auction = borrow_global_mut<Auction>(@auction_address); assert!(timestamp::now_seconds() < auction.end_time, 1); assert!(amount > auction.highest_bid, 2); auction.highest_bidder = signer::address_of(bidder); auction.highest_bid = amount; } }",
        "vulnerabilities": [
            "No mechanism to return funds to previous highest bidder",
            "Possible timestamp manipulation"
        ]
    },
    {
        "code": "module VotingSystem { use std::signer; use aptos_framework::event; struct Proposal has key { id: u64, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64 } struct Vote has drop, store { proposal_id: u64, voter: address, vote: bool } struct VoteEvent has drop, store { proposal_id: u64, voter: address, vote: bool } struct ProposalStore has key { proposals: vector<Proposal>, vote_events: event::EventHandle<VoteEvent> } public fun create_proposal(creator: &signer, description: vector<u8>, duration: u64) acquires ProposalStore { let sender = signer::address_of(creator); if (!exists<ProposalStore>(sender)) { move_to(creator, ProposalStore { proposals: vector::empty(), vote_events: event::new_event_handle<VoteEvent>(creator) }); } let store = borrow_global_mut<ProposalStore>(sender); let proposal = Proposal { id: vector::length(&store.proposals), description, yes_votes: 0, no_votes: 0, end_time: aptos_framework::timestamp::now_seconds() + duration }; vector::push_back(&mut store.proposals, proposal); } public fun vote(voter: &signer, creator: address, proposal_id: u64, vote: bool) acquires ProposalStore { let store = borrow_global_mut<ProposalStore>(creator); let proposal = vector::borrow_mut(&mut store.proposals, proposal_id); assert!(aptos_framework::timestamp::now_seconds() < proposal.end_time, 1); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } event::emit_event(&mut store.vote_events, VoteEvent { proposal_id, voter: signer::address_of(voter), vote }); } }",
        "vulnerabilities": [
            "No check for duplicate votes",
            "Lack of access control for proposal creation",
            "No mechanism to end or finalize proposals",
            "Potential for frontrunning attacks on votes",
            "No limit on proposal duration",
            "Missing events for proposal creation"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::token; struct Listing has store { creator: address, token_id: token::TokenId, price: u64 } struct Marketplace has key { listings: vector<Listing> } public fun create_marketplace(creator: &signer) { move_to(creator, Marketplace { listings: vector::empty() }); } public fun list_token<CoinType>(seller: &signer, token_id: token::TokenId, price: u64) acquires Marketplace { let marketplace = borrow_global_mut<Marketplace>(@marketplace_address); let listing = Listing { creator: signer::address_of(seller), token_id, price }; vector::push_back(&mut marketplace.listings, listing); token::transfer(seller, @marketplace_address, token_id); } public fun buy_token<CoinType>(buyer: &signer, index: u64) acquires Marketplace { let marketplace = borrow_global_mut<Marketplace>(@marketplace_address); let listing = vector::remove(&mut marketplace.listings, index); coin::transfer<CoinType>(buyer, listing.creator, listing.price); token::transfer(@marketplace_address, signer::address_of(buyer), listing.token_id); } }",
        "vulnerabilities": [
            "No mechanism to cancel listings",
            "Lack of access control for marketplace creation",
            "No checks for token ownership before listing",
            "Potential for price manipulation",
            "Missing events for important actions",
            "No royalty distribution mechanism"
        ]
    },
    {
        "code": "module StakingPool { use std::signer; use aptos_framework::coin; struct StakeInfo has key { amount: u64, last_claim_time: u64 } struct Pool has key { total_staked: u64, reward_per_second: u64 } public fun create_pool(creator: &signer, reward_per_second: u64) { move_to(creator, Pool { total_staked: 0, reward_per_second }); } public fun stake<CoinType>(staker: &signer, amount: u64) acquires Pool, StakeInfo { let sender = signer::address_of(staker); let pool = borrow_global_mut<Pool>(@pool_address); pool.total_staked = pool.total_staked + amount; if (!exists<StakeInfo>(sender)) { move_to(staker, StakeInfo { amount: 0, last_claim_time: aptos_framework::timestamp::now_seconds() }); } let stake_info = borrow_global_mut<StakeInfo>(sender); stake_info.amount = stake_info.amount + amount; coin::transfer<CoinType>(staker, @pool_address, amount); } public fun claim_rewards<CoinType>(staker: &signer) acquires Pool, StakeInfo { let sender = signer::address_of(staker); let pool = borrow_global<Pool>(@pool_address); let stake_info = borrow_global_mut<StakeInfo>(sender); let current_time = aptos_framework::timestamp::now_seconds(); let time_elapsed = current_time - stake_info.last_claim_time; let reward = (stake_info.amount * pool.reward_per_second * time_elapsed) / pool.total_staked; stake_info.last_claim_time = current_time; coin::transfer<CoinType>(@pool_address, sender, reward); } }",
        "vulnerabilities": [
            "No mechanism to unstake tokens",
            "Potential for reward calculation errors with integer division",
            "Lack of access control for pool creation",
            "No checks for sufficient pool balance when claiming rewards",
            "Missing events for staking and claiming",
            "Vulnerability to flash loan attacks for reward manipulation"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use aptos_framework::coin; struct Transaction has store { to: address, amount: u64, approvals: vector<address>, executed: bool } struct Wallet has key { owners: vector<address>, required_approvals: u64, transactions: vector<Transaction> } public fun create_wallet(creator: &signer, owners: vector<address>, required_approvals: u64) { assert!(vector::length(&owners) >= required_approvals, 1); move_to(creator, Wallet { owners, required_approvals, transactions: vector::empty() }); } public fun submit_transaction<CoinType>(submitter: &signer, to: address, amount: u64) acquires Wallet { let wallet = borrow_global_mut<Wallet>(@wallet_address); let transaction = Transaction { to, amount, approvals: vector::empty(), executed: false }; vector::push_back(&mut wallet.transactions, transaction); } public fun approve_transaction<CoinType>(approver: &signer, tx_index: u64) acquires Wallet { let wallet = borrow_global_mut<Wallet>(@wallet_address); let transaction = vector::borrow_mut(&mut wallet.transactions, tx_index); assert!(!transaction.executed, 2); let approver_address = signer::address_of(approver); assert!(vector::contains(&wallet.owners, &approver_address), 3); assert!(!vector::contains(&transaction.approvals, &approver_address), 4); vector::push_back(&mut transaction.approvals, approver_address); if (vector::length(&transaction.approvals) >= wallet.required_approvals) { transaction.executed = true; coin::transfer<CoinType>(@wallet_address, transaction.to, transaction.amount); } } }",
        "vulnerabilities": [
            "No mechanism to remove or change owners",
            "Lack of transaction expiration",
            "Missing events for important actions",
            "No way to cancel submitted transactions",
            "Potential for approval frontrunning",
            "No checks for sufficient wallet balance when executing transactions"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::token; struct Listing has key { token_id: token::TokenId, price: u64 } public fun list_token(seller: &signer, token_id: token::TokenId, price: u64) { move_to(seller, Listing { token_id, price }); } public fun buy_token<CoinType>(buyer: &signer, seller_address: address) acquires Listing { let listing = move_from<Listing>(seller_address); coin::transfer<CoinType>(buyer, seller_address, listing.price); token::transfer(seller_address, signer::address_of(buyer), listing.token_id); } }",
        "vulnerabilities": [
            "No mechanism to cancel listings",
            "Lack of access control for buying tokens",
            "No events emitted for important actions",
            "Potential for front-running attacks",
            "No royalty support for original creators",
            "Vulnerability to price manipulation"
        ]
    },
    {
        "code": "module Staking { use std::signer; use aptos_framework::coin; struct StakeInfo has key { amount: u64, start_time: u64 } public fun stake<CoinType>(account: &signer, amount: u64) { let sender = signer::address_of(account); coin::transfer<CoinType>(account, @staking_pool, amount); if (!exists<StakeInfo>(sender)) { move_to(account, StakeInfo { amount: 0, start_time: 0 }); } let stake_info = borrow_global_mut<StakeInfo>(sender); stake_info.amount = stake_info.amount + amount; stake_info.start_time = aptos_framework::timestamp::now_seconds(); } public fun unstake<CoinType>(account: &signer) acquires StakeInfo { let sender = signer::address_of(account); let stake_info = move_from<StakeInfo>(sender); coin::transfer<CoinType>(@staking_pool, sender, stake_info.amount); } }",
        "vulnerabilities": [
            "No reward calculation mechanism",
            "Lack of cooldown period for unstaking",
            "Missing events for stake and unstake actions",
            "No access control for staking pool",
            "Potential for reentrancy attacks",
            "No mechanism to update staking parameters"
        ]
    },
    {
        "code": "module Governance { use std::signer; struct Proposal has key { id: u64, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64 } struct VoteRecord has key { voted_proposals: vector<u64> } public fun create_proposal(creator: &signer, description: vector<u8>, voting_period: u64) { let proposal_id = get_next_proposal_id(); move_to(creator, Proposal { id: proposal_id, description, yes_votes: 0, no_votes: 0, end_time: aptos_framework::timestamp::now_seconds() + voting_period }); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal, VoteRecord { let proposal = borrow_global_mut<Proposal>(@governance_address); assert!(aptos_framework::timestamp::now_seconds() <= proposal.end_time, 1); if (vote) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } if (!exists<VoteRecord>(signer::address_of(voter))) { move_to(voter, VoteRecord { voted_proposals: vector::empty() }); } let vote_record = borrow_global_mut<VoteRecord>(signer::address_of(voter)); vector::push_back(&mut vote_record.voted_proposals, proposal_id); } }",
        "vulnerabilities": [
            "No mechanism to execute approved proposals",
            "Lack of minimum quorum for proposal validity",
            "Missing events for proposal creation and voting",
            "No access control for creating proposals",
            "Potential for double voting",
            "Vulnerability to last-minute voting attacks"
        ]
    },
    {
        "code": "module LendingProtocol { use std::signer; use aptos_framework::coin; struct LendingPool<phantom CoinType> has key { total_borrowed: u64, total_supplied: u64, interest_rate: u64 } struct UserPosition<phantom CoinType> has key { borrowed: u64, supplied: u64 } public fun supply<CoinType>(supplier: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_pool); pool.total_supplied = pool.total_supplied + amount; let sender = signer::address_of(supplier); if (!exists<UserPosition<CoinType>>(sender)) { move_to(supplier, UserPosition<CoinType> { borrowed: 0, supplied: 0 }); } let position = borrow_global_mut<UserPosition<CoinType>>(sender); position.supplied = position.supplied + amount; coin::transfer<CoinType>(supplier, @lending_pool, amount); } public fun borrow<CoinType>(borrower: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_pool); assert!(pool.total_supplied - pool.total_borrowed >= amount, 1); pool.total_borrowed = pool.total_borrowed + amount; let sender = signer::address_of(borrower); let position = borrow_global_mut<UserPosition<CoinType>>(sender); position.borrowed = position.borrowed + amount; coin::transfer<CoinType>(@lending_pool, sender, amount); } }",
        "vulnerabilities": [
            "No collateral system for borrowing",
            "Lack of liquidation mechanism",
            "Missing interest accrual implementation",
            "No events for supply and borrow actions",
            "Potential for flash loan attacks",
            "Vulnerability to interest rate manipulation"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; use aptos_framework::coin; struct MultiSig has key { owners: vector<address>, required_confirmations: u64 } struct Transaction has key { to: address, amount: u64, confirmations: u64 } public fun create_wallet(creator: &signer, owners: vector<address>, required_confirmations: u64) { move_to(creator, MultiSig { owners, required_confirmations }); } public fun propose_transaction<CoinType>(proposer: &signer, to: address, amount: u64) acquires MultiSig { let multi_sig = borrow_global<MultiSig>(@wallet_address); assert!(vector::contains(&multi_sig.owners, &signer::address_of(proposer)), 1); let tx_id = get_next_tx_id(); move_to(proposer, Transaction { to, amount, confirmations: 1 }); } public fun confirm_transaction<CoinType>(confirmer: &signer, tx_id: u64) acquires MultiSig, Transaction { let multi_sig = borrow_global<MultiSig>(@wallet_address); assert!(vector::contains(&multi_sig.owners, &signer::address_of(confirmer)), 1); let tx = borrow_global_mut<Transaction>(@wallet_address); tx.confirmations = tx.confirmations + 1; if (tx.confirmations >= multi_sig.required_confirmations) { let Transaction { to, amount, confirmations: _ } = move_from<Transaction>(@wallet_address); coin::transfer<CoinType>(@wallet_address, to, amount); } } }",
        "vulnerabilities": [
            "No mechanism to change owners or required confirmations",
            "Lack of transaction execution separation from confirmation",
            "Missing events for important actions",
            "No way to cancel or reject transactions",
            "Potential for transaction front-running",
            "Vulnerability to owner key compromise"
        ]
    },
    {
        "code": "module TokenVesting { use std::signer; use aptos_framework::coin; struct VestingSchedule has key { beneficiary: address, total_amount: u64, released_amount: u64, start_time: u64, duration: u64 } public fun create_vesting_schedule(creator: &signer, beneficiary: address, total_amount: u64, start_time: u64, duration: u64) { move_to(creator, VestingSchedule { beneficiary, total_amount, released_amount: 0, start_time, duration }); coin::transfer<AptosCoin>(creator, @vesting_contract, total_amount); } public fun release<CoinType>(caller: &signer) acquires VestingSchedule { let schedule = borrow_global_mut<VestingSchedule>(@vesting_contract); let current_time = aptos_framework::timestamp::now_seconds(); let vested_amount = if (current_time >= schedule.start_time + schedule.duration) { schedule.total_amount } else { let elapsed = current_time - schedule.start_time; (schedule.total_amount * elapsed) / schedule.duration }; let to_release = vested_amount - schedule.released_amount; schedule.released_amount = schedule.released_amount + to_release; coin::transfer<CoinType>(@vesting_contract, schedule.beneficiary, to_release); } }",
        "vulnerabilities": [
            "No mechanism to handle multiple vesting schedules",
            "Lack of access control for releasing tokens",
            "Missing events for schedule creation and token release",
            "No way to cancel or modify vesting schedules",
            "Potential for precision loss in vesting calculations",
            "Vulnerability to time manipulation attacks"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; use aptos_framework::coin; struct BridgeConfig has key { admin: address, fee_percentage: u64 } struct PendingWithdrawal has key { amount: u64, recipient: address } public fun initialize(admin: &signer, fee_percentage: u64) { move_to(admin, BridgeConfig { admin: signer::address_of(admin), fee_percentage }); } public fun deposit<CoinType>(user: &signer, amount: u64, recipient: address) acquires BridgeConfig { let config = borrow_global<BridgeConfig>(@bridge_address); let fee = (amount * config.fee_percentage) / 10000; let net_amount = amount - fee; coin::transfer<CoinType>(user, @bridge_address, amount); move_to(user, PendingWithdrawal { amount: net_amount, recipient }); } public fun withdraw<CoinType>(admin: &signer, withdrawal_id: u64) acquires BridgeConfig, PendingWithdrawal { let config = borrow_global<BridgeConfig>(@bridge_address); assert!(signer::address_of(admin) == config.admin, 1); let PendingWithdrawal { amount, recipient } = move_from<PendingWithdrawal>(@bridge_address); coin::transfer<CoinType>(@bridge_address, recipient, amount); } }",
        "vulnerabilities": [
            "No mechanism for verifying cross-chain transactions",
            "Lack of pause functionality for emergencies",
            "Missing events for deposit and withdrawal actions",
            "No way to update bridge configuration",
            "Potential for front-running in withdrawals",
            "Vulnerability to admin key compromise"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; struct Market has key { id: u64, question: vector<u8>, resolution_time: u64, total_yes_amount: u64, total_no_amount: u64, resolved: bool, outcome: bool } struct Position has key { market_id: u64, yes_amount: u64, no_amount: u64 } public fun create_market(creator: &signer, question: vector<u8>, resolution_time: u64) { let market_id = get_next_market_id(); move_to(creator, Market { id: market_id, question, resolution_time, total_yes_amount: 0, total_no_amount: 0, resolved: false, outcome: false }); } public fun place_bet<CoinType>(bettor: &signer, market_id: u64, amount: u64, bet_yes: bool) acquires Market, Position { let market = borrow_global_mut<Market>(@prediction_market); assert!(!market.resolved && aptos_framework::timestamp::now_seconds() < market.resolution_time, 1); if (bet_yes) { market.total_yes_amount = market.total_yes_amount + amount; } else { market.total_no_amount = market.total_no_amount + amount; } let sender = signer::address_of(bettor); if (!exists<Position>(sender)) { move_to(bettor, Position { market_id, yes_amount: 0, no_amount: 0 }); } let position = borrow_global_mut<Position>(sender); if (bet_yes) { position.yes_amount = position.yes_amount + amount; } else { position.no_amount = position.no_amount + amount; } coin::transfer<CoinType>(bettor, @prediction_market, amount); } public fun resolve_market(admin: &signer, market_id: u64, outcome: bool) acquires Market { let market = borrow_global_mut<Market>(@prediction_market); assert!(!market.resolved && aptos_framework::timestamp::now_seconds() >= market.resolution_time, 1); market.resolved = true; market.outcome = outcome; } }",
        "vulnerabilities": [
            "No mechanism for claiming winnings",
            "Lack of oracle integration for resolution",
            "Missing events for market creation and resolution",
            "No access control for market resolution",
            "Potential for market manipulation",
            "Vulnerability to front-running in bet placement"
        ]
    },
    {
        "code": "module TimelockController { use std::signer; use aptos_framework::coin; struct Timelock has key { admin: address, minimum_delay: u64 } struct Operation has key { id: u64, target: address, data: vector<u8>, execution_time: u64, executed: bool } public fun initialize(admin: &signer, minimum_delay: u64) { move_to(admin, Timelock { admin: signer::address_of(admin), minimum_delay }); } public fun schedule(admin: &signer, target: address, data: vector<u8>, delay: u64) acquires Timelock { let timelock = borrow_global<Timelock>(@timelock_address); assert!(signer::address_of(admin) == timelock.admin, 1); assert!(delay >= timelock.minimum_delay, 2); let operation_id = get_next_operation_id(); let execution_time = aptos_framework::timestamp::now_seconds() + delay; move_to(admin, Operation { id: operation_id, target, data, execution_time, executed: false }); } public fun execute(caller: &signer, operation_id: u64) acquires Operation { let operation = borrow_global_mut<Operation>(@timelock_address); assert!(!operation.executed && aptos_framework::timestamp::now_seconds() >= operation.execution_time, 1); operation.executed = true; // Execute operation logic here } }",
        "vulnerabilities": [
            "No mechanism to cancel scheduled operations",
            "Lack of access control for execution",
            "Missing events for scheduling and execution",
            "No way to update timelock parameters",
            "Potential for griefing attacks",
            "Vulnerability to time manipulation attacks"
        ]
    },
    {
        "code": "module TimeLock { use std::signer; use aptos_framework::coin; struct LockedFunds<phantom CoinType> has key { amount: u64, unlock_time: u64 } public fun lock_funds<CoinType>(account: &signer, amount: u64, lock_duration: u64) { let sender = signer::address_of(account); assert!(!exists<LockedFunds<CoinType>>(sender), 1); let unlock_time = aptos_framework::timestamp::now_seconds() + lock_duration; move_to(account, LockedFunds<CoinType> { amount, unlock_time }); coin::transfer<CoinType>(account, @timelock_address, amount); } public fun unlock_funds<CoinType>(account: &signer) acquires LockedFunds { let sender = signer::address_of(account); let LockedFunds { amount, unlock_time } = move_from<LockedFunds<CoinType>>(sender); assert!(aptos_framework::timestamp::now_seconds() >= unlock_time, 2); coin::transfer<CoinType>(@timelock_address, sender, amount); } }",
        "vulnerabilities": [
            "No partial unlocking mechanism",
            "Lack of access control for locking funds",
            "Missing events for locking and unlocking",
            "No way to extend lock duration",
            "Potential for griefing by locking small amounts",
            "No emergency unlock mechanism"
        ]
    },
    {
        "code": "module Staking { use std::signer; use aptos_framework::coin; struct Staker has key { balance: u64, start_time: u64, } public fun stake(account: &signer, amount: u64) { let staker = signer::address_of(account); let start_time = aptos_framework::timestamp::now_seconds(); move_to(account, Staker { balance: amount, start_time }); coin::transfer(account, staker, amount); } public fun unstake(account: &signer) acquires Staker { let staker = signer::address_of(account); let staker_info = borrow_global_mut<Staker>(staker); coin::transfer(account, staker, staker_info.balance); destroy(staker_info); } public fun check_rewards(account: &signer): u64 acquires Staker { let staker = signer::address_of(account); let staker_info = borrow_global<Staker>(staker); aptos_framework::timestamp::now_seconds() - staker_info.start_time } }",
        "vulnerabilities": [
            "No event emissions for staking and unstaking",
            "No mechanism for reward distribution",
            "No validation of staking amount",
            "Centralization of staking management",
            "No mechanism for slashing penalties",
            "No prevention of reentrancy attacks",
            "No mechanism for staking duration",
            "No prevention of multiple staking by one user",
            "No mechanism for partial unstaking",
            "No prevention of early unstaking"
        ]
    },
    {
        "code": "module SimpleDAO { use std::signer; use aptos_framework::coin; struct Proposal has store { id: u64, description: vector<u8>, vote_yes: u64, vote_no: u64, status: u8 } struct DAO has key { proposals: vector<Proposal>, treasury: u64 } public fun create_dao(creator: &signer) { move_to(creator, DAO { proposals: vector::empty(), treasury: 0 }); } public fun donate<CoinType>(donor: &signer, amount: u64) acquires DAO { let dao = borrow_global_mut<DAO>(@dao_address); dao.treasury = dao.treasury + amount; coin::transfer<CoinType>(donor, @dao_address, amount); } public fun create_proposal(creator: &signer, description: vector<u8>) acquires DAO { let dao = borrow_global_mut<DAO>(@dao_address); let proposal = Proposal { id: vector::length(&dao.proposals), description, vote_yes: 0, vote_no: 0, status: 0 }; vector::push_back(&mut dao.proposals, proposal); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires DAO { let dao = borrow_global_mut<DAO>(@dao_address); let proposal = vector::borrow_mut(&mut dao.proposals, proposal_id); assert!(proposal.status == 0, 1); if (vote) { proposal.vote_yes = proposal.vote_yes + 1; } else { proposal.vote_no = proposal.vote_no + 1; } } }",
        "vulnerabilities": [
            "No mechanism to execute approved proposals",
            "Lack of access control for proposal creation",
            "Missing events for important actions",
            "No voting power based on token holdings",
            "Potential for duplicate votes",
            "No time limit for voting on proposals"
        ]
    },
    {
        "code": "module Fundraising { use std::signer; use aptos_framework::coin; struct Campaign has key { creator: address, goal: u64, raised: u64, end_time: u64, contributors: vector<address>, } public fun create_campaign(account: &signer, goal: u64, duration: u64) { let creator = signer::address_of(account); let end_time = aptos_framework::timestamp::now_seconds() + duration; move_to(account, Campaign { creator, goal, raised: 0, end_time, contributors: vector::empty() }); } public fun contribute(account: &signer, amount: u64) acquires Campaign { let contributor = signer::address_of(account); let campaign = borrow_global_mut<Campaign>(contributor); assert!(aptos_framework::timestamp::now_seconds() < campaign.end_time, 1); campaign.raised = campaign.raised + amount; vector::push_back(&mut campaign.contributors, contributor); coin::transfer(account, contributor, amount); } public fun withdraw_funds(account: &signer) acquires Campaign { let creator = signer::address_of(account); let campaign = borrow_global_mut<Campaign>(creator); assert!(campaign.raised >= campaign.goal, 2); coin::transfer(account, creator, campaign.raised); destroy(campaign); } }",
        "vulnerabilities": [
            "No event emissions for contributions and withdrawals",
            "No mechanism for contribution refunds",
            "No validation of campaign goal and duration",
            "Centralization of campaign management",
            "No mechanism for partial fund withdrawals",
            "No prevention of reentrancy attacks",
            "No mechanism for campaign extensions",
            "No prevention of multiple contributions by one user",
            "No mechanism for contribution limits",
            "No prevention of goal overfunding"
        ]
    },
    {
        "code": "module SimpleLending { use std::signer; use aptos_framework::coin; struct LendingPool<phantom CoinType> has key { total_borrowed: u64, total_deposits: u64, interest_rate: u64 } struct UserAccount<phantom CoinType> has key { borrowed: u64, collateral: u64 } public fun create_pool<CoinType>(creator: &signer, interest_rate: u64) { move_to(creator, LendingPool<CoinType> { total_borrowed: 0, total_deposits: 0, interest_rate }); } public fun deposit<CoinType>(depositor: &signer, amount: u64) acquires LendingPool { let pool = borrow_global_mut<LendingPool<CoinType>>(@pool_address); pool.total_deposits = pool.total_deposits + amount; coin::transfer<CoinType>(depositor, @pool_address, amount); } public fun borrow<CoinType>(borrower: &signer, amount: u64) acquires LendingPool, UserAccount { let sender = signer::address_of(borrower); let pool = borrow_global_mut<LendingPool<CoinType>>(@pool_address); assert!(pool.total_deposits >= pool.total_borrowed + amount, 1); pool.total_borrowed = pool.total_borrowed + amount; if (!exists<UserAccount<CoinType>>(sender)) { move_to(borrower, UserAccount<CoinType> { borrowed: 0, collateral: 0 }); } let user_account = borrow_global_mut<UserAccount<CoinType>>(sender); user_account.borrowed = user_account.borrowed + amount; coin::transfer<CoinType>(@pool_address, sender, amount); } }",
        "vulnerabilities": [
            "No liquidation mechanism for undercollateralized positions",
            "Lack of access control for pool creation",
            "Missing events for deposits and borrows",
            "No mechanism to withdraw deposits",
            "Potential for insolvency if all users withdraw",
            "No checks for borrowing limits based on collateral"
        ]
    },
    {
        "code": "module SimpleInsurance { use std::signer; use aptos_framework::coin; struct Policy has key { coverage_amount: u64, premium: u64, expiry: u64 } struct InsurancePool has key { total_premiums: u64, total_payouts: u64 } public fun create_pool(creator: &signer) { move_to(creator, InsurancePool { total_premiums: 0, total_payouts: 0 }); } public fun buy_policy<CoinType>(buyer: &signer, coverage_amount: u64, premium: u64, duration: u64) acquires InsurancePool { let sender = signer::address_of(buyer); assert!(!exists<Policy>(sender), 1); let pool = borrow_global_mut<InsurancePool>(@pool_address); pool.total_premiums = pool.total_premiums + premium; move_to(buyer, Policy { coverage_amount, premium, expiry: aptos_framework::timestamp::now_seconds() + duration }); coin::transfer<CoinType>(buyer, @pool_address, premium); } public fun claim<CoinType>(claimer: &signer) acquires Policy, InsurancePool { let sender = signer::address_of(claimer); let Policy { coverage_amount, premium: _, expiry } = move_from<Policy>(sender); assert!(aptos_framework::timestamp::now_seconds() <= expiry, 2); let pool = borrow_global_mut<InsurancePool>(@pool_address); pool.total_payouts = pool.total_payouts + coverage_amount; coin::transfer<CoinType>(@pool_address, sender, coverage_amount); } }",
        "vulnerabilities": [
            "No verification of insurable interest",
            "Lack of access control for pool creation",
            "Missing events for policy creation and claims",
            "No mechanism to update or cancel policies",
            "Potential for insolvency if claims exceed premiums",
            "No gradual reduction in coverage amount over time"
        ]
    },
    {
        "code": "module SimpleVoting { use std::signer; use std::vector; struct Proposal has key { description: vector<u8>, yes_votes: u64, no_votes: u64 } struct Voter has key { has_voted: bool } public fun create_proposal(creator: &signer, description: vector<u8>) { move_to(creator, Proposal { description, yes_votes: 0, no_votes: 0 }); } public fun vote(voter: &signer, yes: bool) acquires Proposal, Voter { let voter_address = signer::address_of(voter); assert!(!exists<Voter>(voter_address), 1); let proposal = borrow_global_mut<Proposal>(@proposal_address); if (yes) { proposal.yes_votes = proposal.yes_votes + 1; } else { proposal.no_votes = proposal.no_votes + 1; } move_to(voter, Voter { has_voted: true }); } }",
        "vulnerabilities": [
            "Single proposal limitation",
            "No voting period or finalization mechanism"
        ]
    },
    {
        "code": "module SimpleLottery { use std::signer; use std::vector; struct Lottery has key { participants: vector<address>, prize: u64 } public fun create_lottery(creator: &signer, initial_prize: u64) { move_to(creator, Lottery { participants: vector::empty(), prize: initial_prize }); } public fun enter_lottery(participant: &signer) acquires Lottery { let lottery = borrow_global_mut<Lottery>(@lottery_address); vector::push_back(&mut lottery.participants, signer::address_of(participant)); } public fun draw_winner(admin: &signer) acquires Lottery { let lottery = borrow_global_mut<Lottery>(@lottery_address); let winner_index = (timestamp::now_microseconds() as u64) % vector::length(&lottery.participants); let winner = *vector::borrow(&lottery.participants, winner_index); // Transfer prize to winner } }",
        "vulnerabilities": [
            "Predictable randomness in winner selection",
            "No mechanism to prevent multiple entries from the same participant"
        ]
    },
    {
        "code": "module Marketplace { use std::signer; use aptos_framework::coin; struct Item has key { seller: address, price: u64, available: bool, } public fun list_item(account: &signer, price: u64) { let seller = signer::address_of(account); move_to(account, Item { seller, price, available: true }); } public fun buy_item(account: &signer) acquires Item { let buyer = signer::address_of(account); let item = borrow_global_mut<Item>(buyer); assert!(item.available, 1); item.available = false; coin::transfer(account, item.seller, item.price); } public fun cancel_listing(account: &signer) acquires Item { let seller = signer::address_of(account); let item = borrow_global_mut<Item>(seller); item.available = false; destroy(item); } }",
        "vulnerabilities": [
            "No event emissions for item listing, buying, and cancellation",
            "No mechanism for item relisting",
            "No validation of item price",
            "Centralization of marketplace management",
            "No prevention of reentrancy attacks",
            "No mechanism for buyer and seller ratings",
            "No prevention of multiple listings by one user",
            "No mechanism for dispute resolution",
            "No mechanism for item description",
            "No prevention of item impersonation"
        ]
    },
    {
        "code": "module SimpleStaking { use std::signer; struct StakeInfo has key { amount: u64, start_time: u64 } public fun stake(staker: &signer, amount: u64) { let now = timestamp::now_seconds(); move_to(staker, StakeInfo { amount, start_time: now }); } public fun unstake(staker: &signer) acquires StakeInfo { let stake_info = move_from<StakeInfo>(signer::address_of(staker)); let now = timestamp::now_seconds(); let duration = now - stake_info.start_time; let reward = calculate_reward(stake_info.amount, duration); // Transfer stake amount + reward to staker } public fun calculate_reward(amount: u64, duration: u64): u64 { amount * duration / 100 // 1% per unit of time } }",
        "vulnerabilities": [
            "No minimum staking period",
            "Possible integer overflow in reward calculation"
        ]
    },
    {
        "code": "module SimpleNFT { use std::signer; use std::string::String; struct NFT has key, store { id: u64, name: String, creator: address } struct Collection has key { nfts: vector<NFT>, next_id: u64 } public fun create_collection(creator: &signer) { move_to(creator, Collection { nfts: vector::empty(), next_id: 0 }); } public fun mint_nft(creator: &signer, name: String) acquires Collection { let collection = borrow_global_mut<Collection>(signer::address_of(creator)); let nft = NFT { id: collection.next_id, name, creator: signer::address_of(creator) }; vector::push_back(&mut collection.nfts, nft); collection.next_id = collection.next_id + 1; } }",
        "vulnerabilities": [
            "No transfer functionality",
            "Lack of uniqueness check for NFT names"
        ]
    },
    {
        "code": "module Crowdsale { use std::signer; use aptos_framework::coin; struct Crowdsale has key { owner: address, rate: u64, raised: u64, end_time: u64, } public fun start_crowdsale(account: &signer, rate: u64, duration: u64) { let owner = signer::address_of(account); let end_time = aptos_framework::timestamp::now_seconds() + duration; move_to(account, Crowdsale { owner, rate, raised: 0, end_time }); } public fun buy_tokens(account: &signer, amount: u64) acquires Crowdsale { let buyer = signer::address_of(account); let crowdsale = borrow_global_mut<Crowdsale>(buyer); assert!(aptos_framework::timestamp::now_seconds() < crowdsale.end_time, 1); crowdsale.raised = crowdsale.raised + amount; coin::transfer(account, buyer, amount * crowdsale.rate); } public fun finalize_crowdsale(account: &signer) acquires Crowdsale { let owner = signer::address_of(account); let crowdsale = borrow_global_mut<Crowdsale>(owner); assert!(aptos_framework::timestamp::now_seconds() >= crowdsale.end_time, 2); coin::transfer(account, owner, crowdsale.raised); destroy(crowdsale); } }",
        "vulnerabilities": [
            "No event emissions for token purchases and crowdsale finalization",
            "No mechanism for contribution refunds",
            "No validation of crowdsale rate and duration",
            "Centralization of crowdsale management",
            "No mechanism for partial withdrawals",
            "No prevention of reentrancy attacks",
            "No mechanism for crowdsale extensions",
            "No prevention of multiple contributions by one user",
            "No mechanism for contribution limits",
            "No prevention of goal overfunding"
        ]
    },
    {
        "code": "module Token { use std::signer; struct Token has key { total_supply: u64, balances: table::Table<address, u64> } public fun initialize(signer: &signer, initial_supply: u64) { let token = Token { total_supply: initial_supply, balances: table::new() }; table::add(&mut token.balances, signer::address_of(signer), initial_supply); move_to(signer, token); } public fun transfer(sender: &signer, recipient: address, amount: u64) acquires Token { let token = borrow_global_mut<Token>(signer::address_of(sender)); let sender_balance = table::remove(&mut token.balances, signer::address_of(sender)); assert!(sender_balance >= amount, 101); table::add(&mut token.balances, signer::address_of(sender), sender_balance - amount); let recipient_balance = if (table::contains(&token.balances, recipient)) { table::remove(&mut token.balances, recipient) } else { 0 }; table::add(&mut token.balances, recipient, recipient_balance + amount); } }",
        "vulnerabilities": [        "No event emissions for transfers",        "No access control for initialize function",        "No checks for integer overflow",        "Potential for gas limit issues with large number of holders",        "No mechanism to burn tokens"    ]
    },
    {
        "code": "module Crowdfunding { use std::signer; use aptos_framework::timestamp; struct Campaign has key { creator: address, goal: u64, pledged: u64, end_time: u64 } public fun create_campaign(creator: &signer, goal: u64, duration: u64) { let campaign = Campaign { creator: signer::address_of(creator), goal: goal, pledged: 0, end_time: timestamp::now_seconds() + duration }; move_to(creator, campaign); } public fun pledge(pledger: &signer, campaign_address: address, amount: u64) acquires Campaign { let campaign = borrow_global_mut<Campaign>(campaign_address); assert!(timestamp::now_seconds() < campaign.end_time, 101); campaign.pledged = campaign.pledged + amount; } public fun claim_funds(creator: &signer, campaign_address: address) acquires Campaign { let campaign = borrow_global_mut<Campaign>(campaign_address); assert!(timestamp::now_seconds() >= campaign.end_time, 102); assert!(campaign.pledged >= campaign.goal, 103); assert!(campaign.creator == signer::address_of(creator), 104); destroy(campaign); } }",
        "vulnerabilities": [        "Lack of refund mechanism for failed campaigns",        "No event emissions for pledges and campaign creation",        "No access control for pledge function",        "Potential for gas limit issues with large number of pledges",        "No mechanism to extend campaign time"    ]
    },
    {
        "code": "module SimpleSwap { use std::signer; struct LiquidityPool has key { token_a_reserve: u64, token_b_reserve: u64 } public fun create_pool(creator: &signer, initial_a: u64, initial_b: u64) { move_to(creator, LiquidityPool { token_a_reserve: initial_a, token_b_reserve: initial_b }); } public fun swap_a_to_b(user: &signer, amount_in: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); let amount_out = (amount_in * pool.token_b_reserve) / (pool.token_a_reserve + amount_in); pool.token_a_reserve = pool.token_a_reserve + amount_in; pool.token_b_reserve = pool.token_b_reserve - amount_out; // Transfer tokens } }",
        "vulnerabilities": [
            "No slippage protection",
            "Vulnerable to flash loan attacks"
        ]
    },
    {
        "code": "module SimpleGovernance { use std::signer; struct Proposal has key { id: u64, description: vector<u8>, votes: u64, executed: bool } struct GovernanceSystem has key { proposals: vector<Proposal>, next_proposal_id: u64 } public fun create_proposal(creator: &signer, description: vector<u8>) acquires GovernanceSystem { let gov_system = borrow_global_mut<GovernanceSystem>(@governance_address); let proposal = Proposal { id: gov_system.next_proposal_id, description, votes: 0, executed: false }; vector::push_back(&mut gov_system.proposals, proposal); gov_system.next_proposal_id = gov_system.next_proposal_id + 1; } public fun vote(voter: &signer, proposal_id: u64) acquires GovernanceSystem { let gov_system = borrow_global_mut<GovernanceSystem>(@governance_address); let proposal = vector::borrow_mut(&mut gov_system.proposals, proposal_id); proposal.votes = proposal.votes + 1; } }",
        "vulnerabilities": [
            "No quorum or voting power mechanism",
            "Lack of time-bound voting periods"
        ]
    },
    {
        "code": "module SimpleInsurance { use std::signer; struct Policy has key { premium: u64, coverage: u64, expiry: u64 } public fun create_policy(insurer: &signer, premium: u64, coverage: u64, duration: u64) { let now = timestamp::now_seconds(); move_to(insurer, Policy { premium, coverage, expiry: now + duration }); } public fun claim(policyholder: &signer, amount: u64) acquires Policy { let policy = borrow_global<Policy>(signer::address_of(policyholder)); assert!(timestamp::now_seconds() < policy.expiry, 1); assert!(amount <= policy.coverage, 2); // Process claim payout } }",
        "vulnerabilities": [
            "No verification of premium payment",
            "Lack of claim verification mechanism"
        ]
    },
    {
        "code": "module TokenSwap { use std::signer; struct LiquidityPool has key { token_x: u64, token_y: u64 } public fun add_liquidity(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); pool.token_x = pool.token_x + amount_x; pool.token_y = pool.token_y + amount_y; } public fun swap_x_to_y(account: &signer, amount_x: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool>(@pool_address); let y_out = (amount_x * pool.token_y) / (pool.token_x + amount_x); pool.token_x = pool.token_x + amount_x; pool.token_y = pool.token_y - y_out; } }",
        "vulnerabilities": [
            "No slippage protection",
            "Susceptible to flash loan attacks",
            "Lack of access control"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; struct NFT has key { id: u64, owner: address } struct Listing has key { nft_id: u64, price: u64 } public fun list_nft(seller: &signer, nft_id: u64, price: u64) acquires NFT { let nft = borrow_global_mut<NFT>(@nft_address); assert!(nft.owner == signer::address_of(seller), 1); move_to(seller, Listing { nft_id, price }); } public fun buy_nft(buyer: &signer, listing_address: address) acquires Listing, NFT { let listing = move_from<Listing>(listing_address); let nft = borrow_global_mut<NFT>(@nft_address); nft.owner = signer::address_of(buyer); } }",
        "vulnerabilities": [
            "No royalty mechanism",
            "Lack of escrow for secure transactions",
            "No checks for sufficient funds during purchase"
        ]
    },
    {
        "code": "module Voting { use std::signer; use aptos_framework::table; struct Election has key { votes: table::Table<address, u64> } public fun create_election(creator: &signer) { let election = Election { votes: table::new() }; move_to(creator, election); } public fun vote(voter: &signer, candidate: address, amount: u64) acquires Election { let election = borrow_global_mut<Election>(signer::address_of(voter)); let current_votes = if (table::contains(&election.votes, candidate)) { table::remove(&mut election.votes, candidate) } else { 0 }; table::add(&mut election.votes, candidate, current_votes + amount); } }",
        "vulnerabilities": [        "Lack of access control for vote function",        "No event emissions for votes and election creation",        "Potential for double voting",        "No checks for integer overflow",        "No mechanism to finalize election results"    ]
    },
    {
        "code": "module Staking { use std::signer; use aptos_framework::timestamp; struct Stake has key { amount: u64, end_time: u64 } public fun stake_tokens(staker: &signer, amount: u64, duration: u64) { let stake = Stake { amount: amount, end_time: timestamp::now_seconds() + duration }; move_to(staker, stake); } public fun withdraw_tokens(staker: &signer) acquires Stake { let stake = borrow_global_mut<Stake>(signer::address_of(staker)); assert!(timestamp::now_seconds() >= stake.end_time, 101); let amount = stake.amount; destroy(stake); } }",
        "vulnerabilities": [        "No event emissions for staking and withdrawal",        "No checks for minimum staking amount",        "Potential for early withdrawal",        "No mechanism to extend staking duration",        "No access control for withdrawal function"    ]
    },
    {
        "code": "module StakingRewards { use std::signer; struct StakeInfo has key { amount: u64, last_claim_time: u64 } public fun stake(staker: &signer, amount: u64) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(staker)); stake_info.amount = stake_info.amount + amount; stake_info.last_claim_time = timestamp::now_seconds(); } public fun claim_rewards(staker: &signer) acquires StakeInfo { let stake_info = borrow_global_mut<StakeInfo>(signer::address_of(staker)); let current_time = timestamp::now_seconds(); let reward = (current_time - stake_info.last_claim_time) * stake_info.amount * REWARD_RATE; stake_info.last_claim_time = current_time; } }",
        "vulnerabilities": [
            "No mechanism to handle stake slashing",
            "Potential for reward calculation overflow",
            "Lack of total staked amount tracking"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; struct BridgeInfo has key { locked_funds: u64, processed_txs: vector<u64> } public fun lock_funds(user: &signer, amount: u64) acquires BridgeInfo { let bridge = borrow_global_mut<BridgeInfo>(@bridge_address); bridge.locked_funds = bridge.locked_funds + amount; } public fun release_funds(relayer: &signer, tx_id: u64, amount: u64, recipient: address) acquires BridgeInfo { let bridge = borrow_global_mut<BridgeInfo>(@bridge_address); assert!(!vector::contains(&bridge.processed_txs, &tx_id), 1); vector::push_back(&mut bridge.processed_txs, tx_id); bridge.locked_funds = bridge.locked_funds - amount; } }",
        "vulnerabilities": [
            "No multi-signature validation for relayers",
            "Lack of event emission for tracking",
            "No mechanism to handle failed transactions"
        ]
    },
    {
        "code": "module TokenSwap { use std::signer; use aptos_framework::coin; struct Pool<phantom X, phantom Y> { reserve_x: u64, reserve_y: u64 } public fun create_pool<X, Y>(account: &signer) { move_to(account, Pool<X, Y> { reserve_x: 0, reserve_y: 0 }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires Pool { let pool = borrow_global_mut<Pool<X, Y>>(@token_swap); coin::transfer<X>(account, @token_swap, amount_x); coin::transfer<Y>(account, @token_swap, amount_y); pool.reserve_x += amount_x; pool.reserve_y += amount_y; } public fun swap<X, Y>(account: &signer, amount_in: u64) acquires Pool { let pool = borrow_global_mut<Pool<X, Y>>(@token_swap); let amount_out = (amount_in * pool.reserve_y) / (pool.reserve_x + amount_in); coin::transfer<X>(account, @token_swap, amount_in); coin::transfer<Y>(@token_swap, signer::address_of(account), amount_out); pool.reserve_x += amount_in; pool.reserve_y -= amount_out; } }",
        "vulnerabilities": [
            "No slippage protection",
            "Lack of fee mechanism",
            "Vulnerable to flash loan attacks",
            "No protection against impermanent loss",
            "Missing input validation for zero amounts"
        ]
    },
    
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_token::token; struct Listing { creator: address, token_id: token::TokenId, price: u64 } public fun list_nft(account: &signer, token_id: token::TokenId, price: u64) { let listing = Listing { creator: signer::address_of(account), token_id, price }; move_to(account, listing); token::opt_in_direct_transfer(account, true); } public fun buy_nft(buyer: &signer, seller: address, token_id: token::TokenId) acquires Listing { let listing = move_from<Listing>(seller); assert!(listing.token_id == token_id, 1); coin::transfer<AptosCoin>(buyer, seller, listing.price); token::transfer(seller, buyer, token_id); } public fun cancel_listing(account: &signer, token_id: token::TokenId) acquires Listing { let Listing { creator, token_id: _, price: _ } = move_from<Listing>(signer::address_of(account)); assert!(creator == signer::address_of(account), 1); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow for secure transactions",
            "Missing price negotiation feature",
            "No mechanism to update listing price",
            "Vulnerable to front-running attacks"
        ]
    },
    
    {
        "code": "module StakingRewards { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakeInfo { amount: u64, start_time: u64 } public fun stake(account: &signer, amount: u64) { let stake_info = StakeInfo { amount, start_time: timestamp::now_seconds() }; move_to(account, stake_info); coin::transfer<StakingToken>(account, @staking_pool, amount); } public fun unstake(account: &signer) acquires StakeInfo { let StakeInfo { amount, start_time } = move_from<StakeInfo>(signer::address_of(account)); let duration = timestamp::now_seconds() - start_time; let reward = calculate_reward(amount, duration); coin::transfer<StakingToken>(@staking_pool, signer::address_of(account), amount); coin::transfer<RewardToken>(@reward_pool, signer::address_of(account), reward); } fun calculate_reward(amount: u64, duration: u64): u64 { amount * duration / 100 } }",
        "vulnerabilities": [
            "Linear reward calculation may not incentivize long-term staking",
            "Lack of slashing mechanism for bad actors",
            "No compound interest feature",
            "Missing cool-down period for unstaking",
            "Vulnerable to reward draining if token price fluctuates"
        ]
    },
    
    {
        "code": "module VotingSystem { use std::signer; use std::vector; struct Proposal { id: u64, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64 } struct Vote { proposal_id: u64, in_favor: bool } public fun create_proposal(account: &signer, description: vector<u8>, duration: u64) { let proposal_id = get_next_proposal_id(); let end_time = timestamp::now_seconds() + duration; move_to(account, Proposal { id: proposal_id, description, yes_votes: 0, no_votes: 0, end_time }); } public fun vote(account: &signer, proposal_id: u64, in_favor: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@voting_system); assert!(timestamp::now_seconds() < proposal.end_time, 1); if (in_favor) { proposal.yes_votes += 1; } else { proposal.no_votes += 1; } move_to(account, Vote { proposal_id, in_favor }); } public fun execute_proposal(proposal_id: u64) acquires Proposal { let proposal = move_from<Proposal>(@voting_system); assert!(timestamp::now_seconds() >= proposal.end_time, 1); assert!(proposal.yes_votes > proposal.no_votes, 2); // Execute proposal logic here } }",
        "vulnerabilities": [
            "No weight-based voting (e.g., token-weighted)",
            "Lack of quorum requirement",
            "Missing vote delegation feature",
            "Vulnerable to last-minute voting swings",
            "No mechanism to cancel or update proposals"
        ]
    },
    
    {
        "code": "module SupplyChain { use std::signer; struct Product { id: u64, name: vector<u8>, manufacturer: address, current_owner: address, status: u8 } public fun create_product(account: &signer, id: u64, name: vector<u8>) { let product = Product { id, name, manufacturer: signer::address_of(account), current_owner: signer::address_of(account), status: 0 }; move_to(account, product); } public fun transfer_ownership(account: &signer, product_id: u64, new_owner: address) acquires Product { let product = borrow_global_mut<Product>(signer::address_of(account)); assert!(product.id == product_id, 1); assert!(product.current_owner == signer::address_of(account), 2); product.current_owner = new_owner; } public fun update_status(account: &signer, product_id: u64, new_status: u8) acquires Product { let product = borrow_global_mut<Product>(signer::address_of(account)); assert!(product.id == product_id, 1); assert!(product.current_owner == signer::address_of(account), 2); product.status = new_status; } }",
        "vulnerabilities": [
            "Lack of access control for different supply chain roles",
            "Missing event emissions for tracking",
            "No mechanism to handle product recalls",
            "Absence of privacy for sensitive supply chain data",
            "Vulnerable to front-running in ownership transfers"
        ]
    },
    
    {
        "code": "module DecentralizedExchange { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> { reserve_x: u64, reserve_y: u64, lp_tokens: u64 } public fun create_pool<X, Y>(account: &signer) { move_to(account, LiquidityPool<X, Y> { reserve_x: 0, reserve_y: 0, lp_tokens: 0 }); } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex); coin::transfer<X>(account, @dex, amount_x); coin::transfer<Y>(account, @dex, amount_y); let lp_tokens = if (pool.lp_tokens == 0) { (amount_x * amount_y) as u64 } else { std::math::min((amount_x * pool.lp_tokens) / pool.reserve_x, (amount_y * pool.lp_tokens) / pool.reserve_y) }; pool.reserve_x += amount_x; pool.reserve_y += amount_y; pool.lp_tokens += lp_tokens; coin::mint<LPToken>(account, lp_tokens); } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex); let amount_out = (amount_in * 997 * pool.reserve_y) / (pool.reserve_x * 1000 + amount_in * 997); assert!(amount_out >= min_amount_out, 1); coin::transfer<X>(account, @dex, amount_in); coin::transfer<Y>(@dex, signer::address_of(account), amount_out); pool.reserve_x += amount_in; pool.reserve_y -= amount_out; } }",
        "vulnerabilities": [
            "Lack of oracle for price feeds",
            "Missing governance mechanism for protocol upgrades",
            "No protection against sandwich attacks",
            "Absence of time-weighted average price (TWAP)",
            "Vulnerable to manipulation in low liquidity pools"
        ]
    },
    
    {
        "code": "module LendingPlatform { use std::signer; use aptos_framework::coin; struct LendingPool<phantom T> { total_deposits: u64, total_borrows: u64, interest_rate: u64 } struct UserPosition<phantom T> { deposits: u64, borrows: u64 } public fun create_pool<T>(account: &signer) { move_to(account, LendingPool<T> { total_deposits: 0, total_borrows: 0, interest_rate: 500 }); } public fun deposit<T>(account: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<T>>(@lending_platform); coin::transfer<T>(account, @lending_platform, amount); pool.total_deposits += amount; if (!exists<UserPosition<T>>(signer::address_of(account))) { move_to(account, UserPosition<T> { deposits: 0, borrows: 0 }); } let position = borrow_global_mut<UserPosition<T>>(signer::address_of(account)); position.deposits += amount; } public fun borrow<T>(account: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<T>>(@lending_platform); assert!(pool.total_deposits - pool.total_borrows >= amount, 1); coin::transfer<T>(@lending_platform, signer::address_of(account), amount); pool.total_borrows += amount; let position = borrow_global_mut<UserPosition<T>>(signer::address_of(account)); position.borrows += amount; } public fun repay<T>(account: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<T>>(@lending_platform); coin::transfer<T>(account, @lending_platform, amount); pool.total_borrows -= amount; let position = borrow_global_mut<UserPosition<T>>(signer::address_of(account)); position.borrows -= amount; } }",
        "vulnerabilities": [
            "Lack of collateralization mechanism",
            "Missing liquidation process for undercollateralized positions",
            "No dynamic interest rate model",
            "Absence of borrow limits",
            "Vulnerable to flash loan attacks"
        ]
    },
    
    {
        "code": "module DAO { use std::signer; use aptos_framework::coin; struct Proposal { id: u64, description: vector<u8>, votes: u64, executed: bool, execution_time: u64 } struct MemberInfo { voting_power: u64 } public fun create_proposal(account: &signer, description: vector<u8>) { let proposal_id = get_next_proposal_id(); move_to(account, Proposal { id: proposal_id, description, votes: 0, executed: false, execution_time: 0 }); } public fun vote(account: &signer, proposal_id: u64) acquires Proposal, MemberInfo { let proposal = borrow_global_mut<Proposal>(@dao_address); let member_info = borrow_global<MemberInfo>(signer::address_of(account)); proposal.votes += member_info.voting_power; } public fun execute_proposal(account: &signer, proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@dao_address); assert!(!proposal.executed, 1); assert!(proposal.votes >= get_quorum(), 2); proposal.executed = true; proposal.execution_time = timestamp::now_seconds(); // Execute proposal logic here } public fun join_dao(account: &signer, stake_amount: u64) { coin::transfer<DAOToken>(account, @dao_address, stake_amount); move_to(account, MemberInfo { voting_power: stake_amount }); } }",
        "vulnerabilities": [
            "Lack of time lock for proposal execution",
            "Missing ragequit mechanism for members",
            "No support for quadratic voting",
            "Absence of proposal cancellation feature",
            "Vulnerable to governance attacks with large token acquisitions"
        ]
    },
    
    {
        "code": "module InsuranceProtocol { use std::signer; use aptos_framework::coin; struct Policy { id: u64, holder: address, premium: u64, coverage: u64, expiry: u64 } struct Claim { policy_id: u64, amount: u64, status: u8 } public fun create_policy(account: &signer, premium: u64, coverage: u64, duration: u64) { let policy_id = get_next_policy_id(); let expiry = timestamp::now_seconds() + duration; coin::transfer<InsuranceCoin>(account, @insurance_pool, premium); move_to(account, Policy { id: policy_id, holder: signer::address_of(account), premium, coverage, expiry }); } public fun file_claim(account: &signer, policy_id: u64, amount: u64) acquires Policy { let policy = borrow_global<Policy>(signer::address_of(account)); assert!(policy.id == policy_id, 1); assert!(timestamp::now_seconds() < policy.expiry, 2); assert!(amount <= policy.coverage, 3); move_to(account, Claim { policy_id, amount, status: 0 }); } public fun process_claim(account: &signer, claimer: address, policy_id: u64) acquires Claim { assert!(signer::address_of(account) == @insurance_admin, 1); let claim = borrow_global_mut<Claim>(claimer); assert!(claim.policy_id == policy_id, 2); claim.status = 1; // Approved coin::transfer<InsuranceCoin>(@insurance_pool, claimer, claim.amount); } }",
        "vulnerabilities": [
            "Centralized claim processing",
            "Lack of risk assessment for policy creation",
            "Missing mechanism for policy cancellation and refunds",
            "No support for partial claim payouts",
            "Vulnerable to flash loan attacks for creating and claiming policies"
        ]
    },
    {
        "code": "module FlashLoan { use std::signer; struct LoanPool has key { balance: u64 } public fun take_flash_loan(borrower: &signer, amount: u64) acquires LoanPool { let pool = borrow_global_mut<LoanPool>(@pool_address); assert!(pool.balance >= amount, 1); pool.balance = pool.balance - amount; } public fun repay_flash_loan(borrower: &signer, amount: u64, fee: u64) acquires LoanPool { let pool = borrow_global_mut<LoanPool>(@pool_address); pool.balance = pool.balance + amount + fee; } }",
        "vulnerabilities": [
            "No check for loan repayment in the same transaction",
            "Lack of access control for loan initiation",
            "Potential for reentrancy attacks"
        ]
    },
    {
        "code": "module DynamicNFT { use std::signer; struct NFT has key { id: u64, level: u64, experience: u64 } public fun mint_nft(creator: &signer) { let nft = NFT { id: get_next_id(), level: 1, experience: 0 }; move_to(creator, nft); } public fun gain_experience(owner: &signer, exp: u64) acquires NFT { let nft = borrow_global_mut<NFT>(signer::address_of(owner)); nft.experience = nft.experience + exp; if (nft.experience >= LEVEL_UP_THRESHOLD) { nft.level = nft.level + 1; nft.experience = nft.experience - LEVEL_UP_THRESHOLD; } } }",
        "vulnerabilities": [
            "No mechanism to prevent experience manipulation",
            "Lack of access control for experience gain",
            "Potential for integer overflow in experience calculation"
        ]
    },
    {
        "code": "module TimelockVault { use std::signer; struct LockedFunds has key { amount: u64, unlock_time: u64 } public fun lock_funds(user: &signer, amount: u64, lock_duration: u64) { let unlock_time = timestamp::now_seconds() + lock_duration; move_to(user, LockedFunds { amount, unlock_time }); } public fun withdraw(user: &signer) acquires LockedFunds { let locked_funds = move_from<LockedFunds>(signer::address_of(user)); assert!(timestamp::now_seconds() >= locked_funds.unlock_time, 1); } }",
        "vulnerabilities": [
            "No partial withdrawal mechanism",
            "Lack of emergency withdrawal feature",
            "No event emission for tracking lock/unlock actions"
        ]
    },
    {
        "code": "module DecentralizedExchange { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom X, phantom Y> { reserve_x: u64, reserve_y: u64, lp_token_supply: u64 } public fun add_liquidity<X, Y>(account: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex_address); let lp_tokens = (amount_x * pool.lp_token_supply) / pool.reserve_x; coin::transfer<X>(account, @dex_address, amount_x); coin::transfer<Y>(account, @dex_address, amount_y); pool.reserve_x += amount_x; pool.reserve_y += amount_y; pool.lp_token_supply += lp_tokens; coin::mint<LPToken<X, Y>>(lp_tokens, account); } public fun swap<X, Y>(account: &signer, amount_in: u64, min_amount_out: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@dex_address); let amount_out = (amount_in * 997 * pool.reserve_y) / (pool.reserve_x * 1000 + amount_in * 997); assert!(amount_out >= min_amount_out, 1); coin::transfer<X>(account, @dex_address, amount_in); coin::transfer<Y>(@dex_address, signer::address_of(account), amount_out); pool.reserve_x += amount_in; pool.reserve_y -= amount_out; } }",
        "vulnerabilities": [
            "Lack of slippage protection in liquidity provision",
            "No mechanism to prevent front-running attacks",
            "Vulnerable to price manipulation in low liquidity pools",
            "Missing access control for critical functions",
            "No support for flash loans or composability with other protocols"
        ]
    },
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; struct Listing { creator: address, token_id: u64, price: u64 } public fun list_nft(account: &signer, token_id: u64, price: u64) { let creator = signer::address_of(account); move_to(account, Listing { creator, token_id, price }); } public fun buy_nft(buyer: &signer, creator: address, token_id: u64) acquires Listing { let listing = move_from<Listing>(creator); assert!(listing.token_id == token_id, 1); coin::transfer<AptosCoin>(buyer, creator, listing.price); token::transfer_token(creator, buyer, token_id, 1); } public fun cancel_listing(account: &signer, token_id: u64) acquires Listing { let Listing { creator, token_id: _, price: _ } = move_from<Listing>(signer::address_of(account)); assert!(creator == signer::address_of(account), 1); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of escrow system for secure transactions",
            "Vulnerable to sniping attacks during auctions",
            "Missing checks for token ownership before listing",
            "No support for bundle sales or offers"
        ]
    },
    {
        "code": "module GovernanceDAO { use std::signer; use aptos_framework::coin; struct Proposal { id: u64, proposer: address, description: vector<u8>, votes_for: u64, votes_against: u64, status: u8, execution_time: u64 } struct Vote { proposal_id: u64, amount: u64 } public fun create_proposal(account: &signer, description: vector<u8>) { let proposal_id = get_next_proposal_id(); move_to(account, Proposal { id: proposal_id, proposer: signer::address_of(account), description, votes_for: 0, votes_against: 0, status: 0, execution_time: 0 }); } public fun vote(account: &signer, proposal_id: u64, amount: u64, support: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@dao_address); assert!(proposal.id == proposal_id, 1); if (support) { proposal.votes_for += amount; } else { proposal.votes_against += amount; } coin::transfer<GovernanceToken>(account, @dao_address, amount); move_to(account, Vote { proposal_id, amount }); } public fun execute_proposal(account: &signer, proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@dao_address); assert!(proposal.id == proposal_id, 1); assert!(proposal.votes_for > proposal.votes_against, 2); assert!(timestamp::now_seconds() >= proposal.execution_time, 3); // Execute proposal logic here proposal.status = 2; // Executed } }",
        "vulnerabilities": [
            "Centralized proposal execution",
            "No quorum requirement for proposal execution",
            "Lack of time-lock mechanism for proposal execution",
            "Vulnerable to whale manipulation in voting",
            "Missing support for delegate voting"
        ]
    },
    {
        "code": "module StablecoinProtocol { use std::signer; use aptos_framework::coin; struct CollateralVault { collateral_amount: u64, debt_amount: u64 } public fun deposit_collateral(account: &signer, amount: u64) acquires CollateralVault { let vault = borrow_global_mut<CollateralVault>(signer::address_of(account)); coin::transfer<CollateralCoin>(account, @protocol_reserve, amount); vault.collateral_amount += amount; } public fun borrow_stablecoin(account: &signer, amount: u64) acquires CollateralVault { let vault = borrow_global_mut<CollateralVault>(signer::address_of(account)); let max_borrow = (vault.collateral_amount * get_collateral_ratio()) / 100; assert!(vault.debt_amount + amount <= max_borrow, 1); vault.debt_amount += amount; coin::mint<Stablecoin>(amount, account); } public fun repay_debt(account: &signer, amount: u64) acquires CollateralVault { let vault = borrow_global_mut<CollateralVault>(signer::address_of(account)); assert!(amount <= vault.debt_amount, 1); vault.debt_amount -= amount; coin::burn<Stablecoin>(amount, account); } public fun withdraw_collateral(account: &signer, amount: u64) acquires CollateralVault { let vault = borrow_global_mut<CollateralVault>(signer::address_of(account)); let remaining_collateral = vault.collateral_amount - amount; let max_borrow = (remaining_collateral * get_collateral_ratio()) / 100; assert!(vault.debt_amount <= max_borrow, 1); vault.collateral_amount -= amount; coin::transfer<CollateralCoin>(@protocol_reserve, signer::address_of(account), amount); } }",
        "vulnerabilities": [
            "Lack of liquidation mechanism for undercollateralized positions",
            "No interest rate model for borrowing",
            "Vulnerable to oracle manipulation for collateral pricing",
            "Missing emergency shutdown mechanism",
            "No support for multiple collateral types"
        ]
    },
    {
        "code": "module PredictionMarket { use std::signer; use aptos_framework::coin; struct Market { id: u64, creator: address, description: vector<u8>, resolution_time: u64, outcome: bool, total_yes_stake: u64, total_no_stake: u64 } struct Position { market_id: u64, stake: u64, prediction: bool } public fun create_market(account: &signer, description: vector<u8>, resolution_time: u64) { let market_id = get_next_market_id(); move_to(account, Market { id: market_id, creator: signer::address_of(account), description, resolution_time, outcome: false, total_yes_stake: 0, total_no_stake: 0 }); } public fun place_bet(account: &signer, market_id: u64, amount: u64, prediction: bool) acquires Market { let market = borrow_global_mut<Market>(@prediction_market_address); assert!(market.id == market_id, 1); assert!(timestamp::now_seconds() < market.resolution_time, 2); coin::transfer<BettingToken>(account, @prediction_market_address, amount); if (prediction) { market.total_yes_stake += amount; } else { market.total_no_stake += amount; } move_to(account, Position { market_id, stake: amount, prediction }); } public fun resolve_market(account: &signer, market_id: u64, outcome: bool) acquires Market { let market = borrow_global_mut<Market>(@prediction_market_address); assert!(signer::address_of(account) == market.creator, 1); assert!(timestamp::now_seconds() >= market.resolution_time, 2); market.outcome = outcome; } public fun claim_winnings(account: &signer, market_id: u64) acquires Market, Position { let market = borrow_global<Market>(@prediction_market_address); let position = move_from<Position>(signer::address_of(account)); assert!(position.market_id == market_id, 1); assert!(position.prediction == market.outcome, 2); let total_stake = market.total_yes_stake + market.total_no_stake; let winnings = (position.stake * total_stake) / if (market.outcome) { market.total_yes_stake } else { market.total_no_stake }; coin::transfer<BettingToken>(@prediction_market_address, signer::address_of(account), winnings); } }",
        "vulnerabilities": [
            "Centralized market resolution",
            "No mechanism for disputing market outcomes",
            "Vulnerable to last-minute betting attacks",
            "Lack of partial claim mechanism for winnings",
            "Missing support for multi-outcome markets"
        ]
    },
    {
        "code": "module LendingProtocol { use std::signer; use aptos_framework::coin; struct LendingPool<phantom CoinType> { total_deposits: u64, total_borrows: u64, interest_rate: u64 } struct UserPosition<phantom CoinType> { deposited: u64, borrowed: u64 } public fun deposit<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_protocol); let position = borrow_global_mut<UserPosition<CoinType>>(signer::address_of(account)); coin::transfer<CoinType>(account, @lending_protocol, amount); pool.total_deposits += amount; position.deposited += amount; } public fun borrow<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_protocol); let position = borrow_global_mut<UserPosition<CoinType>>(signer::address_of(account)); assert!(amount <= (position.deposited * 75) / 100, 1); // 75% LTV coin::transfer<CoinType>(@lending_protocol, signer::address_of(account), amount); pool.total_borrows += amount; position.borrowed += amount; } public fun repay<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_protocol); let position = borrow_global_mut<UserPosition<CoinType>>(signer::address_of(account)); assert!(amount <= position.borrowed, 1); coin::transfer<CoinType>(account, @lending_protocol, amount); pool.total_borrows -= amount; position.borrowed -= amount; } public fun withdraw<CoinType>(account: &signer, amount: u64) acquires LendingPool, UserPosition { let pool = borrow_global_mut<LendingPool<CoinType>>(@lending_protocol); let position = borrow_global_mut<UserPosition<CoinType>>(signer::address_of(account)); assert!(amount <= position.deposited, 1); assert!((position.deposited - amount) * 75 / 100 >= position.borrowed, 2); // Maintain 75% LTV coin::transfer<CoinType>(@lending_protocol, signer::address_of(account), amount); pool.total_deposits -= amount; position.deposited -= amount; } }",
        "vulnerabilities": [
            "Lack of dynamic interest rate model",
            "No liquidation mechanism for undercollateralized positions",
            "Vulnerable to flash loan attacks",
            "Missing support for multiple collateral types",
            "No consideration for accumulated interest in user positions"
        ]
    },
    {
        "code": "module CrossChainBridge { use std::signer; use aptos_framework::coin; struct BridgeRequest { id: u64, user: address, amount: u64, target_chain: u64, status: u8 } public fun initiate_transfer(account: &signer, amount: u64, target_chain: u64) { let request_id = get_next_request_id(); coin::transfer<BridgeToken>(account, @bridge_reserve, amount); move_to(account, BridgeRequest { id: request_id, user: signer::address_of(account), amount, target_chain, status: 0 }); // Emit event for off-chain relayers } public fun confirm_transfer(validator: &signer, request_id: u64) acquires BridgeRequest { assert!(is_validator(signer::address_of(validator)), 1); let request = borrow_global_mut<BridgeRequest>(@bridge_address); assert!(request.id == request_id, 2); assert!(request.status == 0, 3); request.status = 1; // Confirmed // Emit confirmation event } public fun execute_transfer(validator: &signer, request_id: u64) acquires BridgeRequest { assert!(is_validator(signer::address_of(validator)), 1); let request = move_from<BridgeRequest>(@bridge_address); assert!(request.id == request_id, 2); assert!(request.status == 1, 3); // Logic to mint or release tokens on target chain // Emit execution event } }",
        "vulnerabilities": [
            "Centralized validation of cross-chain transfers",
            "Lack of multi-signature requirement for validators",
            "No mechanism for handling failed transfers",
            "Vulnerable to replay attacks across different chains",
            "Missing support for fee collection and distribution to validators"
        ]
    },
    {
        "code": "module MultiSigWallet { use std::signer; struct MultiSig has key { owners: vector<address>, required_confirmations: u64 } struct Transaction has key { id: u64, confirmations: u64, executed: bool } public fun create_transaction(creator: &signer, tx_id: u64) acquires MultiSig { let multisig = borrow_global<MultiSig>(@wallet_address); assert!(vector::contains(&multisig.owners, &signer::address_of(creator)), 1); move_to(creator, Transaction { id: tx_id, confirmations: 1, executed: false }); } public fun confirm_transaction(owner: &signer, tx_id: u64) acquires MultiSig, Transaction { let multisig = borrow_global<MultiSig>(@wallet_address); let tx = borrow_global_mut<Transaction>(@tx_address); assert!(vector::contains(&multisig.owners, &signer::address_of(owner)), 1); tx.confirmations = tx.confirmations + 1; if (tx.confirmations >= multisig.required_confirmations) { tx.executed = true; } } }",
        "vulnerabilities": [
            "No mechanism to remove or change owners",
            "Lack of transaction expiration",
            "Potential for double confirmation by the same owner"
        ]
    },
    {
        "code": "module LinearVesting { use std::signer; struct VestingSchedule has key { total_amount: u64, start_time: u64, end_time: u64, claimed_amount: u64 } public fun create_vesting(admin: &signer, recipient: address, total_amount: u64, vesting_duration: u64) { let start_time = timestamp::now_seconds(); let end_time = start_time + vesting_duration; move_to(recipient, VestingSchedule { total_amount, start_time, end_time, claimed_amount: 0 }); } public fun claim(recipient: &signer) acquires VestingSchedule { let vesting = borrow_global_mut<VestingSchedule>(signer::address_of(recipient)); let current_time = timestamp::now_seconds(); let vested_amount = (vesting.total_amount * (current_time - vesting.start_time)) / (vesting.end_time - vesting.start_time); let claimable = vested_amount - vesting.claimed_amount; vesting.claimed_amount = vesting.claimed_amount + claimable; } }",
        "vulnerabilities": [
            "No mechanism to handle token price fluctuations",
            "Lack of emergency withdrawal or pause functionality",
            "Potential for precision loss in vested amount calculation"
        ]
    },
    {
        "code": "module RandomizedLottery { use std::signer; struct LotteryPool has key { tickets: vector<address>, prize: u64 } public fun buy_ticket(player: &signer) acquires LotteryPool { let pool = borrow_global_mut<LotteryPool>(@lottery_address); vector::push_back(&mut pool.tickets, signer::address_of(player)); } public fun draw_winner(admin: &signer) acquires LotteryPool { let pool = borrow_global_mut<LotteryPool>(@lottery_address); let winner_index = pseudorandom::rand_u64() % vector::length(&pool.tickets); let winner = *vector::borrow(&pool.tickets, winner_index); } }",
        "vulnerabilities": [
            "Centralized randomness source",
            "No mechanism to ensure fairness in ticket distribution",
            "Lack of time-bound lottery periods"
        ]
    },
    {
        "code": "module RecurringPayment { use std::signer; struct Subscription has key { recipient: address, amount: u64, interval: u64, last_payment: u64 } public fun create_subscription(payer: &signer, recipient: address, amount: u64, interval: u64) { move_to(payer, Subscription { recipient, amount, interval, last_payment: timestamp::now_seconds() }); } public fun process_payment(payer: &signer) acquires Subscription { let sub = borrow_global_mut<Subscription>(signer::address_of(payer)); let current_time = timestamp::now_seconds(); if (current_time >= sub.last_payment + sub.interval) { sub.last_payment = current_time; } } }",
        "vulnerabilities": [
            "No mechanism to handle insufficient funds",
            "Lack of subscription cancellation feature",
            "Potential for missed payments if not called regularly"
        ]
    },
    {
        "code": "module DAO { use std::signer; struct Proposal has key { id: u64, description: vector<u8>, yes_votes: u64, no_votes: u64, end_time: u64 } struct MemberInfo has key { voting_power: u64 } public fun create_proposal(creator: &signer, description: vector<u8>, voting_period: u64) { let proposal = Proposal { id: get_next_id(), description, yes_votes: 0, no_votes: 0, end_time: timestamp::now_seconds() + voting_period }; move_to(creator, proposal); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal, MemberInfo { let proposal = borrow_global_mut<Proposal>(@proposal_address); let member_info = borrow_global<MemberInfo>(signer::address_of(voter)); if (vote) { proposal.yes_votes = proposal.yes_votes + member_info.voting_power; } else { proposal.no_votes = proposal.no_votes + member_info.voting_power; } } }",
        "vulnerabilities": [
            "No quorum requirement for proposal execution",
            "Lack of proposal execution mechanism",
            "Potential for vote buying or delegation abuse"
        ]
    },
    {
        "code": "module Oracle { use std::signer; struct PriceData has key { asset: vector<u8>, price: u64, timestamp: u64 } public fun update_price(oracle: &signer, asset: vector<u8>, price: u64) acquires PriceData { let price_data = borrow_global_mut<PriceData>(@oracle_address); price_data.asset = asset; price_data.price = price; price_data.timestamp = timestamp::now_seconds(); } public fun get_price(asset: vector<u8>): (u64, u64) acquires PriceData { let price_data = borrow_global<PriceData>(@oracle_address); (price_data.price, price_data.timestamp) } }",
        "vulnerabilities": [
            "Single point of failure with one oracle",
            "No mechanism to prevent price manipulation",
            "Lack of staleness check for price data"
        ]
    },
    {
        "code": "module LiquidationEngine { use std::signer; struct LoanPosition has key { collateral: u64, debt: u64 } public fun liquidate(liquidator: &signer, borrower: address) acquires LoanPosition { let position = borrow_global_mut<LoanPosition>(borrower); let oracle_price = get_oracle_price(); if (position.debt > position.collateral * oracle_price * LIQUIDATION_THRESHOLD) { let liquidation_amount = min(position.debt, position.collateral * oracle_price); position.collateral = position.collateral - liquidation_amount / oracle_price; position.debt = position.debt - liquidation_amount; } } }",
        "vulnerabilities": [
            "No incentive mechanism for liquidators",
            "Lack of partial liquidation options",
            "Potential for oracle price manipulation"
        ]
    },
    {
        "code": "module SimpleDAO { use std::signer; struct Member has key { voting_power: u64 } struct Proposal has key { id: u64, description: vector<u8>, yes_votes: u64, no_votes: u64, executed: bool } public fun join_dao(new_member: &signer, initial_voting_power: u64) { move_to(new_member, Member { voting_power: initial_voting_power }); } public fun create_proposal(creator: &signer, description: vector<u8>) { // Create and store proposal } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Member, Proposal { let member = borrow_global<Member>(signer::address_of(voter)); let proposal = borrow_global_mut<Proposal>(@dao_address); if (vote) { proposal.yes_votes = proposal.yes_votes + member.voting_power; } else { proposal.no_votes = proposal.no_votes + member.voting_power; } } }",
        "vulnerabilities": [
            "No mechanism to prevent double voting",
            "Lack of proposal execution logic"
        ]
    },
    {
        "code": "module TokenStaking { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakeInfo has key { amount: u64, start_time: u64, } public fun stake<CoinType>(account: &signer, amount: u64) { let sender = signer::address_of(account); assert!(!exists<StakeInfo>(sender), 1); move_to(account, StakeInfo { amount, start_time: timestamp::now_seconds(), }); coin::transfer<CoinType>(account, @staking_pool, amount); } public fun unstake<CoinType>(account: &signer) acquires StakeInfo { let sender = signer::address_of(account); let stake_info = move_from<StakeInfo>(sender); let reward = calculate_reward(stake_info.amount, stake_info.start_time); coin::transfer<CoinType>(@staking_pool, sender, stake_info.amount + reward); } fun calculate_reward(amount: u64, start_time: u64): u64 { let duration = timestamp::now_seconds() - start_time; (amount * duration) / 100 } }",
        "vulnerabilities": [
            "No slashing mechanism for early unstaking",
            "Lack of access control for stake and unstake functions",
            "Potential integer overflow in reward calculation",
            "No checks for contract balance before transfers",
            "Missing event emissions for staking and unstaking",
            "Centralized control of the staking pool",
            "No mechanism to update reward calculation",
            "Lack of maximum stake limit",
            "No minimum staking duration enforced",
            "Potential for flash loan attacks"
        ]
    },
    {
        "code": "module SimpleDAO { use std::signer; use aptos_framework::coin; struct Proposal has key { id: u64, votes: u64, executed: bool, } public fun create_proposal(creator: &signer, id: u64) { move_to(creator, Proposal { id, votes: 0, executed: false }); } public fun vote(voter: &signer, proposal_address: address) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); proposal.votes += 1; } public fun execute_proposal(executor: &signer, proposal_address: address) acquires Proposal { let proposal = borrow_global_mut<Proposal>(proposal_address); assert!(!proposal.executed, 1); assert!(proposal.votes > 10, 2); proposal.executed = true; } }",
        "vulnerabilities": [
            "No access control for creating proposals",
            "Single vote per address not enforced",
            "No time limit for voting",
            "Lack of proposal details storage",
            "No event emissions for voting or execution",
            "No mechanism to cancel or update proposals",
            "Fixed threshold for proposal execution",
            "No checks for executor's permissions",
            "Potential for duplicate proposal IDs",
            "Missing vote weight consideration"
        ]
    },
    
    {
        "code": "module NFTMarketplace { use std::signer; use aptos_framework::coin; use aptos_framework::token; struct Listing has key { creator: address, price: u64, } public fun list_nft(seller: &signer, token_id: token::TokenId, price: u64) { let seller_addr = signer::address_of(seller); token::transfer(seller, @nft_vault, token_id); move_to(seller, Listing { creator: seller_addr, price }); } public fun buy_nft<CoinType>(buyer: &signer, token_id: token::TokenId) acquires Listing { let listing = move_from<Listing>(token::creator(token_id)); coin::transfer<CoinType>(buyer, listing.creator, listing.price); token::transfer(@nft_vault, signer::address_of(buyer), token_id); } }",
        "vulnerabilities": [
            "No royalty mechanism for original creators",
            "Lack of price validation",
            "No mechanism to update or cancel listings",
            "Missing checks for token ownership before listing",
            "Potential for front-running attacks",
            "No event emissions for listing and buying",
            "Centralized control of the NFT vault",
            "No support for auction-style sales",
            "Missing checks for sufficient buyer balance",
            "Lack of access control for buying function"
        ]
    },
    {
        "code": "module FlashLoan { use std::signer; use aptos_framework::coin; struct LoanInfo has key { amount: u64, fee: u64, } public fun request_loan<CoinType>(borrower: &signer, amount: u64) { let fee = amount / 100; move_to(borrower, LoanInfo { amount, fee }); coin::transfer<CoinType>(@loan_pool, signer::address_of(borrower), amount); } public fun repay_loan<CoinType>(borrower: &signer) acquires LoanInfo { let loan_info = move_from<LoanInfo>(signer::address_of(borrower)); coin::transfer<CoinType>(borrower, @loan_pool, loan_info.amount + loan_info.fee); } }",
        "vulnerabilities": [
            "No checks for contract balance before loan",
            "Lack of access control for loan functions",
            "Missing checks for existing loans",
            "No time limit for loan repayment",
            "Potential for reentrancy attacks",
            "Fixed fee structure",
            "No event emissions for loan activities",
            "Missing checks for minimum loan amount",
            "Lack of borrower credit assessment",
            "No mechanism to handle defaulted loans"
        ]
    },
    
    {
        "code": "module SimpleAMM { use std::signer; use aptos_framework::coin; struct LiquidityPool<X, Y> has key { reserve_x: u64, reserve_y: u64, } public fun add_liquidity<X, Y>(provider: &signer, amount_x: u64, amount_y: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@amm_address); pool.reserve_x += amount_x; pool.reserve_y += amount_y; coin::transfer<X>(provider, @amm_address, amount_x); coin::transfer<Y>(provider, @amm_address, amount_y); } public fun swap<X, Y>(user: &signer, amount_in: u64) acquires LiquidityPool { let pool = borrow_global_mut<LiquidityPool<X, Y>>(@amm_address); let amount_out = (amount_in * pool.reserve_y) / (pool.reserve_x + amount_in); pool.reserve_x += amount_in; pool.reserve_y -= amount_out; coin::transfer<X>(user, @amm_address, amount_in); coin::transfer<Y>(@amm_address, signer::address_of(user), amount_out); } }",
        "vulnerabilities": [
            "No slippage protection for swaps",
            "Lack of access control for liquidity functions",
            "Potential for price manipulation",
            "Missing checks for minimum liquidity",
            "No mechanism to remove liquidity",
            "Centralized control of the AMM",
            "No event emissions for swaps and liquidity changes",
            "Potential integer overflow in swap calculations",
            "Missing checks for zero amounts",
            "Lack of fee mechanism for liquidity providers"
        ]
    },
    
    {
        "code": "module SimpleLottery { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct LotteryInfo has key { ticket_price: u64, end_time: u64, winner: address, } public fun create_lottery(creator: &signer, ticket_price: u64, duration: u64) { move_to(creator, LotteryInfo { ticket_price, end_time: timestamp::now_seconds() + duration, winner: @0x0, }); } public fun buy_ticket<CoinType>(buyer: &signer) acquires LotteryInfo { let lottery_info = borrow_global_mut<LotteryInfo>(@lottery_address); assert!(timestamp::now_seconds() < lottery_info.end_time, 1); coin::transfer<CoinType>(buyer, @lottery_address, lottery_info.ticket_price); } public fun draw_winner(drawer: &signer) acquires LotteryInfo { let lottery_info = borrow_global_mut<LotteryInfo>(@lottery_address); assert!(timestamp::now_seconds() >= lottery_info.end_time, 1); lottery_info.winner = @random_address; } }",
        "vulnerabilities": [
            "Centralized winner selection",
            "Lack of randomness in winner selection",
            "No mechanism to distribute prize",
            "Missing checks for minimum participants",
            "Potential for admin to manipulate end time",
            "No event emissions for ticket purchases",
            "Lack of access control for draw function",
            "No refund mechanism if lottery fails",
            "Missing maximum ticket limit per address",
            "Potential for front-running last ticket purchase"
        ]
    },
    
    {
        "code": "module SimpleGovernance { use std::signer; use aptos_framework::coin; struct Proposal has key { id: u64, yes_votes: u64, no_votes: u64, end_time: u64, executed: bool, } public fun create_proposal(creator: &signer, id: u64, duration: u64) { move_to(creator, Proposal { id, yes_votes: 0, no_votes: 0, end_time: timestamp::now_seconds() + duration, executed: false }); } public fun vote(voter: &signer, proposal_id: u64, vote: bool) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@governance_address); if (vote) { proposal.yes_votes += 1; } else { proposal.no_votes += 1; } } public fun execute_proposal(executor: &signer, proposal_id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@governance_address); assert!(!proposal.executed && timestamp::now_seconds() >= proposal.end_time, 1); assert!(proposal.yes_votes > proposal.no_votes, 2); proposal.executed = true; } }",
        "vulnerabilities": [
            "No quorum requirement for proposal execution",
            "Lack of token-weighted voting",
            "Missing access control for proposal creation",
            "No mechanism to cancel or update proposals",
            "Potential for duplicate proposal IDs",
            "Lack of minimum voting period",
            "No event emissions for voting activities",
            "Missing checks for voter eligibility",
            "Centralized proposal execution",
            "No time lock for executed proposals"
        ]
    },
    
    {
        "code": "module SimpleBridge { use std::signer; use aptos_framework::coin; struct BridgeRequest has key { amount: u64, target_chain: u64, completed: bool, } public fun initiate_transfer<CoinType>(sender: &signer, amount: u64, target_chain: u64) { let sender_addr = signer::address_of(sender); coin::transfer<CoinType>(sender, @bridge_vault, amount); move_to(sender, BridgeRequest { amount, target_chain, completed: false }); } public fun complete_transfer(operator: &signer, recipient: address) acquires BridgeRequest { let request = move_from<BridgeRequest>(recipient); assert!(!request.completed, 1); coin::transfer<CoinType>(@bridge_vault, recipient, request.amount); } }",
        "vulnerabilities": [
            "Lack of cross-chain verification",
            "Centralized bridge operator",
            "No mechanism to cancel transfers",
            "Missing checks for minimum transfer amount",
            "Potential for duplicate transfer completions",
            "No event emissions for transfer activities",
            "Lack of access control for completion function",
            "Missing time lock for large transfers",
            "No mechanism to pause the bridge",
            "Potential for fund lock if recipient address is invalid"
        ]
    },
    
    {
        "code": "module SimpleInsurance { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Policy has key { premium: u64, coverage: u64, expiry: u64, } public fun create_policy(insurer: &signer, premium: u64, coverage: u64, duration: u64) { move_to(insurer, Policy { premium, coverage, expiry: timestamp::now_seconds() + duration }); } public fun pay_premium<CoinType>(policyholder: &signer) acquires Policy { let policy = borrow_global_mut<Policy>(@insurance_address); coin::transfer<CoinType>(policyholder, @insurance_pool, policy.premium); policy.expiry += 30 * 24 * 60 * 60; } public fun claim(claimer: &signer) acquires Policy { let policy = borrow_global<Policy>(@insurance_address); assert!(timestamp::now_seconds() < policy.expiry, 1); coin::transfer<CoinType>(@insurance_pool, signer::address_of(claimer), policy.coverage); } }",
        "vulnerabilities": [
            "No verification of claim validity",
            "Lack of access control for claim function",
            "Missing checks for sufficient pool balance",
            "Potential for multiple claims on single policy",
            "No mechanism to adjust premium or coverage",
            "Centralized control of insurance pool",
            "No event emissions for policy activities",
            "Missing maximum coverage limit",
            "Lack of waiting period for new policies",
            "No mechanism to cancel or transfer policies"
        ]
    },
    {
        "code": "module SimpleDerivative { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Contract has key { long: address, short: address, amount: u64, settlement_price: u64, expiry: u64, } public fun create_contract(creator: &signer, counterparty: address, amount: u64, duration: u64) { move_to(creator, Contract { long: signer::address_of(creator), short: counterparty, amount, settlement_price: 0, expiry: timestamp::now_seconds() + duration }); } public fun settle_contract(settler: &signer, settlement_price: u64) acquires Contract { let contract = borrow_global_mut<Contract>(@contract_address); assert!(timestamp::now_seconds() >= contract.expiry, 1); contract.settlement_price = settlement_price; let payout = if (settlement_price > 100) { contract.amount } else { 0 }; coin::transfer<CoinType>(@contract_vault, contract.long, payout); coin::transfer<CoinType>(@contract_vault, contract.short, contract.amount - payout); } }",
        "vulnerabilities": [
            "Centralized price settlement",
            "Lack of collateral mechanism",
            "No checks for contract creation permissions",
            "Missing functionality for early settlement",
            "Potential for settlement price manipulation",
            "No event emissions for contract activities",
            "Lack of access control for settlement function",
            "Missing checks for minimum contract amount",
            "No mechanism to handle disputes",
            "Potential for fund lock if settlement fails"
        ]
    },
    {
        "code": "module SimpleOTC { use std::signer; use aptos_framework::coin; struct Trade has key { maker: address, taker: address, amount_give: u64, amount_get: u64, token_give: address, token_get: address, } public fun create_trade(maker: &signer, amount_give: u64, amount_get: u64, token_give: address, token_get: address) { move_to(maker, Trade { maker: signer::address_of(maker), taker: @0x0, amount_give, amount_get, token_give, token_get }); } public fun accept_trade(taker: &signer, maker: address) acquires Trade { let trade = move_from<Trade>(maker); coin::transfer<CoinType1>(taker, trade.maker, trade.amount_get); coin::transfer<CoinType2>(@trade_escrow, signer::address_of(taker), trade.amount_give); } }",
        "vulnerabilities": [
            "No mechanism to cancel or update trades",
            "Lack of escrow for maker's funds",
            "Missing checks for token compatibility",
            "Potential for front-running trade acceptance",
            "No event emissions for trade activities",
            "Lack of access control for trade acceptance",
            "Missing checks for sufficient balances",
            "No time limit for trade execution",
            "Potential for price manipulation",
            "Missing partial fill functionality"
        ]
    },
    {
        "code": "module SimpleToken { use std::signer; use aptos_framework::coin; struct TokenInfo has key { total_supply: u64, } public fun initialize(account: &signer) { move_to(account, TokenInfo { total_supply: 0 }); } public fun mint(account: &signer, amount: u64) acquires TokenInfo { let sender = signer::address_of(account); let token_info = borrow_global_mut<TokenInfo>(sender); token_info.total_supply = token_info.total_supply + amount; coin::register<TokenInfo>(account); coin::deposit(sender, coin::mint<TokenInfo>(amount, &TokenInfo {})); } public fun burn(account: &signer, amount: u64) acquires TokenInfo { let sender = signer::address_of(account); let token_info = borrow_global_mut<TokenInfo>(sender); assert!(token_info.total_supply >= amount, 1); token_info.total_supply = token_info.total_supply - amount; let to_burn = coin::withdraw<TokenInfo>(account, amount); coin::burn<TokenInfo>(to_burn, &TokenInfo {}); } public fun transfer(from: &signer, to: address, amount: u64) { coin::transfer<TokenInfo>(from, to, amount); } }",
        "vulnerabilities": [
            "Lack of access control for minting",
            "No decimal places consideration",
            "Missing event emissions",
            "Potential integer overflow in total_supply",
            "No checks for zero address in transfer"
        ]
    },
    {
        "code": "module SimpleNFT { use std::string; use std::vector; use aptos_framework::account; use aptos_framework::event; struct NFT has store, drop { id: u64, name: string::String, description: string::String, } struct NFTCollection has key { nfts: vector<NFT>, mint_events: event::EventHandle<MintEvent>, } struct MintEvent has drop, store { id: u64, recipient: address, } public fun initialize_collection(account: &signer) { move_to(account, NFTCollection { nfts: vector::empty(), mint_events: account::new_event_handle<MintEvent>(account), }); } public fun mint_nft(account: &signer, name: string::String, description: string::String) acquires NFTCollection { let sender = signer::address_of(account); let collection = borrow_global_mut<NFTCollection>(sender); let id = vector::length(&collection.nfts); let nft = NFT { id, name, description }; vector::push_back(&mut collection.nfts, nft); event::emit_event(&mut collection.mint_events, MintEvent { id, recipient: sender }); } }",
        "vulnerabilities": [
            "No access control for minting",
            "Lack of transfer functionality",
            "No uniqueness check for NFT IDs",
            "Missing burn functionality",
            "No metadata standard adherence"
        ]
    },
    {
        "code": "module SimpleAuction { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct Auction<phantom CoinType> has key { seller: address, highest_bidder: address, highest_bid: u64, end_time: u64, } public fun create_auction<CoinType>(account: &signer, duration: u64) { let sender = signer::address_of(account); move_to(account, Auction<CoinType> { seller: sender, highest_bidder: sender, highest_bid: 0, end_time: timestamp::now_seconds() + duration, }); } public fun place_bid<CoinType>(account: &signer, amount: u64) acquires Auction { let sender = signer::address_of(account); let auction = borrow_global_mut<Auction<CoinType>>(sender); assert!(timestamp::now_seconds() < auction.end_time, 1); assert!(amount > auction.highest_bid, 2); if (auction.highest_bid > 0) { coin::transfer<CoinType>(account, auction.highest_bidder, auction.highest_bid); } auction.highest_bidder = sender; auction.highest_bid = amount; coin::transfer<CoinType>(account, auction.seller, amount); } public fun end_auction<CoinType>(account: &signer) acquires Auction { let sender = signer::address_of(account); let auction = borrow_global<Auction<CoinType>>(sender); assert!(timestamp::now_seconds() >= auction.end_time, 3); if (auction.highest_bid > 0) { coin::transfer<CoinType>(account, auction.highest_bidder, 1); // Transfer NFT or item } } }",
        "vulnerabilities": [
            "Lack of access control for ending auction",
            "No refund mechanism for outbid participants",
            "Missing event emissions",
            "Centralization risk with single auction",
            "No minimum bid increment"
        ]
    },
    {
        "code": "module SimpleDAO { use std::signer; use aptos_framework::coin; use aptos_framework::voting; struct Proposal has store, drop { id: u64, description: vector<u8>, vote_start_time: u64, vote_end_time: u64, } struct DAO has key { proposals: vector<Proposal>, next_proposal_id: u64, } public fun initialize(account: &signer) { move_to(account, DAO { proposals: vector::empty(), next_proposal_id: 0, }); } public fun create_proposal(account: &signer, description: vector<u8>, vote_duration: u64) acquires DAO { let sender = signer::address_of(account); let dao = borrow_global_mut<DAO>(sender); let proposal = Proposal { id: dao.next_proposal_id, description, vote_start_time: timestamp::now_seconds(), vote_end_time: timestamp::now_seconds() + vote_duration, }; vector::push_back(&mut dao.proposals, proposal); dao.next_proposal_id = dao.next_proposal_id + 1; } public fun vote(account: &signer, proposal_id: u64, approve: bool) acquires DAO { let sender = signer::address_of(account); let dao = borrow_global<DAO>(sender); let proposal = vector::borrow(&dao.proposals, proposal_id); assert!(timestamp::now_seconds() >= proposal.vote_start_time && timestamp::now_seconds() <= proposal.vote_end_time, 1); voting::vote<DAO>(account, sender, proposal_id, approve); } }",
        "vulnerabilities": [
            "No quorum or minimum participation requirements",
            "Lack of access control for proposal creation",
            "Missing event emissions for proposals and votes",
            "No mechanism to execute approved proposals",
            "Potential for proposal spam"
        ]
    },
    {
        "code": "module SimpleStaking { use std::signer; use aptos_framework::coin; use aptos_framework::timestamp; struct StakeInfo has key { amount: u64, start_time: u64, } public fun stake(account: &signer, amount: u64) acquires StakeInfo { let sender = signer::address_of(account); if (!exists<StakeInfo>(sender)) { move_to(account, StakeInfo { amount: 0, start_time: timestamp::now_seconds(), }); } let stake_info = borrow_global_mut<StakeInfo>(sender); stake_info.amount = stake_info.amount + amount; coin::transfer<AptosCoin>(account, @staking_pool, amount); } public fun unstake(account: &signer, amount: u64) acquires StakeInfo { let sender = signer::address_of(account); let stake_info = borrow_global_mut<StakeInfo>(sender); assert!(stake_info.amount >= amount, 1); stake_info.amount = stake_info.amount - amount; coin::transfer<AptosCoin>(@staking_pool, sender, amount); } public fun claim_rewards(account: &signer) acquires StakeInfo { let sender = signer::address_of(account); let stake_info = borrow_global<StakeInfo>(sender); let duration = timestamp::now_seconds() - stake_info.start_time; let reward = (stake_info.amount * duration) / 1000000; // Simple reward calculation coin::transfer<AptosCoin>(@reward_pool, sender, reward); } }",
        "vulnerabilities": [
            "Simplistic reward calculation not considering total stake",
            "No slashing mechanism",
            "Lack of access control for reward distribution",
            "Missing event emissions for stake/unstake",
            "No minimum staking period"
        ]
    },
    {
        "code": "module SimpleAMM { use std::signer; use aptos_framework::coin; struct LiquidityPool<phantom CoinTypeA, phantom CoinTypeB> has key { reserve_a: u64, reserve_b: u64, } public fun initialize<CoinTypeA, CoinTypeB>(account: &signer) { move_to(account, LiquidityPool<CoinTypeA, CoinTypeB> { reserve_a: 0, reserve_b: 0 }); } public fun add_liquidity<CoinTypeA, CoinTypeB>(account: &signer, amount_a: u64, amount_b: u64) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(sender); pool.reserve_a = pool.reserve_a + amount_a; pool.reserve_b = pool.reserve_b + amount_b; coin::transfer<CoinTypeA>(account, sender, amount_a); coin::transfer<CoinTypeB>(account, sender, amount_b); } public fun swap<CoinTypeA, CoinTypeB>(account: &signer, amount_in: u64, is_a_to_b: bool) acquires LiquidityPool { let sender = signer::address_of(account); let pool = borrow_global_mut<LiquidityPool<CoinTypeA, CoinTypeB>>(sender); let (reserve_in, reserve_out) = if (is_a_to_b) (pool.reserve_a, pool.reserve_b) else (pool.reserve_b, pool.reserve_a); let amount_out = (amount_in * reserve_out) / (reserve_in + amount_in); if (is_a_to_b) { pool.reserve_a = pool.reserve_a + amount_in; pool.reserve_b = pool.reserve_b - amount_out; coin::transfer<CoinTypeA>(account, sender, amount_in); coin::transfer<CoinTypeB>(sender, account, amount_out); } else { pool.reserve_b = pool.reserve_b + amount_in; pool.reserve_a = pool.reserve_a - amount_out; coin::transfer<CoinTypeB>(account, sender, amount_in); coin::transfer<CoinTypeA>(sender, account, amount_out); } } }",
        "vulnerabilities": [
            "No slippage protection",
            "Lack of access control for liquidity provision",
            "Missing event emissions for swaps and liquidity changes",
            "Potential for price manipulation with small liquidity",
            "No fee mechanism implemented"
        ]
    },
    {
        "code": "module SimpleBridge { use std::signer; use aptos_framework::coin; use aptos_framework::event; struct BridgeEvent has drop, store { from_chain: u8, to_chain: u8, amount: u64, recipient: address, } struct Bridge has key { events: event::EventHandle<BridgeEvent>, } public fun initialize(account: &signer) { move_to(account, Bridge { events: account::new_event_handle<BridgeEvent>(account), }); } public fun lock_tokens<CoinType>(account: &signer, amount: u64, to_chain: u8) acquires Bridge { let sender = signer::address_of(account); coin::transfer<CoinType>(account, @bridge_reserve, amount); let bridge = borrow_global_mut<Bridge>(@bridge); event::emit_event(&mut bridge.events, BridgeEvent { from_chain: 1, // Assuming Aptos is chain 1 to_chain, amount, recipient: sender, }); } public fun unlock_tokens<CoinType>(account: &signer, amount: u64, recipient: address, from_chain: u8) acquires Bridge { assert!(signer::address_of(account) == @bridge_admin, 1); coin::transfer<CoinType>(@bridge_reserve, recipient, amount); let bridge = borrow_global_mut<Bridge>(@bridge_admin); event::emit_event(&mut bridge.events, BridgeEvent { from_chain, to_chain: 1, // Assuming Aptos is chain 1 amount, recipient, }); } }",
        "vulnerabilities": [
            "Centralized control of token unlocking",
            "No verification of cross-chain events",
            "Lack of pausability in case of emergency",
            "Missing access control for initialization",
            "No mechanism to handle failed transfers"
        ]
    },
    {
        "code": "module SimpleOracle { use std::signer; use aptos_framework::timestamp; struct PriceData has key { price: u64, last_update: u64, } public fun initialize(account: &signer) { move_to(account, PriceData { price: 0, last_update: 0 }); } public fun update_price(account: &signer, new_price: u64) acquires PriceData { assert!(signer::address_of(account) == @oracle_admin, 1); let price_data = borrow_global_mut<PriceData>(@oracle_admin); price_data.price = new_price; price_data.last_update = timestamp::now_seconds(); } public fun get_price(): (u64, u64) acquires PriceData { let price_data = borrow_global<PriceData>(@oracle_admin); (price_data.price, price_data.last_update) } public fun is_price_fresh(): bool acquires PriceData { let price_data = borrow_global<PriceData>(@oracle_admin); timestamp::now_seconds() - price_data.last_update < 3600 // 1 hour freshness } }",
        "vulnerabilities": [
            "Single point of failure with one oracle",
            "No aggregation of multiple price sources",
            "Lack of access control for price queries",
            "Missing event emissions for price updates",
            "No mechanism to handle extreme price volatility"
        ]
    },
    {
        "code": "module SimpleLottery { use aptos_framework::coin; struct Lottery has key { total_pool: u64, players: vector<address>, } public fun enter_lottery(account: &signer, amount: u64) acquires Lottery { let sender = signer::address_of(account); let lottery = borrow_global_mut<Lottery>(@lottery_address); lottery.total_pool = lottery.total_pool + amount; vector::push_back(&mut lottery.players, sender); coin::transfer(account, @lottery_address, amount); } public fun draw_winner(account: &signer) acquires Lottery { let lottery = borrow_global_mut<Lottery>(@lottery_address); let winner_index = (timestamp() % vector::length(&lottery.players)) as u64; let winner = vector::borrow(&lottery.players, winner_index); coin::transfer(&*winner, lottery.total_pool); move_from<Lottery>(@lottery_address); } }",
        "vulnerabilities": [            
            "No randomness source for draw_winner function",            
            "Potential for reentrancy attacks"        
        ]
    },
    {
        "code": "module Charity { use aptos_framework::coin; struct Donation has key { donor: address, amount: u64, } public fun donate(account: &signer, amount: u64) { let donor = signer::address_of(account); move_to(account, Donation { donor: donor, amount: amount }); coin::transfer(account, @charity_address, amount); } public fun withdraw(account: &signer, amount: u64) acquires Donation { let donation = borrow_global_mut<Donation>(@charity_address); assert!(donation.amount >= amount, 1); coin::transfer(account, amount); donation.amount = donation.amount - amount; } }",
        "vulnerabilities": [            
            "No limit on withdrawals",            
            "No tracking of total donations"        
        ]
    },
    {
        "code": "module RealEstate { use aptos_framework::coin; struct Property has key { id: u64, owner: address, price: u64, } public fun register_property(account: &signer, id: u64, price: u64) { let owner = signer::address_of(account); move_to(account, Property { id: id, owner: owner, price: price }); } public fun buy_property(account: &signer, id: u64) acquires Property { let property = borrow_global_mut<Property>(@property_address); assert!(property.id == id, 1); assert!(property.price <= coin::balance(account), 2); coin::transfer(account, &property.owner, property.price); property.owner = signer::address_of(account); } }",
        "vulnerabilities": [            
            "No check for existing property ID",            
            "No price validation"        
        ]
    },
    {
        "code": "module IdentityVerification { use std::signer; struct Identity has key { verified: bool, } public fun create_identity(account: &signer) { let owner = signer::address_of(account); move_to(account, Identity { verified: false }); } public fun verify_identity(account: &signer) acquires Identity { let identity = borrow_global_mut<Identity>(@identity_address); assert!(identity.verified == false, 1); identity.verified = true; } }",
        "vulnerabilities": [            
            "No mechanism to handle disputes",            
            "No multi-factor verification"        
        ]
    },
    {
        "code": "module SupplyChain { use std::signer; struct Item has key { id: u64, owner: address, status: u64, } public fun register_item(account: &signer, id: u64, status: u64) { let owner = signer::address_of(account); move_to(account, Item { id: id, owner: owner, status: status }); } public fun update_status(account: &signer, id: u64, status: u64) acquires Item { let item = borrow_global_mut<Item>(@item_address); assert!(item.id == id, 1); item.status = status; } }",
        "vulnerabilities": [            
            "No access control for update_status function",            
            "No mechanism to handle counterfeit items"        
        ]
    },
    {
        "code": "module TimeLock { use aptos_framework::coin; struct TimeLock has key { amount: u64, release_time: u64, } public fun create_timelock(account: &signer, amount: u64, release_time: u64) { move_to(account, TimeLock { amount: amount, release_time: release_time }); coin::transfer(account, @timelock_address, amount); } public fun withdraw(account: &signer) acquires TimeLock { let timelock = borrow_global_mut<TimeLock>(@timelock_address); assert!(timelock.release_time <= timestamp(), 1); coin::transfer(account, timelock.amount); move_from<TimeLock>(@timelock_address); } }",
        "vulnerabilities": [            
            "No mechanism to extend release time",            
            "Potential for integer overflow in release_time"        
        ]

    },
    {
        "code": "module Governance { use aptos_framework::coin; struct Proposal has key { description: vector<u8>, votes: u64, executed: bool, } public fun create_proposal(account: &signer, description: vector<u8>) { move_to(account, Proposal { description: description, votes: 0, executed: false }); } public fun vote(account: &signer, id: u64, weight: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@proposal_address); assert!(proposal.executed == false, 1); proposal.votes = proposal.votes + weight; } public fun execute_proposal(account: &signer, id: u64) acquires Proposal { let proposal = borrow_global_mut<Proposal>(@proposal_address); assert!(proposal.votes > 0, 2); proposal.executed = true; } }",
        "vulnerabilities": [            
            "No quorum mechanism",            
            "No proposal expiration"        
        ]
    },
    {
        "code": "module Loan { use aptos_framework::coin; struct Loan has key { amount: u64, borrower: address, interest: u64, } public fun request_loan(account: &signer, amount: u64, interest: u64) { let borrower = signer::address_of(account); move_to(account, Loan { amount: amount, borrower: borrower, interest: interest }); coin::transfer(account, @loan_address, amount); } public fun repay_loan(account: &signer) acquires Loan { let loan = borrow_global_mut<Loan>(@loan_address); let repayment_amount = loan.amount + loan.interest; coin::transfer(account, repayment_amount); move_from<Loan>(@loan_address); } }",
        "vulnerabilities": [            
            "No collateral mechanism",            
            "Interest rate not validated"        
        ]
    },
    {
        "code": "module Rental { use aptos_framework::coin; struct Rental has key { item_id: u64, renter: address, duration: u64, } public fun rent_item(account: &signer, item_id: u64, duration: u64) { let renter = signer::address_of(account); move_to(account, Rental { item_id: item_id, renter: renter, duration: duration }); } public fun return_item(account: &signer, item_id: u64) acquires Rental { let rental = borrow_global_mut<Rental>(@rental_address); assert!(rental.item_id == item_id, 1); move_from<Rental>(@rental_address); } }",
        "vulnerabilities": [            
            "No mechanism to extend rental duration",            
            "No penalty for late return"        
        ]
    },
    {
        "code": "module Dividend { use aptos_framework::coin; struct Shareholder has key { shares: u64, } struct Dividend has key { amount: u64, distributed: bool, } public fun declare_dividend(account: &signer, amount: u64) { move_to(account, Dividend { amount: amount, distributed: false }); } public fun distribute_dividends(account: &signer) acquires Dividend { let dividend = borrow_global_mut<Dividend>(@dividend_address); assert!(dividend.distributed == false, 1); dividend.distributed = true; let shareholders = get_all_shareholders(); for shareholder in shareholders { let payout = (dividend.amount * shareholder.shares) / total_shares(); coin::transfer(&shareholder.address, payout); } } }",
        "vulnerabilities": [            
            "No mechanism to handle new shareholders",            
            "Potential for integer overflow in payout calculation"        
        ]
    }






]